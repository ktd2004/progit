#. extracted from en/08-git-and-other-scms/01-chapter8.markdown
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-01-02 21:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.9.0\n"

#: en/08-git-and-other-scms/01-chapter8.markdown:1
msgid "# Git and Other Systems #"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:3
msgid ""
"The world isn’t perfect. Usually, you can’t immediately switch every project "
"you come in contact with to Git. Sometimes you’re stuck on a project using "
"another VCS, and many times that system is Subversion. You’ll spend the "
"first part of this chapter learning about `git svn`, the bidirectional "
"Subversion gateway tool in Git."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:5
msgid ""
"At some point, you may want to convert your existing project to Git. The "
"second part of this chapter covers how to migrate your project into Git: "
"first from Subversion, then from Perforce, and finally via a custom import "
"script for a nonstandard importing case. "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:7
msgid "## Git and Subversion ##"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:9
msgid ""
"Currently, the majority of open source development projects and a large "
"number of corporate projects use Subversion to manage their source code. "
"It’s the most popular open source VCS and has been around for nearly a "
"decade. It’s also very similar in many ways to CVS, which was the big boy of "
"the source-control world before that."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:11
msgid ""
"One of Git’s great features is a bidirectional bridge to Subversion called "
"`git svn`. This tool allows you to use Git as a valid client to a Subversion "
"server, so you can use all the local features of Git and then push to a "
"Subversion server as if you were using Subversion locally. This means you "
"can do local branching and merging, use the staging area, use rebasing and "
"cherry-picking, and so on, while your collaborators continue to work in "
"their dark and ancient ways. It’s a good way to sneak Git into the corporate "
"environment and help your fellow developers become more efficient while you "
"lobby to get the infrastructure changed to support Git fully. The "
"Subversion bridge is the gateway drug to the DVCS world."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:13
msgid "### git svn ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:15
msgid ""
"The base command in Git for all the Subversion bridging commands is `git "
"svn`. You preface everything with that. It takes quite a few commands, so "
"you’ll learn about the common ones while going through a few small "
"workflows."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:17
msgid ""
"It’s important to note that when you’re using `git svn`, you’re interacting "
"with Subversion, which is a system that is far less sophisticated than Git. "
"Although you can easily do local branching and merging, it’s generally best "
"to keep your history as linear as possible by rebasing your work and "
"avoiding doing things like simultaneously interacting with a Git remote "
"repository."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:19
msgid ""
"Don’t rewrite your history and try to push again, and don’t push to a "
"parallel Git repository to collaborate with fellow Git developers at the "
"same time. Subversion can have only a single linear history, and confusing "
"it is very easy. If you’re working with a team, and some are using SVN and "
"others are using Git, make sure everyone is using the SVN server to "
"collaborate — doing so will make your life easier."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:21
msgid "### Setting Up ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:23
msgid ""
"To demonstrate this functionality, you need a typical SVN repository that "
"you have write access to. If you want to copy these examples, you’ll have to "
"make a writeable copy of my test repository. In order to do that easily, "
"you can use a tool called `svnsync` that comes with more recent versions of "
"Subversion — it should be distributed with at least 1.4. For these tests, I "
"created a new Subversion repository on Google code that was a partial copy "
"of the `protobuf` project, which is a tool that encodes structured data for "
"network transmission. "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:25
msgid ""
"To follow along, you first need to create a new local Subversion repository:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:27
msgid ""
"\t$ mkdir /tmp/test-svn\n"
"\t$ svnadmin create /tmp/test-svn"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:30
msgid ""
"Then, enable all users to change revprops — the easy way is to add a pre-"
"revprop-change script that always exits 0:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:32
msgid ""
"\t$ cat /tmp/test-svn/hooks/pre-revprop-change \n"
"\t#!/bin/sh\n"
"\texit 0;\n"
"\t$ chmod +x /tmp/test-svn/hooks/pre-revprop-change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:37
msgid ""
"You can now sync this project to your local machine by calling `svnsync "
"init` with the to and from repositories."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:39
msgid ""
"\t$ svnsync init file:///tmp/test-svn http://progit-"
"example.googlecode.com/svn/ "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:41
msgid ""
"This sets up the properties to run the sync. You can then clone the code by "
"running"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:43
msgid ""
"\t$ svnsync sync file:///tmp/test-svn\n"
"\tCommitted revision 1.\n"
"\tCopied properties for revision 1.\n"
"\tCommitted revision 2.\n"
"\tCopied properties for revision 2.\n"
"\tCommitted revision 3.\n"
"\t..."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:51
msgid ""
"Although this operation may take only a few minutes, if you try to copy the "
"original repository to another remote repository instead of a local one, the "
"process will take nearly an hour, even though there are fewer than 100 "
"commits. Subversion has to clone one revision at a time and then push it "
"back into another repository — it’s ridiculously inefficient, but it’s the "
"only easy way to do this."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:53
msgid "### Getting Started ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:55
msgid ""
"Now that you have a Subversion repository to which you have write access, "
"you can go through a typical workflow. You’ll start with the `git svn clone` "
"command, which imports an entire Subversion repository into a local Git "
"repository. Remember that if you’re importing from a real hosted Subversion "
"repository, you should replace the `file:///tmp/test-svn` here with the URL "
"of your Subversion repository:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:57
msgid ""
"\t$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags\n"
"\tInitialized empty Git repository in "
"/Users/schacon/projects/testsvnsync/svn/.git/\n"
"\tr1 = b4e387bc68740b5af56c2a5faf4003ae42bd135c (trunk)\n"
"\t      A    m4/acx_pthread.m4\n"
"\t      A    m4/stl_hash.m4\n"
"\t...\n"
"\tr75 = d1957f3b307922124eec6314e15bcda59e3d9610 (trunk)\n"
"\tFound possible branch point: file:///tmp/test-svn/trunk => \\\n"
"\t    file:///tmp/test-svn /branches/my-calc-branch, 75\n"
"\tFound branch parent: (my-calc-branch) "
"d1957f3b307922124eec6314e15bcda59e3d9610\n"
"\tFollowing parent with do_switch\n"
"\tSuccessfully followed parent\n"
"\tr76 = 8624824ecc0badd73f40ea2f01fce51894189b01 (my-calc-branch)\n"
"\tChecked out HEAD:\n"
"\t file:///tmp/test-svn/branches/my-calc-branch r76"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:73
msgid ""
"This runs the equivalent of two commands — `git svn init` followed by `git "
"svn fetch` — on the URL you provide. This can take a while. The test project "
"has only about 75 commits and the codebase isn’t that big, so it takes just "
"a few minutes. However, Git has to check out each version, one at a time, "
"and commit it individually. For a project with hundreds or thousands of "
"commits, this can literally take hours or even days to finish."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:75
msgid ""
"The `-T trunk -b branches -t tags` part tells Git that this Subversion "
"repository follows the basic branching and tagging conventions. If you name "
"your trunk, branches, or tags differently, you can change these options. "
"Because this is so common, you can replace this entire part with `-s`, which "
"means standard layout and implies all those options. The following command "
"is equivalent:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:77
msgid "\t$ git svn clone file:///tmp/test-svn -s"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:79
msgid ""
"At this point, you should have a valid Git repository that has imported your "
"branches and tags:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:81
msgid ""
"\t$ git branch -a\n"
"\t* master\n"
"\t  my-calc-branch\n"
"\t  tags/2.0.2\n"
"\t  tags/release-2.0.1\n"
"\t  tags/release-2.0.2\n"
"\t  tags/release-2.0.2rc1\n"
"\t  trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:90
msgid ""
"It’s important to note how this tool namespaces your remote references "
"differently. When you’re cloning a normal Git repository, you get all the "
"branches on that remote server available locally as something like "
"`origin/[branch]` - namespaced by the name of the remote. However, `git svn` "
"assumes that you won’t have multiple remotes and saves all its references "
"to points on the remote server with no namespacing. You can use the Git "
"plumbing command `show-ref` to look at all your full reference names:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:92
msgid ""
"\t$ git show-ref\n"
"\t1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/heads/master\n"
"\taee1ecc26318164f355a883f5d99cff0c852d3c4 refs/remotes/my-calc-branch\n"
"\t03d09b0e2aad427e34a6d50ff147128e76c0e0f5 refs/remotes/tags/2.0.2\n"
"\t50d02cc0adc9da4319eeba0900430ba219b9c376 refs/remotes/tags/release-2.0.1\n"
"\t4caaa711a50c77879a91b8b90380060f672745cb refs/remotes/tags/release-2.0.2\n"
"\t1c4cb508144c513ff1214c3488abe66dcb92916f refs/remotes/tags/release-2.0.2rc1\n"
"\t1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:101
msgid "A normal Git repository looks more like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:103
msgid ""
"\t$ git show-ref\n"
"\t83e38c7a0af325a9722f2fdc56b10188806d83a1 refs/heads/master\n"
"\t3e15e38c198baac84223acfc6224bb8b99ff2281 refs/remotes/gitserver/master\n"
"\t0a30dd3b0c795b80212ae723640d4e5d48cabdff refs/remotes/origin/master\n"
"\t25812380387fdd55f916652be4881c6f11600d6f refs/remotes/origin/testing"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:109
msgid ""
"You have two remote servers: one named `gitserver` with a `master` branch; "
"and another named `origin` with two branches, `master` and `testing`. "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:111
msgid ""
"Notice how in the example of remote references imported from `git svn`, tags "
"are added as remote branches, not as real Git tags. Your Subversion import "
"looks like it has a remote named tags with branches under it."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:113
msgid "### Committing Back to Subversion ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:115
msgid ""
"Now that you have a working repository, you can do some work on the project "
"and push your commits back upstream, using Git effectively as a SVN client. "
"If you edit one of the files and commit it, you have a commit that exists in "
"Git locally that doesn’t exist on the Subversion server:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:117
msgid ""
"\t$ git commit -am 'Adding git-svn instructions to the README'\n"
"\t[master 97031e5] Adding git-svn instructions to the README\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:121
msgid ""
"Next, you need to push your change upstream. Notice how this changes the way "
"you work with Subversion — you can do several commits offline and then push "
"them all at once to the Subversion server. To push to a Subversion server, "
"you run the `git svn dcommit` command:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:123
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      README.txt\n"
"\tCommitted r79\n"
"\t       M      README.txt\n"
"\tr79 = 938b1a547c2cc92033b74d32030e86468294a5c8 (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:132
msgid ""
"This takes all the commits you’ve made on top of the Subversion server code, "
"does a Subversion commit for each, and then rewrites your local Git commit "
"to include a unique identifier. This is important because it means that all "
"the SHA-1 checksums for your commits change. Partly for this reason, working "
"with Git-based remote versions of your projects concurrently with a "
"Subversion server isn’t a good idea. If you look at the last commit, you can "
"see the new `git-svn-id` that was added:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:134
msgid ""
"\t$ git log -1\n"
"\tcommit 938b1a547c2cc92033b74d32030e86468294a5c8\n"
"\tAuthor: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\n"
"\tDate:   Sat May 2 22:06:44 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:139
msgid "\t    Adding git-svn instructions to the README"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:141
msgid ""
"\t    git-svn-id: file:///tmp/test-svn/trunk@79 4c93b258-373f-11de-"
"be05-5f7a86268029"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:143
msgid ""
"Notice that the SHA checksum that originally started with `97031e5` when you "
"committed now begins with `938b1a5`. If you want to push to both a Git "
"server and a Subversion server, you have to push (`dcommit`) to the "
"Subversion server first, because that action changes your commit data."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:145
msgid "### Pulling in New Changes ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:147
msgid ""
"If you’re working with other developers, then at some point one of you will "
"push, and then the other one will try to push a change that conflicts. That "
"change will be rejected until you merge in their work. In `git svn`, it "
"looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:149
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\tMerge conflict during commit: Your file or directory 'README.txt' is "
"probably \\\n"
"\tout-of-date: resource out of date; try updating at "
"/Users/schacon/libexec/git-\\\n"
"\tcore/git-svn line 482"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:155
msgid ""
"To resolve this situation, you can run `git svn rebase`, which pulls down "
"any changes on the server that you don’t have yet and rebases any work you "
"have on top of what is on the server:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:157
msgid ""
"\t$ git svn rebase\n"
"\t       M      README.txt\n"
"\tr80 = ff829ab914e8775c7c025d741beb3d523ee30bc4 (trunk)\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tApplying: first user change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:163
msgid ""
"Now, all your work is on top of what is on the Subversion server, so you can "
"successfully `dcommit`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:165
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      README.txt\n"
"\tCommitted r81\n"
"\t       M      README.txt\n"
"\tr81 = 456cbe6337abe49154db70106d1836bc1332deed (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:174
msgid ""
"It’s important to remember that unlike Git, which requires you to merge "
"upstream work you don’t yet have locally before you can push, `git svn` "
"makes you do that only if the changes conflict. If someone else pushes a "
"change to one file and then you push a change to another file, your "
"`dcommit` will work fine:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:176
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      configure.ac\n"
"\tCommitted r84\n"
"\t       M      autogen.sh\n"
"\tr83 = 8aa54a74d452f82eee10076ab2584c1fc424853b (trunk)\n"
"\t       M      configure.ac\n"
"\tr84 = cdbac939211ccb18aa744e581e46563af5d962d0 (trunk)\n"
"\tW: d2f23b80f67aaaa1f6f5aaef48fce3263ac71a92 and refs/remotes/trunk differ, "
"\\\n"
"\t  using rebase:\n"
"\t:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 \\\n"
"\t  015e4c98c482f0fa71e4d5434338014530b37fa6 M   autogen.sh\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tNothing to do."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:191
msgid ""
"This is important to remember, because the outcome is a project state that "
"didn’t exist on either of your computers when you pushed. If the changes are "
"incompatible but don’t conflict, you may get issues that are difficult to "
"diagnose. This is different than using a Git server — in Git, you can fully "
"test the state on your client system before publishing it, whereas in SVN, "
"you can’t ever be certain that the states immediately before commit and "
"after commit are identical."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:193
msgid ""
"You should also run this command to pull in changes from the Subversion "
"server, even if you’re not ready to commit yourself. You can run `git svn "
"fetch` to grab the new data, but `git svn rebase` does the fetch and then "
"updates your local commits."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:195
msgid ""
"\t$ git svn rebase\n"
"\t       M      generate_descriptor_proto.sh\n"
"\tr82 = bd16df9173e424c6f52c337ab6efa7f7643282f1 (trunk)\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tFast-forwarded master to refs/remotes/trunk."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:201
msgid ""
"Running `git svn rebase` every once in a while makes sure your code is "
"always up to date. You need to be sure your working directory is clean when "
"you run this, though. If you have local changes, you must either stash your "
"work or temporarily commit it before running `git svn rebase` — otherwise, "
"the command will stop if it sees that the rebase will result in a merge "
"conflict."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:203
msgid "### Git Branching Issues ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:205
msgid ""
"When you’ve become comfortable with a Git workflow, you’ll likely create "
"topic branches, do work on them, and then merge them in. If you’re pushing "
"to a Subversion server via git svn, you may want to rebase your work onto a "
"single branch each time instead of merging branches together. The reason to "
"prefer rebasing is that Subversion has a linear history and doesn’t deal "
"with merges like Git does, so git svn follows only the first parent when "
"converting the snapshots into Subversion commits."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:207
msgid ""
"Suppose your history looks like the following: you created an `experiment` "
"branch, did two commits, and then merged them back into `master`. When you "
"`dcommit`, you see output like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:209
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      CHANGES.txt\n"
"\tCommitted r85\n"
"\t       M      CHANGES.txt\n"
"\tr85 = 4bfebeec434d156c36f2bcd18f4e3d97dc3269a2 (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk\n"
"\tCOPYING.txt: locally modified\n"
"\tINSTALL.txt: locally modified\n"
"\t       M      COPYING.txt\n"
"\t       M      INSTALL.txt\n"
"\tCommitted r86\n"
"\t       M      INSTALL.txt\n"
"\t       M      COPYING.txt\n"
"\tr86 = 2647f6b86ccfcaad4ec58c520e369ec81f7c283c (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:228
msgid ""
"Running `dcommit` on a branch with merged history works fine, except that "
"when you look at your Git project history, it hasn’t rewritten either of the "
"commits you made on the `experiment` branch — instead, all those changes "
"appear in the SVN version of the single merge commit."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:230
msgid ""
"When someone else clones that work, all they see is the merge commit with "
"all the work squashed into it; they don’t see the commit data about where it "
"came from or when it was committed."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:232
msgid "### Subversion Branching ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:234
msgid ""
"Branching in Subversion isn’t the same as branching in Git; if you can avoid "
"using it much, that’s probably best. However, you can create and commit to "
"branches in Subversion using git svn."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:236
msgid "#### Creating a New SVN Branch ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:238
msgid ""
"To create a new branch in Subversion, you run `git svn branch [branchname]`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:240
msgid ""
"\t$ git svn branch opera\n"
"\tCopying file:///tmp/test-svn/trunk at r87 to file:///tmp/test-"
"svn/branches/opera...\n"
"\tFound possible branch point: file:///tmp/test-svn/trunk => \\\n"
"\t  file:///tmp/test-svn/branches/opera, 87\n"
"\tFound branch parent: (opera) 1f6bfe471083cbca06ac8d4176f7ad4de0d62e5f\n"
"\tFollowing parent with do_switch\n"
"\tSuccessfully followed parent\n"
"\tr89 = 9b6fe0b90c5c9adf9165f700897518dbc54a7cbf (opera)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:249
msgid ""
"This does the equivalent of the `svn copy trunk branches/opera` command in "
"Subversion and operates on the Subversion server. It’s important to note "
"that it doesn’t check you out into that branch; if you commit at this point, "
"that commit will go to `trunk` on the server, not `opera`."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:251
msgid "### Switching Active Branches ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:253
msgid ""
"Git figures out what branch your dcommits go to by looking for the tip of "
"any of your Subversion branches in your history — you should have only one, "
"and it should be the last one with a `git-svn-id` in your current branch "
"history. "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:255
msgid ""
"If you want to work on more than one branch simultaneously, you can set up "
"local branches to `dcommit` to specific Subversion branches by starting them "
"at the imported Subversion commit for that branch. If you want an `opera` "
"branch that you can work on separately, you can run"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:257
msgid "\t$ git branch opera remotes/opera"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:259
msgid ""
"Now, if you want to merge your `opera` branch into `trunk` (your `master` "
"branch), you can do so with a normal `git merge`. But you need to provide a "
"descriptive commit message (via `-m`), or the merge will say \"Merge branch "
"opera\" instead of something useful."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:261
msgid ""
"Remember that although you’re using `git merge` to do this operation, and "
"the merge likely will be much easier than it would be in Subversion (because "
"Git will automatically detect the appropriate merge base for you), this "
"isn’t a normal Git merge commit. You have to push this data back to a "
"Subversion server that can’t handle a commit that tracks more than one "
"parent; so, after you push it up, it will look like a single commit that "
"squashed in all the work of another branch under a single commit. After you "
"merge one branch into another, you can’t easily go back and continue working "
"on that branch, as you normally can in Git. The `dcommit` command that you "
"run erases any information that says what branch was merged in, so "
"subsequent merge-base calculations will be wrong — the dcommit makes your "
"`git merge` result look like you ran `git merge --squash`. Unfortunately, "
"there’s no good way to avoid this situation — Subversion can’t store this "
"information, so you’ll always be crippled by its limitations while you’re "
"using it as your server. To avoid issues, you should delete the local branch "
"(in this case, `opera`) after you merge it into trunk."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:263
msgid "### Subversion Commands ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:265
msgid ""
"The `git svn` toolset provides a number of commands to help ease the "
"transition to Git by providing some functionality that’s similar to what you "
"had in Subversion. Here are a few commands that give you what Subversion "
"used to."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:267
msgid "#### SVN Style History ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:269
msgid ""
"If you’re used to Subversion and want to see your history in SVN output "
"style, you can run `git svn log` to view your commit history in SVN "
"formatting:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:271
msgid ""
"\t$ git svn log\n"
"\t------------------------------------------------------------------------\n"
"\tr87 | schacon | 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:275
msgid "\tautogen change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:277
msgid ""
"\t------------------------------------------------------------------------\n"
"\tr86 | schacon | 2009-05-02 16:00:21 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:280
msgid "\tMerge branch 'experiment'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:282
msgid ""
"\t------------------------------------------------------------------------\n"
"\tr85 | schacon | 2009-05-02 16:00:09 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:285
msgid "\tupdated the changelog"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:287
msgid ""
"You should know two important things about `git svn log`. First, it works "
"offline, unlike the real `svn log` command, which asks the Subversion server "
"for the data. Second, it only shows you commits that have been committed up "
"to the Subversion server. Local Git commits that you haven’t dcommited "
"don’t show up; neither do commits that people have made to the Subversion "
"server in the meantime. It’s more like the last known state of the commits "
"on the Subversion server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:289
msgid "#### SVN Annotation ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:291
msgid ""
"Much as the `git svn log` command simulates the `svn log` command offline, "
"you can get the equivalent of `svn annotate` by running `git svn blame "
"[FILE]`. The output looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:293
msgid ""
"\t$ git svn blame README.txt \n"
"\t 2   temporal Protocol Buffers - Google's data interchange format\n"
"\t 2   temporal Copyright 2008 Google Inc.\n"
"\t 2   temporal http://code.google.com/apis/protocolbuffers/\n"
"\t 2   temporal \n"
"\t22   temporal C++ Installation - Unix\n"
"\t22   temporal =======================\n"
"\t 2   temporal \n"
"\t79    schacon Committing in git-svn.\n"
"\t78    schacon \n"
"\t 2   temporal To build and install the C++ Protocol Buffer runtime and the "
"Protocol\n"
"\t 2   temporal Buffer compiler (protoc) execute the following:\n"
"\t 2   temporal "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:307
msgid ""
"Again, it doesn’t show commits that you did locally in Git or that have been "
"pushed to Subversion in the meantime."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:309
msgid "#### SVN Server Information ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:311
msgid ""
"You can also get the same sort of information that `svn info` gives you by "
"running `git svn info`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:313
msgid ""
"\t$ git svn info\n"
"\tPath: .\n"
"\tURL: https://schacon-test.googlecode.com/svn/trunk\n"
"\tRepository Root: https://schacon-test.googlecode.com/svn\n"
"\tRepository UUID: 4c93b258-373f-11de-be05-5f7a86268029\n"
"\tRevision: 87\n"
"\tNode Kind: directory\n"
"\tSchedule: normal\n"
"\tLast Changed Author: schacon\n"
"\tLast Changed Rev: 87\n"
"\tLast Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:325
msgid ""
"This is like `blame` and `log` in that it runs offline and is up to date "
"only as of the last time you communicated with the Subversion server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:327
msgid "#### Ignoring What Subversion Ignores ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:329
msgid ""
"If you clone a Subversion repository that has `svn:ignore` properties set "
"anywhere, you’ll likely want to set corresponding `.gitignore` files so you "
"don’t accidentally commit files that you shouldn’t. `git svn` has two "
"commands to help with this issue. The first is `git svn create-ignore`, "
"which automatically creates corresponding `.gitignore` files for you so your "
"next commit can include them."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:331
msgid ""
"The second command is `git svn show-ignore`, which prints to stdout the "
"lines you need to put in a `.gitignore` file so you can redirect the output "
"into your project exclude file:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:333
msgid "\t$ git svn show-ignore > .git/info/exclude"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:335
msgid ""
"That way, you don’t litter the project with `.gitignore` files. This is a "
"good option if you’re the only Git user on a Subversion team, and your "
"teammates don’t want `.gitignore` files in the project."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:337
msgid "### Git-Svn Summary ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:339
msgid ""
"The `git svn` tools are useful if you’re stuck with a Subversion server for "
"now or are otherwise in a development environment that necessitates running "
"a Subversion server. You should consider it crippled Git, however, or you’ll "
"hit issues in translation that may confuse you and your collaborators. To "
"stay out of trouble, try to follow these guidelines:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:341
msgid ""
"* Keep a linear Git history that doesn’t contain merge commits made by `git "
"merge`. Rebase any work you do outside of your mainline branch back onto it; "
"don’t merge it in.\n"
"* Don’t set up and collaborate on a separate Git server. Possibly have one "
"to speed up clones for new developers, but don’t push anything to it that "
"doesn’t have a `git-svn-id` entry. You may even want to add a `pre-receive` "
"hook that checks each commit message for a `git-svn-id` and rejects pushes "
"that contain commits without it."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:344
msgid ""
"If you follow those guidelines, working with a Subversion server can be more "
"bearable. However, if it’s possible to move to a real Git server, doing so "
"can gain your team a lot more."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:346
msgid "## Migrating to Git ##"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:348
msgid ""
"If you have an existing codebase in another VCS but you’ve decided to start "
"using Git, you must migrate your project one way or another. This section "
"goes over some importers that are included with Git for common systems and "
"then demonstrates how to develop your own custom importer."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:350
msgid "### Importing ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:352
msgid ""
"You’ll learn how to import data from two of the bigger professionally used "
"SCM systems — Subversion and Perforce — both because they make up the "
"majority of users I hear of who are currently switching, and because high-"
"quality tools for both systems are distributed with Git."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:354
msgid "### Subversion ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:356
msgid ""
"If you read the previous section about using `git svn`, you can easily use "
"those instructions to `git svn clone` a repository; then, stop using the "
"Subversion server, push to a new Git server, and start using that. If you "
"want the history, you can accomplish that as quickly as you can pull the "
"data out of the Subversion server (which may take a while)."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:358
msgid ""
"However, the import isn’t perfect; and because it will take so long, you may "
"as well do it right. The first problem is the author information. In "
"Subversion, each person committing has a user on the system who is recorded "
"in the commit information. The examples in the previous section show "
"`schacon` in some places, such as the `blame` output and the `git svn log`. "
"If you want to map this to better Git author data, you need a mapping from "
"the Subversion users to the Git authors. Create a file called `users.txt` "
"that has this mapping in a format like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:360
msgid ""
"\tschacon = Scott Chacon <schacon@geemail.com>\n"
"\tselse = Someo Nelse <selse@geemail.com>"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:363
msgid "To get a list of the author names that SVN uses, you can run this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:365
msgid ""
"\t$ svn log --xml | grep -P \"^<author\" | sort -u | \\\n"
"\t      perl -pe 's/<author>(.*?)<\\/author>/$1 = /'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:368
msgid ""
"That gives you the log output in XML format — you can look for the authors, "
"create a unique list, and then strip out the XML. (Obviously this only works "
"on a machine with `grep`, `sort`, and `perl` installed.) Then, redirect "
"that output into your users.txt file so you can add the equivalent Git user "
"data next to each entry."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:370
msgid ""
"You can provide this file to `git svn` to help it map the author data more "
"accurately. You can also tell `git svn` not to include the metadata that "
"Subversion normally imports, by passing `--no-metadata` to the `clone` or "
"`init` command. This makes your `import` command look like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:372
msgid ""
"\t$ git-svn clone http://my-project.googlecode.com/svn/ \\\n"
"\t      --authors-file=users.txt --no-metadata -s my_project"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:375
msgid ""
"Now you should have a nicer Subversion import in your `my_project` "
"directory. Instead of commits that look like this"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:377
msgid ""
"\tcommit 37efa680e8473b615de980fa935944215428a35a\n"
"\tAuthor: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\n"
"\tDate:   Sun May 3 00:12:22 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:381
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:381"
msgid "\t    fixed install - go to trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:383
msgid ""
"\t    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258"
"-373f-11de-\n"
"\t    be05-5f7a86268029\n"
"they look like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:387
msgid ""
"\tcommit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2\n"
"\tAuthor: Scott Chacon <schacon@geemail.com>\n"
"\tDate:   Sun May 3 00:12:22 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:391
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:391"
msgid "\t    fixed install - go to trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:393
msgid ""
"Not only does the Author field look a lot better, but the `git-svn-id` is no "
"longer there, either."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:395
msgid ""
"You need to do a bit of `post-import` cleanup. For one thing, you should "
"clean up the weird references that `git svn` set up. First you’ll move the "
"tags so they’re actual tags rather than strange remote branches, and then "
"you’ll move the rest of the branches so they’re local."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:397
msgid "To move the tags to be proper Git tags, run"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:399
msgid ""
"\t$ git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while "
"read tagname; do git tag \"$tagname\" \"tags/$tagname\"; git branch -r -d "
"\"tags/$tagname\"; done"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:401
msgid ""
"This takes the references that were remote branches that started with `tag/` "
"and makes them real (lightweight) tags."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:403
msgid ""
"Next, move the rest of the references under `refs/remotes` to be local "
"branches:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:405
msgid ""
"\t$ git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read "
"branchname; do git branch \"$branchname\" \"refs/remotes/$branchname\"; git "
"branch -r -d \"$branchname\"; done"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:407
msgid ""
"Now all the old branches are real Git branches and all the old tags are real "
"Git tags. The last thing to do is add your new Git server as a remote and "
"push to it. Here is an example of adding your server as a remote:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:409
msgid "\t$ git remote add origin git@my-git-server:myrepository.git"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:411
msgid ""
"Because you want all your branches and tags to go up, you can now run this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:413
msgid ""
"\t$ git push origin --all\n"
"\t$ git push origin --tags"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:416
msgid ""
"All your branches and tags should be on your new Git server in a nice, clean "
"import."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:418
msgid "### Perforce ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:420
msgid ""
"The next system you’ll look at importing from is Perforce. A Perforce "
"importer is also distributed with Git, but only in the `contrib` section of "
"the source code — it isn’t available by default like `git svn`. To run it, "
"you must get the Git source code, which you can download from "
"git.kernel.org:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:422
msgid ""
"\t$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t$ cd git/contrib/fast-import"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:425
msgid ""
"In this `fast-import` directory, you should find an executable Python script "
"named `git-p4`. You must have Python and the `p4` tool installed on your "
"machine for this import to work. For example, you’ll import the Jam project "
"from the Perforce Public Depot. To set up your client, you must export the "
"P4PORT environment variable to point to the Perforce depot:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:427
msgid "\t$ export P4PORT=public.perforce.com:1666"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:429
msgid ""
"Run the `git-p4 clone` command to import the Jam project from the Perforce "
"server, supplying the depot and project path and the path into which you "
"want to import the project:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:431
msgid ""
"\t$ git-p4 clone //public/jam/src@all /opt/p4import\n"
"\tImporting from //public/jam/src@all into /opt/p4import\n"
"\tReinitialized existing Git repository in /opt/p4import/.git/\n"
"\tImport destination: refs/remotes/p4/master\n"
"\tImporting revision 4409 (100%)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:437
msgid ""
"If you go to the `/opt/p4import` directory and run `git log`, you can see "
"your imported work:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:439
msgid ""
"\t$ git log -2\n"
"\tcommit 1fd4ec126171790efd2db83548b85b1bbbc07dc2\n"
"\tAuthor: Perforce staff <support@perforce.com>\n"
"\tDate:   Thu Aug 19 10:18:45 2004 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:444
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:444"
msgid ""
"\t    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\n"
"\t    the main part of the document.  Built new tar/zip balls."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:447
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:447"
msgid "\t    Only 16 months later."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:449
msgid "\t    [git-p4: depot-paths = \"//public/jam/src/\": change = 4409]"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:451
msgid ""
"\tcommit ca8870db541a23ed867f38847eda65bf4363371d\n"
"\tAuthor: Richard Geiger <rmg@perforce.com>\n"
"\tDate:   Tue Apr 22 20:51:34 2003 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:455
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:455"
msgid "\t    Update derived jamgram.c"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:457
msgid "\t    [git-p4: depot-paths = \"//public/jam/src/\": change = 3108]"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:459
msgid ""
"You can see the `git-p4` identifier in each commit. It’s fine to keep that "
"identifier there, in case you need to reference the Perforce change number "
"later. However, if you’d like to remove the identifier, now is the time to "
"do so — before you start doing work on the new repository. You can use `git "
"filter-branch` to remove the identifier strings en masse:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:461
msgid ""
"\t$ git filter-branch --msg-filter '\n"
"\t        sed -e \"/^\\[git-p4:/d\"\n"
"\t'\n"
"\tRewrite 1fd4ec126171790efd2db83548b85b1bbbc07dc2 (123/123)\n"
"\tRef 'refs/heads/master' was rewritten"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:467
msgid ""
"If you run `git log`, you can see that all the SHA-1 checksums for the "
"commits have changed, but the `git-p4` strings are no longer in the commit "
"messages:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:469
msgid ""
"\t$ git log -2\n"
"\tcommit 10a16d60cffca14d454a15c6164378f4082bc5b0\n"
"\tAuthor: Perforce staff <support@perforce.com>\n"
"\tDate:   Thu Aug 19 10:18:45 2004 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:474
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:474"
msgid ""
"\t    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\n"
"\t    the main part of the document.  Built new tar/zip balls."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:477
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:477"
msgid "\t    Only 16 months later."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:479
msgid ""
"\tcommit 2b6c6db311dd76c34c66ec1c40a49405e6b527b2\n"
"\tAuthor: Richard Geiger <rmg@perforce.com>\n"
"\tDate:   Tue Apr 22 20:51:34 2003 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:483
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:483"
msgid "\t    Update derived jamgram.c"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:485
msgid "Your import is ready to push up to your new Git server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:487
msgid "### A Custom Importer ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:489
msgid ""
"If your system isn’t Subversion or Perforce, you should look for an importer "
"online — quality importers are available for CVS, Clear Case, Visual Source "
"Safe, even a directory of archives. If none of these tools works for you, "
"you have a rarer tool, or you otherwise need a more custom importing "
"process, you should use `git fast-import`. This command reads simple "
"instructions from stdin to write specific Git data. It’s much easier to "
"create Git objects this way than to run the raw Git commands or try to write "
"the raw objects (see Chapter 9 for more information). This way, you can "
"write an import script that reads the necessary information out of the "
"system you’re importing from and prints straightforward instructions to "
"stdout. You can then run this program and pipe its output through `git fast-"
"import`."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:491
msgid ""
"To quickly demonstrate, you’ll write a simple importer. Suppose you work in "
"current, you back up your project by occasionally copying the directory into "
"a time-stamped `back_YYYY_MM_DD` backup directory, and you want to import "
"this into Git. Your directory structure looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:493
msgid ""
"\t$ ls /opt/import_from\n"
"\tback_2009_01_02\n"
"\tback_2009_01_04\n"
"\tback_2009_01_14\n"
"\tback_2009_02_03\n"
"\tcurrent"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:500
msgid ""
"In order to import a Git directory, you need to review how Git stores its "
"data. As you may remember, Git is fundamentally a linked list of commit "
"objects that point to a snapshot of content. All you have to do is tell "
"`fast-import` what the content snapshots are, what commit data points to "
"them, and the order they go in. Your strategy will be to go through the "
"snapshots one at a time and create commits with the contents of each "
"directory, linking each commit back to the previous one."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:502
msgid ""
"As you did in the \"An Example Git Enforced Policy\" section of Chapter 7, "
"we’ll write this in Ruby, because it’s what I generally work with and it "
"tends to be easy to read. You can write this example pretty easily in "
"anything you’re familiar with — it just needs to print the appropriate "
"information to stdout. And, if you are running on Windows, this means you'll "
"need to take special care to not introduce carriage returns at the end your "
"lines — git fast-import is very particular about just wanting line feeds "
"(LF) not the carriage return line feeds (CRLF) that Windows uses."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:504
msgid ""
"To begin, you’ll change into the target directory and identify every "
"subdirectory, each of which is a snapshot that you want to import as a "
"commit. You’ll change into each subdirectory and print the commands "
"necessary to export it. Your basic main loop looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:506
msgid "\tlast_mark = nil"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:508
msgid ""
"\t# loop through the directories\n"
"\tDir.chdir(ARGV[0]) do\n"
"\t  Dir.glob(\"*\").each do |dir|\n"
"\t    next if File.file?(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:513
msgid ""
"\t    # move into the target directory\n"
"\t    Dir.chdir(dir) do \n"
"\t      last_mark = print_export(dir, last_mark)\n"
"\t    end\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:520
msgid ""
"You run `print_export` inside each directory, which takes the manifest and "
"mark of the previous snapshot and returns the manifest and mark of this one; "
"that way, you can link them properly. \"Mark\" is the `fast-import` term for "
"an identifier you give to a commit; as you create commits, you give each one "
"a mark that you can use to link to it from other commits. So, the first "
"thing to do in your `print_export` method is generate a mark from the "
"directory name:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:522
msgid "\tmark = convert_dir_to_mark(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:524
msgid ""
"You’ll do this by creating an array of directories and using the index value "
"as the mark, because a mark must be an integer. Your method looks like "
"this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:526
msgid ""
"\t$marks = []\n"
"\tdef convert_dir_to_mark(dir)\n"
"\t  if !$marks.include?(dir)\n"
"\t    $marks << dir\n"
"\t  end\n"
"\t  ($marks.index(dir) + 1).to_s\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:534
msgid ""
"Now that you have an integer representation of your commit, you need a date "
"for the commit metadata. Because the date is expressed in the name of the "
"directory, you’ll parse it out. The next line in your `print_export` file is"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:536
msgid "\tdate = convert_dir_to_date(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:538
msgid "where `convert_dir_to_date` is defined as"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:540
msgid ""
"\tdef convert_dir_to_date(dir)\n"
"\t  if dir == 'current'\n"
"\t    return Time.now().to_i\n"
"\t  else\n"
"\t    dir = dir.gsub('back_', '')\n"
"\t    (year, month, day) = dir.split('_')\n"
"\t    return Time.local(year, month, day).to_i\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:550
msgid ""
"That returns an integer value for the date of each directory. The last piece "
"of meta-information you need for each commit is the committer data, which "
"you hardcode in a global variable:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:552
msgid "\t$author = 'Scott Chacon <schacon@example.com>'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:554
msgid ""
"Now you’re ready to begin printing out the commit data for your importer. "
"The initial information states that you’re defining a commit object and what "
"branch it’s on, followed by the mark you’ve generated, the committer "
"information and commit message, and then the previous commit, if any. The "
"code looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:556
msgid ""
"\t# print the import information\n"
"\tputs 'commit refs/heads/master'\n"
"\tputs 'mark :' + mark\n"
"\tputs \"committer #{$author} #{date} -0700\"\n"
"\texport_data('imported from ' + dir)\n"
"\tputs 'from :' + last_mark if last_mark"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:563
msgid ""
"You hardcode the time zone (-0700) because doing so is easy. If you’re "
"importing from another system, you must specify the time zone as an offset. \n"
"The commit message must be expressed in a special format:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:566
msgid "\tdata (size)\\n(contents)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:568
msgid ""
"The format consists of the word data, the size of the data to be read, a "
"newline, and finally the data. Because you need to use the same format to "
"specify the file contents later, you create a helper method, `export_data`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:570
msgid ""
"\tdef export_data(string)\n"
"\t  print \"data #{string.size}\\n#{string}\"\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:574
msgid ""
"All that’s left is to specify the file contents for each snapshot. This is "
"easy, because you have each one in a directory — you can print out the "
"`deleteall` command followed by the contents of each file in the directory. "
"Git will then record each snapshot appropriately:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:576
msgid ""
"\tputs 'deleteall'\n"
"\tDir.glob(\"**/*\").each do |file|\n"
"\t  next if !File.file?(file)\n"
"\t  inline_data(file)\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:582
msgid ""
"Note:\tBecause many systems think of their revisions as changes from one "
"commit to another, fast-import can also take commands with each commit to "
"specify which files have been added, removed, or modified and what the new "
"contents are. You could calculate the differences between snapshots and "
"provide only this data, but doing so is more complex — you may as well give "
"Git all the data and let it figure it out. If this is better suited to your "
"data, check the `fast-import` man page for details about how to provide your "
"data in this manner."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:584
msgid ""
"The format for listing the new file contents or specifying a modified file "
"with the new contents is as follows:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:586
msgid ""
"\tM 644 inline path/to/file\n"
"\tdata (size)\n"
"\t(file contents)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:590
msgid ""
"Here, 644 is the mode (if you have executable files, you need to detect and "
"specify 755 instead), and inline says you’ll list the contents immediately "
"after this line. Your `inline_data` method looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:592
msgid ""
"\tdef inline_data(file, code = 'M', mode = '644')\n"
"\t  content = File.read(file)\n"
"\t  puts \"#{code} #{mode} inline #{file}\"\n"
"\t  export_data(content)\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:598
msgid ""
"You reuse the `export_data` method you defined earlier, because it’s the "
"same as the way you specified your commit message data. "
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:600
msgid ""
"The last thing you need to do is to return the current mark so it can be "
"passed to the next iteration:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:602
msgid "\treturn mark"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:604
msgid ""
"NOTE: If you are running on Windows you'll need to make sure that you add "
"one extra step. As metioned before, Windows uses CRLF for new line "
"characters while git fast-import expects only LF. To get around this problem "
"and make git fast-import happy, you need to tell ruby to use LF instead of "
"CRLF:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:606
msgid "\t$stdout.binmode"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:608
msgid ""
"That’s it. If you run this script, you’ll get content that looks something "
"like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:610
msgid ""
"\t$ ruby import.rb /opt/import_from \n"
"\tcommit refs/heads/master\n"
"\tmark :1\n"
"\tcommitter Scott Chacon <schacon@geemail.com> 1230883200 -0700\n"
"\tdata 29\n"
"\timported from back_2009_01_02deleteall\n"
"\tM 644 inline file.rb\n"
"\tdata 12\n"
"\tversion two\n"
"\tcommit refs/heads/master\n"
"\tmark :2\n"
"\tcommitter Scott Chacon <schacon@geemail.com> 1231056000 -0700\n"
"\tdata 29\n"
"\timported from back_2009_01_04from :1\n"
"\tdeleteall\n"
"\tM 644 inline file.rb\n"
"\tdata 14\n"
"\tversion three\n"
"\tM 644 inline new.rb\n"
"\tdata 16\n"
"\tnew version one\n"
"\t(...)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:633
msgid ""
"To run the importer, pipe this output through `git fast-import` while in the "
"Git directory you want to import into. You can create a new directory and "
"then run `git init` in it for a starting point, and then run your script:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:635
msgid ""
"\t$ git init\n"
"\tInitialized empty Git repository in /opt/import_to/.git/\n"
"\t$ ruby import.rb /opt/import_from | git fast-import\n"
"\tgit-fast-import statistics:\n"
"\t---------------------------------------------------------------------\n"
"\tAlloc'd objects:       5000\n"
"\tTotal objects:           18 (         1 duplicates                  )\n"
"\t      blobs  :            7 (         1 duplicates          0 deltas)\n"
"\t      trees  :            6 (         0 duplicates          1 deltas)\n"
"\t      commits:            5 (         0 duplicates          0 deltas)\n"
"\t      tags   :            0 (         0 duplicates          0 deltas)\n"
"\tTotal branches:           1 (         1 loads     )\n"
"\t      marks:           1024 (         5 unique    )\n"
"\t      atoms:              3\n"
"\tMemory total:          2255 KiB\n"
"\t       pools:          2098 KiB\n"
"\t     objects:           156 KiB\n"
"\t---------------------------------------------------------------------\n"
"\tpack_report: getpagesize()            =       4096\n"
"\tpack_report: core.packedGitWindowSize =   33554432\n"
"\tpack_report: core.packedGitLimit      =  268435456\n"
"\tpack_report: pack_used_ctr            =          9\n"
"\tpack_report: pack_mmap_calls          =          5\n"
"\tpack_report: pack_open_windows        =          1 /          1\n"
"\tpack_report: pack_mapped              =       1356 /       1356\n"
"\t---------------------------------------------------------------------"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:662
msgid ""
"As you can see, when it completes successfully, it gives you a bunch of "
"statistics about what it accomplished. In this case, you imported 18 objects "
"total for 5 commits into 1 branch. Now, you can run `git log` to see your "
"new history:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:664
msgid ""
"\t$ git log -2\n"
"\tcommit 10bfe7d22ce15ee25b60a824c8982157ca593d41\n"
"\tAuthor: Scott Chacon <schacon@example.com>\n"
"\tDate:   Sun May 3 12:57:39 2009 -0700"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:669
msgid "\t    imported from current"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:671
msgid ""
"\tcommit 7e519590de754d079dd73b44d695a42c9d2df452\n"
"\tAuthor: Scott Chacon <schacon@example.com>\n"
"\tDate:   Tue Feb 3 01:00:00 2009 -0700"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:675
msgid "\t    imported from back_2009_02_03"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:677
msgid ""
"There you go — a nice, clean Git repository. It’s important to note that "
"nothing is checked out — you don’t have any files in your working directory "
"at first. To get them, you must reset your branch to where `master` is now:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:679
msgid ""
"\t$ ls\n"
"\t$ git reset --hard master\n"
"\tHEAD is now at 10bfe7d imported from current\n"
"\t$ ls\n"
"\tfile.rb  lib"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:685
msgid ""
"You can do a lot more with the `fast-import` tool — handle different modes, "
"binary data, multiple branches and merging, tags, progress indicators, and "
"more. A number of examples of more complex scenarios are available in the "
"`contrib/fast-import` directory of the Git source code; one of the better "
"ones is the `git-p4` script I just covered."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:687
msgid "## Summary ##"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:689
msgid ""
"You should feel comfortable using Git with Subversion or importing nearly "
"any existing repository into a new Git one without losing data. The next "
"chapter will cover the raw internals of Git so you can craft every single "
"byte, if need be."
msgstr ""
