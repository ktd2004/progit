#. extracted from en/01-introduction/01-chapter1.markdown
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-01-03 12:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.9.0\n"

#: en/01-introduction/01-chapter1.markdown:1
msgid "# Getting Started #"
msgstr "# 시작하기 #"

#: en/01-introduction/01-chapter1.markdown:3
msgid ""
"This chapter will be about getting started with Git.  We will begin at the "
"beginning by explaining some background on version control tools, then move "
"on to how to get Git running on your system and finally how to get it setup "
"to start working with.  At the end of this chapter you should understand why "
"Git is around, why you should use it and you should be all setup to do so."
msgstr ""
"이 장에서는 처음 접하는 사람들에게 Git을 설명한다. 먼저 버전 관리 도구에 대한 이해를, 그리고 Git을 설치하는 방법을, 마지막으로 "
"Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git의 탄생 배경, Git을 사용하는 이유, Git을 "
"설정하고 사용하는 방법을 터득할 것이다."

#: en/01-introduction/01-chapter1.markdown:5
msgid "## About Version Control ##"
msgstr "## 버전 관리란? ##"

#: en/01-introduction/01-chapter1.markdown:7
msgid ""
"What is version control, and why should you care? Version control is a "
"system that records changes to a file or set of files over time so that you "
"can recall specific versions later. Even though the examples in this book "
"show software source code as the files under version control, in reality any "
"type of file on a computer can be placed under version control."
msgstr ""
"버전 관리는 무엇이고, 우리는 왜 이것을 알아야 할까? 버전 관리는 파일들의 변화를 시간에 따라 기록하는 것이다. 이 책에 있는 모든 "
"예제는 모두 버전 관리 시스템을 사용한다. 실제로 컴퓨터에서 사용하는 거의 모든 파일의 버전을 관리할 수 있다."

#: en/01-introduction/01-chapter1.markdown:9
msgid ""
"If you are a graphic or web designer and want to keep every version of an "
"image or layout (which you certainly would), it is very wise to use a "
"Version Control System (VCS). A VCS allows you to: revert files back to a "
"previous state, revert the entire project back to a previous state, compare "
"changes over time, see who last modified something that might be causing a "
"problem, who introduced an issue and when, and more. Using a VCS also means "
"that if you screw things up or lose files, you can generally recover easily. "
"In addition, you get all this for very little overhead."
msgstr ""
"그래픽 디자이너나 웹 디자이너도 이미지나 레이아웃의 모든 버전(변경 이력 혹은 수정 내용)을 관리하기 위해 버전 관리 시스템 (VCS - "
"Version Control System)을 사용하는 것이 현명하다. VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, "
"프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, "
"누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든 "
"장점을 큰 노력 없이 이용할 수 있다."

#: en/01-introduction/01-chapter1.markdown:11
msgid "### Local Version Control Systems ###"
msgstr "### 로컬 버전 관리 시스템 ###"

#: en/01-introduction/01-chapter1.markdown:13
msgid ""
"Many people’s version-control method of choice is to copy files into another "
"directory (perhaps a time-stamped directory, if they’re clever). This "
"approach is very common because it is so simple, but it is also incredibly "
"error prone. It is easy to forget which directory you’re in and accidentally "
"write to the wrong file or copy over files you don’t mean to."
msgstr ""
"많은 사람은 버전을 관리하기 위해 Directory로 파일을 복사하는 방법을 쓴다(똑똑한 사람이라면 Directory 이름으로 시간을 쓸 "
"거다). 이 방법은 간단하므로 자주 사용한다. 그렇지만, 정말 뭔가가 잘못되기 쉽다. 작업하는 Directory를 지워버리거나, 실수로 "
"파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다."

#: en/01-introduction/01-chapter1.markdown:15
msgid ""
"To deal with this issue, programmers long ago developed local VCSs that had "
"a simple database that kept all the changes to files under revision control "
"(see Figure 1-1)."
msgstr ""
"이런 이유로 프로그래머들은 오래전에 로컬 VCS를 만들었다. 그 VCS는 관리 중인 파일의 변경 정보를 저장하려고 아주 간단한 "
"데이터베이스를 사용했다. "

#: en/01-introduction/01-chapter1.markdown:17
#, fuzzy
msgid ""
"Insert 18333fig0101.png\n"
"Figure 1-1. Local version control diagram."
msgstr ""
"Insert 18333fig0101.png \n"
"그림 1-1. 로컬 버전 관리 다이어그램."

#: en/01-introduction/01-chapter1.markdown:20
msgid ""
"One of the more popular VCS tools was a system called rcs, which is still "
"distributed with many computers today. Even the popular Mac OS X operating "
"system includes the rcs command when you install the Developer Tools. This "
"tool basically works by keeping patch sets (that is, the differences between "
"files) from one change to another in a special format on disk; it can then "
"re-create what any file looked like at any point in time by adding up all "
"the patches."
msgstr ""
"많이 쓰는 VCS 도구 중에 rcs라고 부르는 것이 있는데 오늘날까지도 아직 많은 회사가 사용하고 있다. Mac OS X 운영체제에서도 "
"개발 도구를 설치하면 RCS가 함께 설치된다. RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch "
"Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다."

#: en/01-introduction/01-chapter1.markdown:22
msgid "### Centralized Version Control Systems ###"
msgstr "### 중앙집중식 버전 관리 시스템 (Centralized VCS) ###"

#: en/01-introduction/01-chapter1.markdown:24
msgid ""
"The next major issue that people encounter is that they need to collaborate "
"with developers on other systems. To deal with this problem, Centralized "
"Version Control Systems (CVCSs) were developed. These systems, such as CVS, "
"Subversion, and Perforce, have a single server that contains all the "
"versioned files, and a number of clients that check out files from that "
"central place. For many years, this has been the standard for version "
"control (see Figure 1-2)."
msgstr ""
"프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 "
"CVCS(Centralized Version Control System)가 개발됐다. CVS, Subversion, Perforce 같은 "
"시스템은 모든 파일을 관리하는 서버가 별도로 있고 많은 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 수년 동안 "
"이러한 시스템들이 많은 사랑을 받았다."

#: en/01-introduction/01-chapter1.markdown:26
#, fuzzy
msgid ""
"Insert 18333fig0102.png\n"
"Figure 1-2. Centralized version control diagram."
msgstr ""
"Insert 18333fig0102.png \n"
"그림 1-2. 중앙집중식 버전 관리 (CVCS) 다이어그램."

#: en/01-introduction/01-chapter1.markdown:29
msgid ""
"This setup offers many advantages, especially over local VCSs. For example, "
"everyone knows to a certain degree what everyone else on the project is "
"doing. Administrators have fine-grained control over who can do what; and "
"it’s far easier to administer a CVCS than it is to deal with local databases "
"on every client."
msgstr ""
"CVCS 환경은 로컬 VCS에 비해 장점이 많다. 프로젝트에 참여한 사람이면 누가 무엇을 하고 있는지 알 수 있다. 관리자는 누가 무엇을 "
"할 수 있는지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의 로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다."

#: en/01-introduction/01-chapter1.markdown:31
msgid ""
"However, this setup also has some serious downsides. The most obvious is the "
"single point of failure that the centralized server represents. If that "
"server goes down for an hour, then during that hour nobody can collaborate "
"at all or save versioned changes to anything they’re working on. If the hard "
"disk the central database is on becomes corrupted, and proper backups "
"haven’t been kept, you lose absolutely everything—the entire history of the "
"project except whatever single snapshots people happen to have on their "
"local machines. Local VCS systems suffer from this same problem—whenever you "
"have the entire history of the project in a single place, you risk losing "
"everything."
msgstr ""
"그러나 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 "
"다운되면 그동안 아무도 다른 사람과 협업할 수 없고 사람들이 하는 일을 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 "
"문제가 생기면 프로젝트의 모든 히스토리를 잃는다. 물론 사람마다 하나씩 가진 Snapshot은 괜찮다. 로컬 VCS 시스템도 이와 "
"비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다."

#: en/01-introduction/01-chapter1.markdown:33
msgid "### Distributed Version Control Systems ###"
msgstr "### 분산형 버전 관리 시스템(Distributed VCS) ###"

#: en/01-introduction/01-chapter1.markdown:35
msgid ""
"This is where Distributed Version Control Systems (DVCSs) step in. In a DVCS "
"(such as Git, Mercurial, Bazaar or Darcs), clients don’t just check out the "
"latest snapshot of the files: they fully mirror the repository. Thus if any "
"server dies, and these systems were collaborating via it, any of the client "
"repositories can be copied back up to the server to restore it. Every "
"checkout is really a full backup of all the data (see Figure 1-3)."
msgstr ""
"분산형 버전 관리 시스템(DVCS)을 설명할 차례다. Git, Mecurial, Bazaar, Darcs 같은 DVCS에서는 클라이언트가 "
"파일의 마지막 Snapshot을 Checkout 하지 않는다. 그냥 저장소를 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 "
"작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. 모든 Checkout은 모든 데이터를 가진 진정한 "
"백업이다."

#: en/01-introduction/01-chapter1.markdown:37
#, fuzzy
msgid ""
"Insert 18333fig0103.png\n"
"Figure 1-3. Distributed version control diagram."
msgstr ""
"Insert 18333fig0103.png\n"
"그림 1-3. 분산형 버전 관리 시스템(DVCS) 다이어그램."

#: en/01-introduction/01-chapter1.markdown:40
msgid ""
"Furthermore, many of these systems deal pretty well with having several "
"remote repositories they can work with, so you can collaborate with "
"different groups of people in different ways simultaneously within the same "
"project. This allows you to set up several types of workflows that aren’t "
"possible in centralized systems, such as hierarchical models."
msgstr ""
"게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재할 수 있다. 리모트 저장소가 많다고 해도 문제없다. 그래서 사람들은 동시에 "
"다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 몇 가지 워크플로우도 사용할 수 "
"있다."

#: en/01-introduction/01-chapter1.markdown:42
msgid "## A Short History of Git ##"
msgstr "## 짧게 보는 Git의 역사 ##"

#: en/01-introduction/01-chapter1.markdown:44
msgid ""
"As with many great things in life, Git began with a bit of creative "
"destruction and fiery controversy. The Linux kernel is an open source "
"software project of fairly large scope. For most of the lifetime of the "
"Linux kernel maintenance (1991–2002), changes to the software were passed "
"around as patches and archived files. In 2002, the Linux kernel project "
"began using a proprietary DVCS system called BitKeeper."
msgstr ""
"인생을 살다 보면 여러 가지 일들이 벌어지듯이 Git의 삶 또한 창조적인 파괴와 모순 속에서 시작되었다. 리눅스 커널은 굉장히 규모가 큰 "
"오픈소스 프로젝트다. 리눅스 커널의 일생에서 대부분 시절은 패치와 단순 파일(Archived file)로만 관리했다. 2002년에 "
"드디어 리눅스 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다."

#: en/01-introduction/01-chapter1.markdown:46
msgid ""
"In 2005, the relationship between the community that developed the Linux "
"kernel and the commercial company that developed BitKeeper broke down, and "
"the tool’s free-of-charge status was revoked. This prompted the Linux "
"development community (and in particular Linus Torvalds, the creator of "
"Linux) to develop their own tool based on some of the lessons they learned "
"while using BitKeeper. Some of the goals of the new system were as follows:"
msgstr ""
"2005년에 커뮤니티가 만드는 리눅스 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 "
"사용이 제고된 것이다. 이 사건은 리눅스 개발 커뮤니티(특히 리눅스 창시자 리누스 토발즈)가 자체 도구를 만드는 계기가 됐다. Git은 "
"BitKeeper를 사용하면서 배운 교훈을 기초로 다음과 같은 목표를 세웠다:"

#: en/01-introduction/01-chapter1.markdown:48
msgid ""
"*\tSpeed\n"
"*\tSimple design\n"
"*\tStrong support for non-linear development (thousands of parallel branches)\n"
"*\tFully distributed\n"
"*\tAble to handle large projects like the Linux kernel efficiently (speed and "
"data size)"
msgstr ""
"* 빠른 속도\n"
"* 단순한 구조\n"
"* 비선형적인 개발(수천 개의 동시 다발적인 브랜치)\n"
"* 완벽한 분산\n"
"* 리눅스 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)"

#: en/01-introduction/01-chapter1.markdown:54
msgid ""
"Since its birth in 2005, Git has evolved and matured to be easy to use and "
"yet retain these initial qualities. It’s incredibly fast, it’s very "
"efficient with large projects, and it has an incredible branching system for "
"non-linear development (See Chapter 3)."
msgstr ""
"Git은 2005년 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있으면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 "
"빨라서 대형 프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이다 (3장 참고)."

#: en/01-introduction/01-chapter1.markdown:56
msgid "## Git Basics ##"
msgstr "## Git 기초 ##"

#: en/01-introduction/01-chapter1.markdown:58
msgid ""
"So, what is Git in a nutshell? This is an important section to absorb, "
"because if you understand what Git is and the fundamentals of how it works, "
"then using Git effectively will probably be much easier for you. As you "
"learn Git, try to clear your mind of the things you may know about other "
"VCSs, such as Subversion and Perforce; doing so will help you avoid subtle "
"confusion when using the tool. Git stores and thinks about information much "
"differently than these other systems, even though the user interface is "
"fairly similar; understanding those differences will help prevent you from "
"becoming confused while using it."
msgstr ""
"Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 "
"효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 지워버려야 "
"한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈릴 거다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 "
"방식이 다르다. 이런 차이점들을 이해하면 Git을 사용하는 것이 어렵지 않다."

#: en/01-introduction/01-chapter1.markdown:60
msgid "### Snapshots, Not Differences ###"
msgstr "### 차이점이 아니라 Snapshot ###"

#: en/01-introduction/01-chapter1.markdown:62
msgid ""
"The major difference between Git and any other VCS (Subversion and friends "
"included) is the way Git thinks about its data. Conceptually, most other "
"systems store information as a list of file-based changes. These systems "
"(CVS, Subversion, Perforce, Bazaar, and so on) think of the information they "
"keep as a set of files and the changes made to each file over time, as "
"illustrated in Figure 1-4."
msgstr ""
"Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 "
"대부분의 VCS 시스템이 관리하는 정보는 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 "
"파일의 집합으로 정보를 관리한다. 각 파일의 변화를 그림 1-4처럼 시간순으로 관리한다."

#: en/01-introduction/01-chapter1.markdown:64
#, fuzzy
msgid ""
"Insert 18333fig0104.png\n"
"Figure 1-4. Other systems tend to store data as changes to a base version of "
"each file."
msgstr ""
"Insert 18333fig0104.png \n"
"그림 1-4. 각 파일에 대한 변화(차이점)를 저장하는 시스템들."

#: en/01-introduction/01-chapter1.markdown:67
#, fuzzy
msgid ""
"Git doesn’t think of or store its data this way. Instead, Git thinks of its "
"data more like a set of snapshots of a mini filesystem. Every time you "
"commit, or save the state of your project in Git, it basically takes a "
"picture of what all your files look like at that moment and stores a "
"reference to that snapshot. To be efficient, if files have not changed, Git "
"doesn’t store the file again—just a link to the previous identical file it "
"has already stored. Git thinks about its data more like Figure 1-5."
msgstr ""
"Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git의 데이터는 파일 시스템의 Snapshot이라 할 수 있으며 "
"크기가 아주 작다. Git은 Commit 하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 "
"달라지지 않았으면 Git은 성능을 위해서 파일을 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 그림 "
"1-5처럼 동작한다."

#: en/01-introduction/01-chapter1.markdown:69
#, fuzzy
msgid ""
"Insert 18333fig0105.png\n"
"Figure 1-5. Git stores data as snapshots of the project over time."
msgstr ""
"Insert 18333fig0105.png \n"
"그림 1-5. Git은 시간순으로 프로젝트의 Snapshot을 저장한다."

#: en/01-introduction/01-chapter1.markdown:72
msgid ""
"This is an important distinction between Git and nearly all other VCSs. It "
"makes Git reconsider almost every aspect of version control that most other "
"systems copied from the previous generation. This makes Git more like a mini "
"filesystem with some incredibly powerful tools built on top of it, rather "
"than simply a VCS. We’ll explore some of the benefits you gain by thinking "
"of your data this way when we cover Git branching in Chapter 3."
msgstr ""
"이것이 Git이 다른 VCS와 구분되는 점이다. 이점 때문에 Git는 다른 시스템들이 과거로부터 답습해왔던 버전 컨트롤의 개념의 많은 "
"부분을 새로운 관점에서 바라본다. Git은 강력한 도구를 지원하는 작은 파일시스템이다. Git은 단순한 VCS가 아니다. 이제 3장에서 "
"설명할 Git 브랜치를 사용하면 얻게 되는 이득이 무엇인지 설명한다."

#: en/01-introduction/01-chapter1.markdown:74
msgid "### Nearly Every Operation Is Local ###"
msgstr "### 거의 모든 명령을 로컬에서 실행 ###"

#: en/01-introduction/01-chapter1.markdown:76
msgid ""
"Most operations in Git only need local files and resources to operate — "
"generally no information is needed from another computer on your network.  "
"If you’re used to a CVCS where most operations have that network latency "
"overhead, this aspect of Git will make you think that the gods of speed have "
"blessed Git with unworldly powers. Because you have the entire history of "
"the project right there on your local disk, most operations seem almost "
"instantaneous."
msgstr ""
"거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 "
"영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠듯한 속도는 오직 Git느님만이 구사할 "
"수 있는 초인적인 능력이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령을 순식간에 실행된다."

#: en/01-introduction/01-chapter1.markdown:78
msgid ""
"For example, to browse the history of the project, Git doesn’t need to go "
"out to the server to get the history and display it for you—it simply reads "
"it directly from your local database. This means you see the project history "
"almost instantly. If you want to see the changes introduced between the "
"current version of a file and the file a month ago, Git can look up the file "
"a month ago and do a local difference calculation, instead of having to "
"either ask a remote server to do it or pull an older version of the file "
"from the remote server to do it locally."
msgstr ""
"예를 들어 프로젝트의 히스토리를 조회하려 할 때 Git은 서버가 필요 없다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. "
"그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를 비교해보고 싶을 때도 Git은 그냥 한 "
"달 전의 파일과 지금의 파일을 로컬에서 찾는다. 파일을 비교하기 위해 리모트에 있는 서버에 접근하고 나서 예전 버전을 가져올 필요가 "
"없다."

#: en/01-introduction/01-chapter1.markdown:80
msgid ""
"This also means that there is very little you can’t do if you’re offline or "
"off VPN. If you get on an airplane or a train and want to do a little work, "
"you can commit happily until you get to a network connection to upload. If "
"you go home and can’t get your VPN client working properly, you can still "
"work. In many other systems, doing so is either impossible or painful. In "
"Perforce, for example, you can’t do much when you aren’t connected to the "
"server; and in Subversion and CVS, you can edit files, but you can’t commit "
"changes to your database (because your database is offline). This may not "
"seem like a huge deal, but you may be surprised what a big difference it can "
"make."
msgstr ""
"즉 오프라인 상태에서도 비교할 수 있다. 비행기나 기차 등에서 작업하고 네트워크에 접속하고 있지 않아도 Commit 할 수 있다. 다른 "
"VCS 시스템에서는 불가능한 일이다. Perforce는 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나 "
"CVS에서도 마찬가지다. 데이터베이스에 접근할 수 없어서 파일을 편집할 수는 있지만, Commit 할 수 없다. 매우 사소해 보이지만 "
"실제로 이 상황에 부닥쳐보면 느껴지는 차이가 매우 크다."

#: en/01-introduction/01-chapter1.markdown:82
msgid "### Git Has Integrity ###"
msgstr "### Git의 무결성 ###"

#: en/01-introduction/01-chapter1.markdown:84
msgid ""
"Everything in Git is check-summed before it is stored and is then referred "
"to by that checksum. This means it’s impossible to change the contents of "
"any file or directory without Git knowing about it. This functionality is "
"built into Git at the lowest levels and is integral to its philosophy. You "
"can’t lose information in transit or get file corruption without Git being "
"able to detect it."
msgstr ""
"Git은 모든 데이터를 저장하기 전에 체크섬(Checksum 또는 Hash)을 구하고 그 체크섬으로 데이터를 관리한다. 체크섬 없이 "
"어떠한 파일이나 Directory도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 "
"기본 철학이다. Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 데이터를 잃어버릴 수도 없다."

#: en/01-introduction/01-chapter1.markdown:86
msgid ""
"The mechanism that Git uses for this checksumming is called a SHA-1 hash. "
"This is a 40-character string composed of hexadecimal characters (0–9 and "
"a–f) and calculated based on the contents of a file or directory structure "
"in Git. A SHA-1 hash looks something like this:"
msgstr ""
"Git은 SHA-1 Hash를 사용하여 체크섬을 만든다. 만든 체크섬은 40자 길이의 16진수 문자열이다. 파일의 내용이나 "
"Directory 구조를 이용하여 체크섬을 구한다. SHA-1은 아래처럼 생겼다."

#: en/01-introduction/01-chapter1.markdown:88
msgid "\t24b9da6552252987aa493b52f8696cd6d3b00373"
msgstr "\t24b9da6552252987aa493b52f8696cd6d3b00373"

#: en/01-introduction/01-chapter1.markdown:90
msgid ""
"You will see these hash values all over the place in Git because it uses "
"them so much. In fact, Git stores everything not by file name but in the Git "
"database addressable by the hash value of its contents."
msgstr ""
"Git은 모든 것을 Hash로 식별하기 때문에 이런 값은 여기저기서 보일 것이다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 "
"파일의 Hash로 저장한다."

#: en/01-introduction/01-chapter1.markdown:92
msgid "### Git Generally Only Adds Data ###"
msgstr "### Git은 데이터를 추가할 뿐 ###"

#: en/01-introduction/01-chapter1.markdown:94
msgid ""
"When you do actions in Git, nearly all of them only add data to the Git "
"database. It is very difficult to get the system to do anything that is not "
"undoable or to make it erase data in any way. As in any VCS, you can lose or "
"mess up changes you haven’t committed yet; but after you commit a snapshot "
"into Git, it is very difficult to lose, especially if you regularly push "
"your database to another repository."
msgstr ""
"Git으로 무얼 하든 데이터가 추가된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS처럼 Git도 Commit 하지 않으면 "
"변경사항을 잃어버릴 수 있다. 하지만, 일단 Snapshot을 Commit하고 나면 데이터를 잃어버리기 어렵다."

#: en/01-introduction/01-chapter1.markdown:96
msgid ""
"This makes using Git a joy because we know we can experiment without the "
"danger of severely screwing things up. For a more in-depth look at how Git "
"stores its data and how you can recover data that seems lost, see Chapter 9."
msgstr ""
"Git을 사용하면 프로젝트가 심각하게 망가질 걱정 없이 매우 즐겁게 여러 가지 실험을 해 볼 수 있다. Git이 데이터를 어떻게 저장하고 "
"손실을 복구할 수 있는지 좀 더 알아보려면 9장 살펴본다."

#: en/01-introduction/01-chapter1.markdown:98
msgid "### The Three States ###"
msgstr "### 세 가지 상태 ###"

#: en/01-introduction/01-chapter1.markdown:100
msgid ""
"Now, pay attention. This is the main thing to remember about Git if you want "
"the rest of your learning process to go smoothly. Git has three main states "
"that your files can reside in: committed, modified, and staged. Committed "
"means that the data is safely stored in your local database. Modified means "
"that you have changed the file but have not committed it to your database "
"yet. Staged means that you have marked a modified file in its current "
"version to go into your next commit snapshot."
msgstr ""
"이 부분은 중요하기에 집중해서 읽어야 한다. Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을 Commited, "
"Modified, Staged 이렇게 세 가지 상태로 관리한다. Commited란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 "
"의미한다. Modified는 수정한 파일을 아직 로컬 데이터베이스에 Commit 하지 않은 것을 말한다. Staged란 현재 수정한 "
"파일을 곧 Commit 할 것이라고 표시한 상태를 의미한다."

#: en/01-introduction/01-chapter1.markdown:102
msgid ""
"This leads us to the three main sections of a Git project: the Git "
"directory, the working directory, and the staging area."
msgstr ""
"이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git Directory, Working Directory, "
"Staging Area 이 세 가지 단계를 이해하고 넘어가자."

#: en/01-introduction/01-chapter1.markdown:104
#, fuzzy
msgid ""
"Insert 18333fig0106.png\n"
"Figure 1-6. Working directory, staging area, and git directory."
msgstr ""
"Insert 18333fig0106.png \n"
"그림 1-5. Working Directory, Staging Area, Git Directory"

#: en/01-introduction/01-chapter1.markdown:107
msgid ""
"The Git directory is where Git stores the metadata and object database for "
"your project. This is the most important part of Git, and it is what is "
"copied when you clone a repository from another computer."
msgstr ""
"Git Directory는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. Git Directory가 Git의 "
"핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git Directory가 만들어진다."

#: en/01-introduction/01-chapter1.markdown:109
msgid ""
"The working directory is a single checkout of one version of the project. "
"These files are pulled out of the compressed database in the Git directory "
"and placed on disk for you to use or modify."
msgstr ""
"Working Directory는 프로젝트의 특정 버전을 Checkout 한 것이다. Git Directory는 지금 작업하는 디스크에 "
"있고 그 Directory에 압축된 데이터베이스에서 파일을 가져와서 Working Directory를 만든다."

#: en/01-introduction/01-chapter1.markdown:111
msgid ""
"The staging area is a simple file, generally contained in your Git "
"directory, that stores information about what will go into your next commit. "
"It’s sometimes referred to as the index, but it’s becoming standard to "
"refer to it as the staging area."
msgstr ""
"Staging Area는 Git Directory에 있다. 단순한 파일이고 곧 Commit 할 파일에 대한 정보를 저장한다. 종종 "
"인덱스라고 불리기도 하지만, Staging Area라는 명칭이 표준이 되어가고 있다."

#: en/01-introduction/01-chapter1.markdown:113
msgid "The basic Git workflow goes something like this:"
msgstr "Git으로 하는 일은 기본적으로 다음과 같다:"

#: en/01-introduction/01-chapter1.markdown:115
msgid ""
"1. You modify files in your working directory.\n"
"2. You stage the files, adding snapshots of them to your staging area.\n"
"3. You do a commit, which takes the files as they are in the staging area "
"and stores that snapshot permanently to your Git directory."
msgstr ""
"- Working Directory에서 파일을 수정한다.\n"
"- Staging Area에 파일을 Stage 해서 Commit 할 Snapshot을 만든다.\n"
"- Staging Area에 있는 파일들을 Commit 해서 Git Directory에 영구적인 Snapshot으로 저장한다."

#: en/01-introduction/01-chapter1.markdown:119
msgid ""
"If a particular version of a file is in the git directory, it’s considered "
"committed. If it’s modified but has been added to the staging area, it is "
"staged. And if it was changed since it was checked out but has not been "
"staged, it is modified. In Chapter 2, you’ll learn more about these states "
"and how you can either take advantage of them or skip the staged part "
"entirely."
msgstr ""
"Git directory에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 "
"Staged이다. 그리고 Checkout하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다. "
"2장에서 이 상태에 대해 좀 더 자세히 배운다. 특히 Staging Area를 어떻게 이용하는지 혹은 아예 생략하는 방법도 설명한다."

#: en/01-introduction/01-chapter1.markdown:121
msgid "## Installing Git ##"
msgstr "## Git 설치 ##"

#: en/01-introduction/01-chapter1.markdown:123
msgid ""
"Let’s get into using some Git. First things first—you have to install it. "
"You can get it a number of ways; the two major ones are to install it from "
"source or to install an existing package for your platform."
msgstr ""
"Git을 사용해 보려면 우선 설치해야 한다. 다양한 방법으로 Git을 설치할 수 있지만 가장 일반적인 방법은 두 가지가 있다. 하나는 "
"소스코드로 컴파일하여 설치하는 방법이고 다른 하나는 각 운영체제(혹은 Platform)의 패키지를 사용하여 설치하는 방법이다."

#: en/01-introduction/01-chapter1.markdown:125
msgid "### Installing from Source ###"
msgstr "### 소스코드로 설치하기 ###"

#: en/01-introduction/01-chapter1.markdown:127
msgid ""
"If you can, it’s generally useful to install Git from source, because you’ll "
"get the most recent version. Each version of Git tends to include useful UI "
"enhancements, so getting the latest version is often the best route if you "
"feel comfortable compiling software from source. It is also the case that "
"many Linux distributions contain very old packages; so unless you’re on a "
"very up-to-date distro or are using backports, installing from source may be "
"the best bet."
msgstr ""
"소스코드로 설치하면 Git의 가장 최신 버전을 설치할 수 있기 때문에 컴파일하여 설치할 시간이 있으면 소스코드로 Git을 설치하는 것이 "
"좋다. Git은 계속 UI를 개선하고 있기 때문에 최신 버전을 사용하면 좋은 기능을 빨리 사용할 수 있다. 리눅스 패키지는 보통 최신 "
"버전이 아니고 예전 버전이다. 그래서 Backport를 사용하거나 소스코드로 설치하는 것도 좋은 대안이다."

#: en/01-introduction/01-chapter1.markdown:129
msgid ""
"To install Git, you need to have the following libraries that Git depends "
"on: curl, zlib, openssl, expat, and libiconv. For example, if you’re on a "
"system that has yum (such as Fedora) or apt-get (such as a Debian based "
"system), you can use one of these commands to install all of the "
"dependencies:"
msgstr ""
"Git을 설치하려면 다음과 같은 라이브러리들이 필요하다. Git은 curl, zlib, openssl, expat, libiconv를 "
"필요로 한다. 예를 들어 Fedora처럼 yum을 가지는 시스템을 사용하고 있거나 apt-get이 있는 데비안류 시스템을 사용하면 다음의 "
"명령어를 실행하여 의존 패키지를 설치할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:131
msgid ""
"\t$ yum install curl-devel expat-devel gettext-devel \\\n"
"\t  openssl-devel zlib-devel"
msgstr ""
"\t$ yum install curl-devel expat-devel gettext-devel \\\n"
"\t  openssl-devel zlib-devel"

#: en/01-introduction/01-chapter1.markdown:134
msgid ""
"\t$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n"
"\t  libz-dev libssl-dev"
msgstr ""
"\t$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n"
"\t  libz-dev libssl-dev"

#: en/01-introduction/01-chapter1.markdown:137
msgid ""
"When you have all the necessary dependencies, you can go ahead and grab the "
"latest snapshot from the Git web site:"
msgstr "필요한 라이브러리를 모두 설치하고 다음 단계를 진행한다. Git 웹 사이트에서 최신 Snapshot을 가져온다:"

#: en/01-introduction/01-chapter1.markdown:139
msgid "\thttp://git-scm.com/download"
msgstr "\thttp://git-scm.com/download"

#: en/01-introduction/01-chapter1.markdown:141
msgid "Then, compile and install:"
msgstr "그리고 컴파일하고 설치한다:"

#: en/01-introduction/01-chapter1.markdown:143
msgid ""
"\t$ tar -zxf git-1.7.2.2.tar.gz\n"
"\t$ cd git-1.7.2.2\n"
"\t$ make prefix=/usr/local all\n"
"\t$ sudo make prefix=/usr/local install"
msgstr ""
"\t$ tar -zxf git-1.7.2.2.tar.gz\n"
"\t$ cd git-1.7.2.2\n"
"\t$ make prefix=/usr/local all\n"
"\t$ sudo make prefix=/usr/local install"

#: en/01-introduction/01-chapter1.markdown:148
msgid "After this is done, you can also get Git via Git itself for updates:"
msgstr "설치한 다음부터는 Git을 사용하여 Git 소스코드를 갱신할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:150
msgid "\t$ git clone git://git.kernel.org/pub/scm/git/git.git"
msgstr "\t$ git clone git://git.kernel.org/pub/scm/git/git.git"

#: en/01-introduction/01-chapter1.markdown:152
msgid "### Installing on Linux ###"
msgstr "### 리눅스에 설치 ###"

#: en/01-introduction/01-chapter1.markdown:154
msgid ""
"If you want to install Git on Linux via a binary installer, you can "
"generally do so through the basic package-management tool that comes with "
"your distribution. If you’re on Fedora, you can use yum:"
msgstr ""
"리눅스에서 패키지로 Git을 설치할 때에는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora에서는 다음과 "
"같이 한다:"

#: en/01-introduction/01-chapter1.markdown:156
msgid "\t$ yum install git-core"
msgstr "\t$ yum install git-core"

#: en/01-introduction/01-chapter1.markdown:158
msgid "Or if you’re on a Debian-based distribution like Ubuntu, try apt-get:"
msgstr "Ubuntu같은 데비안류 배포판에서는 apt-get을 사용한다:"

#: en/01-introduction/01-chapter1.markdown:160
msgid "\t$ apt-get install git-core"
msgstr "\t$ apt-get install git-core"

#: en/01-introduction/01-chapter1.markdown:162
msgid "### Installing on Mac ###"
msgstr "### Mac에 설치하기 ###"

#: en/01-introduction/01-chapter1.markdown:164
msgid ""
"There are two easy ways to install Git on a Mac. The easiest is to use the "
"graphical Git installer, which you can download from the Google Code page "
"(see Figure 1-7):"
msgstr ""
"Mac에 Git을 쉽게 설치하는 방법은 두 가지가 있다. GUI 인스톨러를 사용하기가 가장 쉽다. Google Code 페이지에서 "
"내려받는다:"

#: en/01-introduction/01-chapter1.markdown:166
msgid "\thttp://code.google.com/p/git-osx-installer"
msgstr "\thttp://code.google.com/p/git-osx-installer"

#: en/01-introduction/01-chapter1.markdown:168
#, fuzzy
msgid ""
"Insert 18333fig0107.png\n"
"Figure 1-7. Git OS X installer."
msgstr ""
"Insert 18333fig0107.png \n"
"그림 1-7. OS X Git 인스톨러."

#: en/01-introduction/01-chapter1.markdown:171
msgid ""
"The other major way is to install Git via MacPorts "
"(`http://www.macports.org`). If you have MacPorts installed, install Git via"
msgstr ""
"MacPorts(`http://www.macports.org`)를 사용하는 방법도 있다. MacPorts가 설치돼 있으면 다음과 같이 "
"Git을 설치한다:"

#: en/01-introduction/01-chapter1.markdown:173
msgid "\t$ sudo port install git-core +svn +doc +bash_completion +gitweb"
msgstr "\t$ sudo port install git-core +svn +doc +bash_completion +gitweb"

#: en/01-introduction/01-chapter1.markdown:175
msgid ""
"You don’t have to add all the extras, but you’ll probably want to include "
"+svn in case you ever have to use Git with Subversion repositories (see "
"Chapter 8)."
msgstr "이제 설치는 했다. 만약 Subversion 저장소를 Git과 함께 사용해야 하면 svn도 필요하다."

#: en/01-introduction/01-chapter1.markdown:177
msgid "### Installing on Windows ###"
msgstr "### 윈도우에 설치 ###"

#: en/01-introduction/01-chapter1.markdown:179
msgid ""
"Installing Git on Windows is very easy. The msysGit project has one of the "
"easier installation procedures. Simply download the installer exe file from "
"the Google Code page, and run it:"
msgstr "Git을 윈도우에 설치하기도 쉽다. 그저 구글 코드 페이지에서 msysGit 인스톨러를 내려받고 실행하면 된다:"

#: en/01-introduction/01-chapter1.markdown:181
msgid "\thttp://code.google.com/p/msysgit"
msgstr "\thttp://code.google.com/p/msysgit"

#: en/01-introduction/01-chapter1.markdown:183
msgid ""
"After it’s installed, you have both a command-line version (including an SSH "
"client that will come in handy later) and the standard GUI."
msgstr ""
"설치가 완료되면 CLI 프로그램과 GUI 프로그램을 둘 다 사용할 수 있다. CLI 프로그램에는 SSH 클라이언트가 포함돼 있기 때문에 "
"유용하다."

#: en/01-introduction/01-chapter1.markdown:185
msgid ""
"Note on Windows usage: you should use Git with the provided msysGit shell "
"(Unix style), it allows to use the complex lines of command given in this "
"book. If you need, for some reason, to use the native Windows shell / "
"command line console, you have to use double quotes instead of simple quotes "
"(for parameters with spaces in them) and you must quote the parameters "
"ending with the circumflex accent (^) if they are last on the line, as it is "
"a continuation symbol in Windows."
msgstr ""

#: en/01-introduction/01-chapter1.markdown:187
msgid "## First-Time Git Setup ##"
msgstr "## Git 최초 설정 ##"

#: en/01-introduction/01-chapter1.markdown:189
msgid ""
"Now that you have Git on your system, you’ll want to do a few things to "
"customize your Git environment. You should have to do these things only "
"once; they’ll stick around between upgrades. You can also change them at any "
"time by running through the commands again."
msgstr ""
"Git을 설치하고 나면 Git의 사용 환경을 적절히 설정해 주어야 한다. 한 번만 설정하면 된다. 설정한 내용은 Git을 업그레이드해도 "
"유지된다. 또한, 명령어로 언제든지 다시 바꿀 수 있다."

#: en/01-introduction/01-chapter1.markdown:191
msgid ""
"Git comes with a tool called git config that lets you get and set "
"configuration variables that control all aspects of how Git looks and "
"operates. These variables can be stored in three different places:"
msgstr ""
"Git은 'git config'라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이 설정 파일은 세 "
"가지나 된다."

#: en/01-introduction/01-chapter1.markdown:193
#, fuzzy
msgid ""
"*\t`/etc/gitconfig` file: Contains values for every user on the system and "
"all their repositories. If you pass the option` --system` to `git config`, "
"it reads and writes from this file specifically.\n"
"*\t`~/.gitconfig` file: Specific to your user. You can make Git read and "
"write to this file specifically by passing the `--global` option.\n"
"*\tconfig file in the git directory (that is, `.git/config`) of whatever "
"repository you’re currently using: Specific to that single repository. Each "
"level overrides values in the previous level, so values in `.git/config` "
"trump those in `/etc/gitconfig`."
msgstr ""
"* `/etc/gitconfig` 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. `git config --system` "
"옵션으로 이 파일을 읽고 쓸 수 있다.\n"
"* `~/.gitconfig` 파일: 특정 사용자에게만 적용되는 설정이다. `git config --global` 옵션으로 이 파일을 "
"읽고 쓸 수 있다.\n"
"* `.git/config`: 이 파일은 Git Directory에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. 각 "
"설정은 역순으로 우선시 된다. 그래서 `.git/config`가 `/etc/gitconfig`보다 우선한다."

#: en/01-introduction/01-chapter1.markdown:197
msgid ""
"On Windows systems, Git looks for the `.gitconfig` file in the `$HOME` "
"directory (`%USERPROFILE%` in Windows’ environment), which is `C:\\Documents "
"and Settings\\$USER` or `C:\\Users\\$USER` for most people, depending on "
"version (`$USER` is `%USERNAME%` in Windows’ environment). It also still "
"looks for /etc/gitconfig, although it’s relative to the MSys root, which is "
"wherever you decide to install Git on your Windows system when you run the "
"installer."
msgstr ""

#: en/01-introduction/01-chapter1.markdown:199
msgid "### Your Identity ###"
msgstr "### 사용자 정보 ###"

#: en/01-introduction/01-chapter1.markdown:201
msgid ""
"The first thing you should do when you install Git is to set your user name "
"and e-mail address. This is important because every Git commit uses this "
"information, and it’s immutably baked into the commits you pass around:"
msgstr ""
"Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자 이름과 이메일 주소를 설정하는 것이다. Git은 Commit 할 때마다 이 "
"정보를 사용한다. 한 번 Commit 한 후에는 정보를 변경할 수 없다."

#: en/01-introduction/01-chapter1.markdown:203
msgid ""
"\t$ git config --global user.name \"John Doe\"\n"
"\t$ git config --global user.email johndoe@example.com"
msgstr ""
"\t$ git config --global user.name \"John Doe\"\n"
"\t$ git config --global user.email johndoe@example.com"

#: en/01-introduction/01-chapter1.markdown:206
msgid ""
"Again, you need to do this only once if you pass the `--global` option, "
"because then Git will always use that information for anything you do on "
"that system. If you want to override this with a different name or e-mail "
"address for specific projects, you can run the command without the "
"`--global` option when you’re in that project."
msgstr ""
"다시 말하자면 `--global` 옵션으로 설정한 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때에는 이 정보를 "
"사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 `--global` 옵션을 빼고 명령을 실행한다."

#: en/01-introduction/01-chapter1.markdown:208
msgid "### Your Editor ###"
msgstr "### 편집기 ###"

#: en/01-introduction/01-chapter1.markdown:210
msgid ""
"Now that your identity is set up, you can configure the default text editor "
"that will be used when Git needs you to type in a message. By default, Git "
"uses your system’s default editor, which is generally Vi or Vim. If you want "
"to use a different text editor, such as Emacs, you can do the following:"
msgstr ""
"사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용하고 보통 이것은 "
"Vi나 Vim이다. 하지만, Emacs 같은 다른 텍스트 편집기를 사용하고 싶다면 다음과 같이 실행한다.:"

#: en/01-introduction/01-chapter1.markdown:212
msgid "\t$ git config --global core.editor emacs"
msgstr "\t$ git config --global core.editor emacs"

#: en/01-introduction/01-chapter1.markdown:214
msgid "### Your Diff Tool ###"
msgstr "### Diff 도구 ###"

#: en/01-introduction/01-chapter1.markdown:216
msgid ""
"Another useful option you may want to configure is the default diff tool to "
"use to resolve merge conflicts. Say you want to use vimdiff:"
msgstr ""
"Merge 충돌을 해결하기 위해 사용하는 Diff 도구를 설정할 수 있다. vimdiff를 사용하고 싶으면 다음과 같이 실행한다:"

#: en/01-introduction/01-chapter1.markdown:218
msgid "\t$ git config --global merge.tool vimdiff"
msgstr "\t$ git config --global merge.tool vimdiff"

#: en/01-introduction/01-chapter1.markdown:220
msgid ""
"Git accepts kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, "
"ecmerge, and opendiff as valid merge tools. You can also set up a custom "
"tool; see Chapter 7 for more information about doing that."
msgstr ""
"이렇게 kdiff3, tkdiff, meld, xxdif, emerge, vimdiff, gvimdiff, ecmerge, "
"opendiff를 사용할 수 있다. 물론 다른 도구도 사용할 수 있다. 자세한 내용은 7장에서 다룬다."

#: en/01-introduction/01-chapter1.markdown:222
msgid "### Checking Your Settings ###"
msgstr "### 설정 확인 ###"

#: en/01-introduction/01-chapter1.markdown:224
msgid ""
"If you want to check your settings, you can use the `git config --list` "
"command to list all the settings Git can find at that point:"
msgstr "`git config --list` 명령을 실행하면 모든 설정 내용을 확인할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:226
msgid ""
"\t$ git config --list\n"
"\tuser.name=Scott Chacon\n"
"\tuser.email=schacon@gmail.com\n"
"\tcolor.status=auto\n"
"\tcolor.branch=auto\n"
"\tcolor.interactive=auto\n"
"\tcolor.diff=auto\n"
"\t..."
msgstr ""
"\t$ git config --list\n"
"\tuser.name=Scott Chacon\n"
"\tuser.email=schacon@gmail.com\n"
"\tcolor.status=auto\n"
"\tcolor.branch=auto\n"
"\tcolor.interactive=auto\n"
"\tcolor.diff=auto\n"
"\t..."

#: en/01-introduction/01-chapter1.markdown:235
msgid ""
"You may see keys more than once, because Git reads the same key from "
"different files (`/etc/gitconfig` and `~/.gitconfig`, for example). In this "
"case, Git uses the last value for each unique key it sees."
msgstr ""
"Git은 같은 키를 여러 파일(`/etc/gitconfig`와 `~/.gitconfig`같은)에서 읽기 때문에 같은 키가 하나 이상 나올 "
"수도 있다. 이 경우에 Git은 나중 값을 사용한다."

#: en/01-introduction/01-chapter1.markdown:237
msgid ""
"You can also check what Git thinks a specific key’s value is by typing `git "
"config {key}`:"
msgstr "`git config {key}` 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:239
msgid ""
"\t$ git config user.name\n"
"\tScott Chacon"
msgstr ""
"\t$ git config user.name\n"
"\tScott Chacon"

#: en/01-introduction/01-chapter1.markdown:242
msgid "## Getting Help ##"
msgstr "## 도움말 보기 ##"

#: en/01-introduction/01-chapter1.markdown:244
msgid ""
"If you ever need help while using Git, there are three ways to get the "
"manual page (manpage) help for any of the Git commands:"
msgstr "명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 세 가지이다:"

#: en/01-introduction/01-chapter1.markdown:246
msgid ""
"\t$ git help <verb>\n"
"\t$ git <verb> --help\n"
"\t$ man git-<verb>"
msgstr ""
"\t$ git help <verb>\n"
"\t$ git <verb> --help\n"
"\t$ man git-<verb>"

#: en/01-introduction/01-chapter1.markdown:250
msgid ""
"For example, you can get the manpage help for the config command by running"
msgstr "예를 들어 다음과 같이 실행하면 config 명령에 대한 도움말을 볼 수 있다:"

#: en/01-introduction/01-chapter1.markdown:252
msgid "\t$ git help config"
msgstr "\t$ git help config"

#: en/01-introduction/01-chapter1.markdown:254
msgid ""
"These commands are nice because you can access them anywhere, even offline.\n"
"If the manpages and this book aren’t enough and you need in-person help, you "
"can try the `#git` or `#github` channel on the Freenode IRC server "
"(irc.freenode.net). These channels are regularly filled with hundreds of "
"people who are all very knowledgeable about Git and are often willing to "
"help."
msgstr ""
"도움말은 언제 어디서나 볼 수 있다. 오프라인 상태에서도 가능하다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. "
"Freenode IRC 서버(irc.freenode.net)에 있는 `#git`이나 `#github` 채널로 찾아가라. 이 채널은 보통 "
"수백 명의 사람이 접속해 있다. 이 사람들은 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다."

#: en/01-introduction/01-chapter1.markdown:257
msgid "## Summary ##"
msgstr "## 요약 ##"

#: en/01-introduction/01-chapter1.markdown:259
msgid ""
"You should have a basic understanding of what Git is and how it’s different "
"from the CVCS you may have been using. You should also now have a working "
"version of Git on your system that’s set up with your personal identity. "
"It’s now time to learn some Git basics."
msgstr ""
"우리는 Git이 무엇이고 지금까지 사용해 왔던 다른 CVCS와 어떻게 다른지 배웠다. 시스템에 Git을 설치하고 사용자 정보도 설정했다. "
"다음 장에서는 Git의 사용법을 배운다."

#~ msgid ""
#~ "On Windows systems, Git looks for the `.gitconfig` file in the `$HOME` "
#~ "directory (`C:\\Documents and Settings\\$USER` for most people). It also still "
#~ "looks for /etc/gitconfig, although it’s relative to the MSys root, which is "
#~ "wherever you decide to install Git on your Windows system when you run the "
#~ "installer."
#~ msgstr ""
#~ "윈도우에서 Git은 `$HOME` Directory(`C:\\Documents and Settings\\$USER`)에 있는 "
#~ "`.gitconfig` 파일을 찾는다. 그리고 msysGit도 /etc/gitconfig를 가지고 있다. 경로는 MSys 루트에 따른 "
#~ "상대 경로다. 인스톨러로 msysGit을 설치할 때 설치 경로를 선택할 수 있다."
