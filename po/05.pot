#. extracted from en/05-distributed-git/01-chapter5.markdown
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-01-03 12:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.9.0\n"

#: en/05-distributed-git/01-chapter5.markdown:1
msgid "# Distributed Git #"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:3
msgid ""
"Now that you have a remote Git repository set up as a point for all the "
"developers to share their code, and you’re familiar with basic Git commands "
"in a local workflow, you’ll look at how to utilize some of the distributed "
"workflows that Git affords you."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:5
msgid ""
"In this chapter, you’ll see how to work with Git in a distributed "
"environment as a contributor and an integrator. That is, you’ll learn how to "
"contribute code successfully to a project and make it as easy on you and "
"the project maintainer as possible, and also how to maintain a project "
"successfully with a number of developers contributing."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:7
msgid "## Distributed Workflows ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:9
msgid ""
"Unlike Centralized Version Control Systems (CVCSs), the distributed nature "
"of Git allows you to be far more flexible in how developers collaborate on "
"projects. In centralized systems, every developer is a node working more or "
"less equally on a central hub. In Git, however, every developer is "
"potentially both a node and a hub — that is, every developer can both "
"contribute code to other repositories and maintain a public repository on "
"which others can base their work and which they can contribute to. This "
"opens a vast range of workflow possibilities for your project and/or your "
"team, so I’ll cover a few common paradigms that take advantage of this "
"flexibility. I’ll go over the strengths and possible weaknesses of each "
"design; you can choose a single one to use, or you can mix and match "
"features from each."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:11
msgid "### Centralized Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:13
msgid ""
"In centralized systems, there is generally a single collaboration model—the "
"centralized workflow. One central hub, or repository, can accept code, and "
"everyone synchronizes their work to it. A number of developers are nodes — "
"consumers of that hub — and synchronize to that one place (see Figure 5-1)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:15
msgid ""
"Insert 18333fig0501.png\n"
"Figure 5-1. Centralized workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:18
msgid ""
"This means that if two developers clone from the hub and both make changes, "
"the first developer to push their changes back up can do so with no "
"problems. The second developer must merge in the first one’s work before "
"pushing changes up, so as not to overwrite the first developer’s changes. "
"This concept is true in Git as it is in Subversion (or any CVCS), and this "
"model works perfectly in Git."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:20
msgid ""
"If you have a small team or are already comfortable with a centralized "
"workflow in your company or team, you can easily continue using that "
"workflow with Git. Simply set up a single repository, and give everyone on "
"your team push access; Git won’t let users overwrite each other. If one "
"developer clones, makes changes, and then tries to push their changes while "
"another developer has pushed in the meantime, the server will reject that "
"developer’s changes. They will be told that they’re trying to push non-fast-"
"forward changes and that they won’t be able to do so until they fetch and "
"merge.\n"
"This workflow is attractive to a lot of people because it’s a paradigm that "
"many are familiar and comfortable with."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:23
msgid "### Integration-Manager Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:25
msgid ""
"Because Git allows you to have multiple remote repositories, it’s possible "
"to have a workflow where each developer has write access to their own public "
"repository and read access to everyone else’s. This scenario often includes "
"a canonical repository that represents the \"official\" project. To "
"contribute to that project, you create your own public clone of the project "
"and push your changes to it. Then, you can send a request to the maintainer "
"of the main project to pull in your changes. They can add your repository as "
"a remote, test your changes locally, merge them into their branch, and push "
"back to their repository. The process works as follow (see Figure 5-2):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:27
msgid ""
"1. The project maintainer pushes to their public repository.\n"
"2. A contributor clones that repository and makes changes.\n"
"3. The contributor pushes to their own public copy.\n"
"4. The contributor sends the maintainer an e-mail asking them to pull "
"changes.\n"
"5. The maintainer adds the contributor’s repo as a remote and merges "
"locally.\n"
"6. The maintainer pushes merged changes to the main repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:34
msgid ""
"Insert 18333fig0502.png\n"
"Figure 5-2. Integration-manager workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:37
msgid ""
"This is a very common workflow with sites like GitHub, where it’s easy to "
"fork a project and push your changes into your fork for everyone to see. One "
"of the main advantages of this approach is that you can continue to work, "
"and the maintainer of the main repository can pull in your changes at any "
"time. Contributors don’t have to wait for the project to incorporate their "
"changes — each party can work at their own pace."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:39
msgid "### Dictator and Lieutenants Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:41
msgid ""
"This is a variant of a multiple-repository workflow. It’s generally used by "
"huge projects with hundreds of collaborators; one famous example is the "
"Linux kernel. Various integration managers are in charge of certain parts of "
"the repository; they’re called lieutenants. All the lieutenants have one "
"integration manager known as the benevolent dictator. The benevolent "
"dictator’s repository serves as the reference repository from which all the "
"collaborators need to pull. The process works like this (see Figure 5-3):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:43
msgid ""
"1. Regular developers work on their topic branch and rebase their work on "
"top of master. The master branch is that of the dictator.\n"
"2. Lieutenants merge the developers’ topic branches into their master "
"branch.\n"
"3. The dictator merges the lieutenants’ master branches into the dictator’s "
"master branch.\n"
"4. The dictator pushes their master to the reference repository so the other "
"developers can rebase on it."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:48
msgid ""
"Insert 18333fig0503.png\n"
"Figure 5-3. Benevolent dictator workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:51
msgid ""
"This kind of workflow isn’t common but can be useful in very big projects or "
"in highly hierarchical environments, as it allows the project leader (the "
"dictator) to delegate much of the work and collect large subsets of code at "
"multiple points before integrating them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:53
msgid ""
"These are some commonly used workflows that are possible with a distributed "
"system like Git, but you can see that many variations are possible to suit "
"your particular real-world workflow. Now that you can (I hope) determine "
"which workflow combination may work for you, I’ll cover some more specific "
"examples of how to accomplish the main roles that make up the different "
"flows."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:55
msgid "## Contributing to a Project ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:57
msgid ""
"You know what the different workflows are, and you should have a pretty good "
"grasp of fundamental Git usage. In this section, you’ll learn about a few "
"common patterns for contributing to a project."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:59
msgid ""
"The main difficulty with describing this process is that there are a huge "
"number of variations on how it’s done. Because Git is very flexible, people "
"can and do work together many ways, and it’s problematic to describe how you "
"should contribute to a project — every project is a bit different. Some of "
"the variables involved are active contributor size, chosen workflow, your "
"commit access, and possibly the external contribution method."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:61
msgid ""
"The first variable is active contributor size. How many users are actively "
"contributing code to this project, and how often? In many instances, you’ll "
"have two or three developers with a few commits a day, or possibly less for "
"somewhat dormant projects. For really large companies or projects, the "
"number of developers could be in the thousands, with dozens or even hundreds "
"of patches coming in each day. This is important because with more and more "
"developers, you run into more issues with making sure your code applies "
"cleanly or can be easily merged. Changes you submit may be rendered obsolete "
"or severely broken by work that is merged in while you were working or "
"while your changes were waiting to be approved or applied. How can you keep "
"your code consistently up to date and your patches valid?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:63
msgid ""
"The next variable is the workflow in use for the project. Is it centralized, "
"with each developer having equal write access to the main codeline? Does "
"the project have a maintainer or integration manager who checks all the "
"patches? Are all the patches peer-reviewed and approved? Are you involved in "
"that process? Is a lieutenant system in place, and do you have to submit "
"your work to them first?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:65
msgid ""
"The next issue is your commit access. The workflow required in order to "
"contribute to a project is much different if you have write access to the "
"project than if you don’t. If you don’t have write access, how does the "
"project prefer to accept contributed work? Does it even have a policy? How "
"much work are you contributing at a time? How often do you contribute?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:67
msgid ""
"All these questions can affect how you contribute effectively to a project "
"and what workflows are preferred or available to you. I’ll cover aspects of "
"each of these in a series of use cases, moving from simple to more complex; "
"you should be able to construct the specific workflows you need in practice "
"from these examples."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:69
msgid "### Commit Guidelines ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:71
msgid ""
"Before you start looking at the specific use cases, here’s a quick note "
"about commit messages. Having a good guideline for creating commits and "
"sticking to it makes working with Git and collaborating with others a lot "
"easier. The Git project provides a document that lays out a number of good "
"tips for creating commits from which to submit patches — you can read it in "
"the Git source code in the `Documentation/SubmittingPatches` file."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:73
msgid ""
"First, you don’t want to submit any whitespace errors. Git provides an easy "
"way to check for this — before you commit, run `git diff --check`, which "
"identifies possible whitespace errors and lists them for you. Here is an "
"example, where I’ve replaced a red terminal color with `X`s:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:75
msgid ""
"\t$ git diff --check\n"
"\tlib/simplegit.rb:5: trailing whitespace.\n"
"\t+    @git_dir = File.expand_path(git_dir)XX\n"
"\tlib/simplegit.rb:7: trailing whitespace.\n"
"\t+ XXXXXXXXXXX\n"
"\tlib/simplegit.rb:26: trailing whitespace.\n"
"\t+    def command(git_cmd)XXXX"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:83
msgid ""
"If you run that command before committing, you can tell if you’re about to "
"commit whitespace issues that may annoy other developers."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:85
msgid ""
"Next, try to make each commit a logically separate changeset. If you can, "
"try to make your changes digestible — don’t code for a whole weekend on five "
"different issues and then submit them all as one massive commit on Monday. "
"Even if you don’t commit during the weekend, use the staging area on Monday "
"to split your work into at least one commit per issue, with a useful message "
"per commit. If some of the changes modify the same file, try to use `git "
"add --patch` to partially stage files (covered in detail in Chapter 6). The "
"project snapshot at the tip of the branch is identical whether you do one "
"commit or five, as long as all the changes are added at some point, so try "
"to make things easier on your fellow developers when they have to review "
"your changes. This approach also makes it easier to pull out or revert one "
"of the changesets if you need to later. Chapter 6 describes a number of "
"useful Git tricks for rewriting history and interactively staging files — "
"use these tools to help craft a clean and understandable history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:87
msgid ""
"The last thing to keep in mind is the commit message. Getting in the habit "
"of creating quality commit messages makes using and collaborating with Git a "
"lot easier. As a general rule, your messages should start with a single "
"line that’s no more than about 50 characters and that describes the "
"changeset concisely, followed by a blank line, followed by a more detailed "
"explanation. The Git project requires that the more detailed explanation "
"include your motivation for the change and contrast its implementation with "
"previous behavior — this is a good guideline to follow. It’s also a good "
"idea to use the imperative present tense in these messages. In other words, "
"use commands. Instead of \"I added tests for\" or \"Adding tests for,\" use \"Add "
"tests for.\"\n"
"Here is a template originally written by Tim Pope at tpope.net:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:90
msgid "\tShort (50 chars or less) summary of changes"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:92
msgid ""
"\tMore detailed explanatory text, if necessary.  Wrap it to about 72\n"
"\tcharacters or so.  In some contexts, the first line is treated as the\n"
"\tsubject of an email and the rest of the text as the body.  The blank\n"
"\tline separating the summary from the body is critical (unless you omit\n"
"\tthe body entirely); tools like rebase can get confused if you run the\n"
"\ttwo together."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:99
msgid "\tFurther paragraphs come after blank lines."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:101
msgid "\t - Bullet points are okay, too"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:103
msgid ""
"\t - Typically a hyphen or asterisk is used for the bullet, preceded by a\n"
"\t   single space, with blank lines in between, but conventions vary here"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:106
msgid ""
"If all your commit messages look like this, things will be a lot easier for "
"you and the developers you work with. The Git project has well-formatted "
"commit messages — I encourage you to run `git log --no-merges` there to see "
"what a nicely formatted project-commit history looks like."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:108
msgid ""
"In the following examples, and throughout most of this book, for the sake of "
"brevity I don’t format messages nicely like this; instead, I use the `-m` "
"option to `git commit`. Do as I say, not as I do."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:110
msgid "### Private Small Team ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:112
msgid ""
"The simplest setup you’re likely to encounter is a private project with one "
"or two other developers. By private, I mean closed source — not read-"
"accessible to the outside world. You and the other developers all have push "
"access to the repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:114
msgid ""
"In this environment, you can follow a workflow similar to what you might do "
"when using Subversion or another centralized system. You still get the "
"advantages of things like offline committing and vastly simpler branching "
"and merging, but the workflow can be very similar; the main difference is "
"that merges happen client-side rather than on the server at commit time.\n"
"Let’s see what it might look like when two developers start to work together "
"with a shared repository. The first developer, John, clones the repository, "
"makes a change, and commits locally. (I’m replacing the protocol messages "
"with `...` in these examples to shorten them somewhat.)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:117
msgid ""
"\t# John's Machine\n"
"\t$ git clone john@githost:simplegit.git\n"
"\tInitialized empty Git repository in /home/john/simplegit/.git/\n"
"\t...\n"
"\t$ cd simplegit/\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'removed invalid default value'\n"
"\t[master 738ee87] removed invalid default value\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:127
msgid ""
"The second developer, Jessica, does the same thing — clones the repository "
"and commits a change:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:129
msgid ""
"\t# Jessica's Machine\n"
"\t$ git clone jessica@githost:simplegit.git\n"
"\tInitialized empty Git repository in /home/jessica/simplegit/.git/\n"
"\t...\n"
"\t$ cd simplegit/\n"
"\t$ vim TODO\n"
"\t$ git commit -am 'add reset task'\n"
"\t[master fbff5bc] add reset task\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:139
msgid "Now, Jessica pushes her work up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:141
msgid ""
"\t# Jessica's Machine\n"
"\t$ git push origin master\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   1edee6b..fbff5bc  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:147
msgid "John tries to push his change up, too:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:149
msgid ""
"\t# John's Machine\n"
"\t$ git push origin master\n"
"\tTo john@githost:simplegit.git\n"
"\t ! [rejected]        master -> master (non-fast forward)\n"
"\terror: failed to push some refs to 'john@githost:simplegit.git'"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:155
msgid ""
"John isn’t allowed to push because Jessica has pushed in the meantime. This "
"is especially important to understand if you’re used to Subversion, because "
"you’ll notice that the two developers didn’t edit the same file. Although "
"Subversion automatically does such a merge on the server if different files "
"are edited, in Git you must merge the commits locally. John has to fetch "
"Jessica’s changes and merge them in before he will be allowed to push:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:157
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom john@githost:simplegit\n"
"\t + 049d078...fbff5bc master     -> origin/master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:162
msgid "At this point, John’s local repository looks something like Figure 5-4."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:164
msgid ""
"Insert 18333fig0504.png\n"
"Figure 5-4. John’s initial repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:167
msgid ""
"John has a reference to the changes Jessica pushed up, but he has to merge "
"them into his own work before he is allowed to push:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:169
msgid ""
"\t$ git merge origin/master\n"
"\tMerge made by recursive.\n"
"\t TODO |    1 +\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:174
msgid ""
"The merge goes smoothly — John’s commit history now looks like Figure 5-5."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:176
msgid ""
"Insert 18333fig0505.png\n"
"Figure 5-5. John’s repository after merging origin/master."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:179
msgid ""
"Now, John can test his code to make sure it still works properly, and then "
"he can push his new merged work up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:181
msgid ""
"\t$ git push origin master\n"
"\t...\n"
"\tTo john@githost:simplegit.git\n"
"\t   fbff5bc..72bbc59  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:186
msgid "Finally, John’s commit history looks like Figure 5-6."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:188
msgid ""
"Insert 18333fig0506.png\n"
"Figure 5-6. John’s history after pushing to the origin server."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:191
msgid ""
"In the meantime, Jessica has been working on a topic branch. She’s created a "
"topic branch called `issue54` and done three commits on that branch. She "
"hasn’t fetched John’s changes yet, so her commit history looks like Figure "
"5-7."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:193
msgid ""
"Insert 18333fig0507.png\n"
"Figure 5-7. Jessica’s initial commit history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:196
msgid "Jessica wants to sync up with John, so she fetches:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:198
msgid ""
"\t# Jessica's Machine\n"
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t   fbff5bc..72bbc59  master     -> origin/master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:204
msgid ""
"That pulls down the work John has pushed up in the meantime. Jessica’s "
"history now looks like Figure 5-8."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:206
msgid ""
"Insert 18333fig0508.png\n"
"Figure 5-8. Jessica’s history after fetching John’s changes."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:209
msgid ""
"Jessica thinks her topic branch is ready, but she wants to know what she has "
"to merge her work into so that she can push. She runs `git log` to find "
"out:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:211
msgid ""
"\t$ git log --no-merges origin/master ^issue54\n"
"\tcommit 738ee872852dfaa9d6634e0dea7a324040193016\n"
"\tAuthor: John Smith <jsmith@example.com>\n"
"\tDate:   Fri May 29 16:01:27 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:216
msgid "\t    removed invalid default value"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:218
msgid ""
"Now, Jessica can merge her topic work into her master branch, merge John’s "
"work (`origin/master`) into her `master` branch, and then push back to the "
"server again. First, she switches back to her master branch to integrate all "
"this work:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:220
msgid ""
"\t$ git checkout master\n"
"\tSwitched to branch \"master\"\n"
"\tYour branch is behind 'origin/master' by 2 commits, and can be fast-"
"forwarded."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:224
msgid ""
"She can merge either `origin/master` or `issue54` first — they’re both "
"upstream, so the order doesn’t matter. The end snapshot should be identical "
"no matter which order she chooses; only the history will be slightly "
"different. She chooses to merge in `issue54` first:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:226
msgid ""
"\t$ git merge issue54\n"
"\tUpdating fbff5bc..4af4298\n"
"\tFast forward\n"
"\t README           |    1 +\n"
"\t lib/simplegit.rb |    6 +++++-\n"
"\t 2 files changed, 6 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:233
msgid ""
"No problems occur; as you can see, it was a simple fast-forward. Now Jessica "
"merges in John’s work (`origin/master`):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:235
msgid ""
"\t$ git merge origin/master\n"
"\tAuto-merging lib/simplegit.rb\n"
"\tMerge made by recursive.\n"
"\t lib/simplegit.rb |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:241
msgid "Everything merges cleanly, and Jessica’s history looks like Figure 5-9."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:243
msgid ""
"Insert 18333fig0509.png\n"
"Figure 5-9. Jessica’s history after merging John’s changes."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:246
msgid ""
"Now `origin/master` is reachable from Jessica’s `master` branch, so she "
"should be able to successfully push (assuming John hasn’t pushed again in "
"the meantime):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:248
msgid ""
"\t$ git push origin master\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   72bbc59..8059c15  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:253
msgid ""
"Each developer has committed a few times and merged each other’s work "
"successfully; see Figure 5-10."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:255
msgid ""
"Insert 18333fig0510.png\n"
"Figure 5-10. Jessica’s history after pushing all changes back to the server."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:258
msgid ""
"That is one of the simplest workflows. You work for a while, generally in a "
"topic branch, and merge into your master branch when it’s ready to be "
"integrated. When you want to share that work, you merge it into your own "
"master branch, then fetch and merge `origin/master` if it has changed, and "
"finally push to the `master` branch on the server. The general sequence is "
"something like that shown in Figure 5-11."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:260
msgid ""
"Insert 18333fig0511.png\n"
"Figure 5-11. General sequence of events for a simple multiple-developer Git "
"workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:263
msgid "### Private Managed Team ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:265
msgid ""
"In this next scenario, you’ll look at contributor roles in a larger private "
"group. You’ll learn how to work in an environment where small groups "
"collaborate on features and then those team-based contributions are "
"integrated by another party."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:267
msgid ""
"Let’s say that John and Jessica are working together on one feature, while "
"Jessica and Josie are working on a second. In this case, the company is "
"using a type of integration-manager workflow where the work of the "
"individual groups is integrated only by certain engineers, and the `master` "
"branch of the main repo can be updated only by those engineers. In this "
"scenario, all work is done in team-based branches and pulled together by the "
"integrators later."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:269
msgid ""
"Let’s follow Jessica’s workflow as she works on her two features, "
"collaborating in parallel with two different developers in this environment. "
"Assuming she already has her repository cloned, she decides to work on "
"`featureA` first. She creates a new branch for the feature and does some "
"work on it there:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:271
msgid ""
"\t# Jessica's Machine\n"
"\t$ git checkout -b featureA\n"
"\tSwitched to a new branch \"featureA\"\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'add limit to log function'\n"
"\t[featureA 3300904] add limit to log function\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:279
msgid ""
"At this point, she needs to share her work with John, so she pushes her "
"`featureA` branch commits up to the server. Jessica doesn’t have push access "
"to the `master` branch — only the integrators do — so she has to push to "
"another branch in order to collaborate with John:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:281
msgid ""
"\t$ git push origin featureA\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t * [new branch]      featureA -> featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:286
msgid ""
"Jessica e-mails John to tell him that she’s pushed some work into a branch "
"named `featureA` and he can look at it now. While she waits for feedback "
"from John, Jessica decides to start working on `featureB` with Josie. To "
"begin, she starts a new feature branch, basing it off the server’s `master` "
"branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:288
msgid ""
"\t# Jessica's Machine\n"
"\t$ git fetch origin\n"
"\t$ git checkout -b featureB origin/master\n"
"\tSwitched to a new branch \"featureB\""
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:293
msgid "Now, Jessica makes a couple of commits on the `featureB` branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:295
msgid ""
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'made the ls-tree function recursive'\n"
"\t[featureB e5b0fdc] made the ls-tree function recursive\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'add ls-files'\n"
"\t[featureB 8512791] add ls-files\n"
"\t 1 files changed, 5 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:304
msgid "Jessica’s repository looks like Figure 5-12."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:306
msgid ""
"Insert 18333fig0512.png\n"
"Figure 5-12. Jessica’s initial commit history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:309
msgid ""
"She’s ready to push up her work, but gets an e-mail from Josie that a branch "
"with some initial work on it was already pushed to the server as "
"`featureBee`. Jessica first needs to merge those changes in with her own "
"before she can push to the server. She can then fetch Josie’s changes down "
"with `git fetch`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:311
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t * [new branch]      featureBee -> origin/featureBee"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:316
msgid "Jessica can now merge this into the work she did with `git merge`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:318
msgid ""
"\t$ git merge origin/featureBee\n"
"\tAuto-merging lib/simplegit.rb\n"
"\tMerge made by recursive.\n"
"\t lib/simplegit.rb |    4 ++++\n"
"\t 1 files changed, 4 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:324
msgid ""
"There is a bit of a problem — she needs to push the merged work in her "
"`featureB` branch to the `featureBee` branch on the server. She can do so by "
"specifying the local branch followed by a colon (:) followed by the remote "
"branch to the `git push` command:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:326
msgid ""
"\t$ git push origin featureB:featureBee\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   fba9af8..cd685d1  featureB -> featureBee"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:331
msgid ""
"This is called a _refspec_. See Chapter 9 for a more detailed discussion of "
"Git refspecs and different things you can do with them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:333
msgid ""
"Next, John e-mails Jessica to say he’s pushed some changes to the `featureA` "
"branch and ask her to verify them. She runs a `git fetch` to pull down "
"those changes:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:335
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t   3300904..aad881d  featureA   -> origin/featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:340
msgid "Then, she can see what has been changed with `git log`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:342
msgid ""
"\t$ git log origin/featureA ^featureA\n"
"\tcommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6\n"
"\tAuthor: John Smith <jsmith@example.com>\n"
"\tDate:   Fri May 29 19:57:33 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:347
msgid "\t    changed log output to 30 from 25"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:349
msgid "Finally, she merges John’s work into her own `featureA` branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:351
msgid ""
"\t$ git checkout featureA\n"
"\tSwitched to branch \"featureA\"\n"
"\t$ git merge origin/featureA\n"
"\tUpdating 3300904..aad881d\n"
"\tFast forward\n"
"\t lib/simplegit.rb |   10 +++++++++-\n"
"\t1 files changed, 9 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:359
msgid ""
"Jessica wants to tweak something, so she commits again and then pushes this "
"back up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:361
msgid ""
"\t$ git commit -am 'small tweak'\n"
"\t[featureA 774b3ed] small tweak\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)\n"
"\t$ git push origin featureA\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   3300904..774b3ed  featureA -> featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:369
msgid "Jessica’s commit history now looks something like Figure 5-13."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:371
msgid ""
"Insert 18333fig0513.png\n"
"Figure 5-13. Jessica’s history after committing on a feature branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:374
msgid ""
"Jessica, Josie, and John inform the integrators that the `featureA` and "
"`featureBee` branches on the server are ready for integration into the "
"mainline. After they integrate these branches into the mainline, a fetch "
"will bring down the new merge commits, making the commit history look like "
"Figure 5-14."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:376
msgid ""
"Insert 18333fig0514.png\n"
"Figure 5-14. Jessica’s history after merging both her topic branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:379
msgid ""
"Many groups switch to Git because of this ability to have multiple teams "
"working in parallel, merging the different lines of work late in the "
"process. The ability of smaller subgroups of a team to collaborate via "
"remote branches without necessarily having to involve or impede the entire "
"team is a huge benefit of Git. The sequence for the workflow you saw here is "
"something like Figure 5-15."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:381
msgid ""
"Insert 18333fig0515.png\n"
"Figure 5-15. Basic sequence of this managed-team workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:384
msgid "### Public Small Project ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:386
msgid ""
"Contributing to public projects is a bit different. Because you don’t have "
"the permissions to directly update branches on the project, you have to get "
"the work to the maintainers some other way. This first example describes "
"contributing via forking on Git hosts that support easy forking. The "
"repo.or.cz and GitHub hosting sites both support this, and many project "
"maintainers expect this style of contribution. The next section deals with "
"projects that prefer to accept contributed patches via e-mail."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:388
msgid ""
"First, you’ll probably want to clone the main repository, create a topic "
"branch for the patch or patch series you’re planning to contribute, and do "
"your work there. The sequence looks basically like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:390
msgid ""
"\t$ git clone (url)\n"
"\t$ cd project\n"
"\t$ git checkout -b featureA\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ (work)\n"
"\t$ git commit"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:398
msgid ""
"You may want to use `rebase -i` to squash your work down to a single commit, "
"or rearrange the work in the commits to make the patch easier for the "
"maintainer to review — see Chapter 6 for more information about interactive "
"rebasing."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:400
msgid ""
"When your branch work is finished and you’re ready to contribute it back to "
"the maintainers, go to the original project page and click the \"Fork\" "
"button, creating your own writable fork of the project. You then need to add "
"in this new repository URL as a second remote, in this case named `myfork`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:402
msgid "\t$ git remote add myfork (url)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:404
msgid ""
"You need to push your work up to it. It’s easiest to push the remote branch "
"you’re working on up to your repository, rather than merging into your "
"master branch and pushing that up. The reason is that if the work isn’t "
"accepted or is cherry picked, you don’t have to rewind your master branch. "
"If the maintainers merge, rebase, or cherry-pick your work, you’ll "
"eventually get it back via pulling from their repository anyhow:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:406
msgid "\t$ git push myfork featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:408
msgid ""
"When your work has been pushed up to your fork, you need to notify the "
"maintainer. This is often called a pull request, and you can either generate "
"it via the website — GitHub has a \"pull request\" button that automatically "
"messages the maintainer — or run the `git request-pull` command and e-mail "
"the output to the project maintainer manually."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:410
msgid ""
"The `request-pull` command takes the base branch into which you want your "
"topic branch pulled and the Git repository URL you want them to pull from, "
"and outputs a summary of all the changes you’re asking to be pulled in. For "
"instance, if Jessica wants to send John a pull request, and she’s done two "
"commits on the topic branch she just pushed up, she can run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:412
msgid ""
"\t$ git request-pull origin/master myfork\n"
"\tThe following changes since commit "
"1edee6b1d61823a2de3b09c160d7080b8d1b3a40:\n"
"\t  John Smith (1):\n"
"\t        added a new function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:417
msgid "\tare available in the git repository at:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:419
msgid "\t  git://githost/simplegit.git featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:421
msgid ""
"\tJessica Smith (2):\n"
"\t      add limit to log function\n"
"\t      change log output to 30 from 25"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:425
msgid ""
"\t lib/simplegit.rb |   10 +++++++++-\n"
"\t 1 files changed, 9 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:428
msgid ""
"The output can be sent to the maintainer—it tells them where the work was "
"branched from, summarizes the commits, and tells where to pull this work "
"from."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:430
msgid ""
"On a project for which you’re not the maintainer, it’s generally easier to "
"have a branch like `master` always track `origin/master` and to do your work "
"in topic branches that you can easily discard if they’re rejected.  Having "
"work themes isolated into topic branches also makes it easier for you to "
"rebase your work if the tip of the main repository has moved in the meantime "
"and your commits no longer apply cleanly. For example, if you want to "
"submit a second topic of work to the project, don’t continue working on the "
"topic branch you just pushed up — start over from the main repository’s "
"`master` branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:432
msgid ""
"\t$ git checkout -b featureB origin/master\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ git push myfork featureB\n"
"\t$ (email maintainer)\n"
"\t$ git fetch origin"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:439
msgid ""
"Now, each of your topics is contained within a silo — similar to a patch "
"queue — that you can rewrite, rebase, and modify without the topics "
"interfering or interdepending on each other as in Figure 5-16."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:441
msgid ""
"Insert 18333fig0516.png\n"
"Figure 5-16. Initial commit history with featureB work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:444
msgid ""
"Let’s say the project maintainer has pulled in a bunch of other patches and "
"tried your first branch, but it no longer cleanly merges. In this case, you "
"can try to rebase that branch on top of `origin/master`, resolve the "
"conflicts for the maintainer, and then resubmit your changes:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:446
msgid ""
"\t$ git checkout featureA\n"
"\t$ git rebase origin/master\n"
"\t$ git push -f myfork featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:450
msgid "This rewrites your history to now look like Figure 5-17."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:452
msgid ""
"Insert 18333fig0517.png\n"
"Figure 5-17. Commit history after featureA work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:455
msgid ""
"Because you rebased the branch, you have to specify the `-f` to your push "
"command in order to be able to replace the `featureA` branch on the server "
"with a commit that isn’t a descendant of it. An alternative would be to push "
"this new work to a different branch on the server (perhaps called "
"`featureAv2`)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:457
msgid ""
"Let’s look at one more possible scenario: the maintainer has looked at work "
"in your second branch and likes the concept but would like you to change an "
"implementation detail. You’ll also take this opportunity to move the work to "
"be based off the project’s current `master` branch. You start a new branch "
"based off the current `origin/master` branch, squash the `featureB` changes "
"there, resolve any conflicts, make the implementation change, and then push "
"that up as a new branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:459
msgid ""
"\t$ git checkout -b featureBv2 origin/master\n"
"\t$ git merge --no-commit --squash featureB\n"
"\t$ (change implementation)\n"
"\t$ git commit\n"
"\t$ git push myfork featureBv2"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:465
msgid ""
"The `--squash` option takes all the work on the merged branch and squashes "
"it into one non-merge commit on top of the branch you’re on. The `--no-"
"commit` option tells Git not to automatically record a commit. This allows "
"you to introduce all the changes from another branch and then make more "
"changes before recording the new commit."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:467
msgid ""
"Now you can send the maintainer a message that you’ve made the requested "
"changes and they can find those changes in your `featureBv2` branch (see "
"Figure 5-18)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:469
msgid ""
"Insert 18333fig0518.png\n"
"Figure 5-18. Commit history after featureBv2 work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:472
msgid "### Public Large Project ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:474
msgid ""
"Many larger projects have established procedures for accepting patches — "
"you’ll need to check the specific rules for each project, because they will "
"differ. However, many larger public projects accept patches via a developer "
"mailing list, so I’ll go over an example of that now."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:476
msgid ""
"The workflow is similar to the previous use case — you create topic branches "
"for each patch series you work on. The difference is how you submit them to "
"the project. Instead of forking the project and pushing to your own "
"writable version, you generate e-mail versions of each commit series and "
"e-mail them to the developer mailing list:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:478
msgid ""
"\t$ git checkout -b topicA\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ (work)\n"
"\t$ git commit"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:484
msgid ""
"Now you have two commits that you want to send to the mailing list. You use "
"`git format-patch` to generate the mbox-formatted files that you can e-mail "
"to the list — it turns each commit into an e-mail message with the first "
"line of the commit message as the subject and the rest of the message plus "
"the patch that the commit introduces as the body. The nice thing about this "
"is that applying a patch from an e-mail generated with `format-patch` "
"preserves all the commit information properly, as you’ll see more of in the "
"next section when you apply these patches:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:486
msgid ""
"\t$ git format-patch -M origin/master\n"
"\t0001-add-limit-to-log-function.patch\n"
"\t0002-changed-log-output-to-30-from-25.patch"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:490
msgid ""
"The `format-patch` command prints out the names of the patch files it "
"creates. The `-M` switch tells Git to look for renames. The files end up "
"looking like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:492
msgid ""
"\t$ cat 0001-add-limit-to-log-function.patch\n"
"\tFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tDate: Sun, 6 Apr 2008 10:17:23 -0700\n"
"\tSubject: [PATCH 1/2] add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:498
msgctxt "en/05-distributed-git/01-chapter5.markdown:498"
msgid "\tLimit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:500
msgid ""
"\t---\n"
"\t lib/simplegit.rb |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:504
msgid ""
"\tdiff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"\tindex 76f47bc..f9815f1 100644\n"
"\t--- a/lib/simplegit.rb\n"
"\t+++ b/lib/simplegit.rb\n"
"\t@@ -14,7 +14,7 @@ class SimpleGit\n"
"\t   end"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:511
msgid ""
"\t   def log(treeish = 'master')\n"
"\t-    command(\"git log #{treeish}\")\n"
"\t+    command(\"git log -n 20 #{treeish}\")\n"
"\t   end"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:516
msgid ""
"\t   def ls_tree(treeish = 'master')\n"
"\t--\n"
"\t1.6.2.rc1.20.g8c5b.dirty"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:520
msgid ""
"You can also edit these patch files to add more information for the e-mail "
"list that you don’t want to show up in the commit message. If you add text "
"between the `--` line and the beginning of the patch (the `lib/simplegit.rb` "
"line), then developers can read it; but applying the patch excludes it."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:522
msgid ""
"To e-mail this to a mailing list, you can either paste the file into your "
"e-mail program or send it via a command-line program. Pasting the text often "
"causes formatting issues, especially with \"smarter\" clients that don’t "
"preserve newlines and other whitespace appropriately. Luckily, Git provides "
"a tool to help you send properly formatted patches via IMAP, which may be "
"easier for you. I’ll demonstrate how to send a patch via Gmail, which "
"happens to be the e-mail agent I use; you can read detailed instructions for "
"a number of mail programs at the end of the aforementioned "
"`Documentation/SubmittingPatches` file in the Git source code."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:524
msgid ""
"First, you need to set up the imap section in your `~/.gitconfig` file. You "
"can set each value separately with a series of `git config` commands, or you "
"can add them manually; but in the end, your config file should look "
"something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:526
msgid ""
"\t[imap]\n"
"\t  folder = \"[Gmail]/Drafts\"\n"
"\t  host = imaps://imap.gmail.com\n"
"\t  user = user@gmail.com\n"
"\t  pass = p4ssw0rd\n"
"\t  port = 993\n"
"\t  sslverify = false"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:534
msgid ""
"If your IMAP server doesn’t use SSL, the last two lines probably aren’t "
"necessary, and the host value will be `imap://` instead of `imaps://`.\n"
"When that is set up, you can use `git send-email` to place the patch series "
"in the Drafts folder of the specified IMAP server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:537
msgid ""
"\t$ git send-email *.patch\n"
"\t0001-added-limit-to-log-function.patch\n"
"\t0002-changed-log-output-to-30-from-25.patch\n"
"\tWho should the emails appear to be from? [Jessica Smith "
"<jessica@example.com>]\n"
"\tEmails will be sent from: Jessica Smith <jessica@example.com>\n"
"\tWho should the emails be sent to? jessica@example.com\n"
"\tMessage-ID to be used as In-Reply-To for the first email? y"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:545
msgid ""
"Then, Git spits out a bunch of log information looking something like this "
"for each patch you’re sending:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:547
msgid ""
"\t(mbox) Adding cc: Jessica Smith <jessica@example.com> from\n"
"\t  \\line 'From: Jessica Smith <jessica@example.com>'\n"
"\tOK. Log says:\n"
"\tSendmail: /usr/sbin/sendmail -i jessica@example.com\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tTo: jessica@example.com\n"
"\tSubject: [PATCH 1/2] added limit to log function\n"
"\tDate: Sat, 30 May 2009 13:29:15 -0700\n"
"\tMessage-Id: <1243715356-61726-1-git-send-email-jessica@example.com>\n"
"\tX-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty\n"
"\tIn-Reply-To: <y>\n"
"\tReferences: <y>"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:560
msgid "\tResult: OK"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:562
msgid ""
"At this point, you should be able to go to your Drafts folder, change the To "
"field to the mailing list you’re sending the patch to, possibly CC the "
"maintainer or person responsible for that section, and send it off."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:564
msgid "### Summary ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:566
msgid ""
"This section has covered a number of common workflows for dealing with "
"several very different types of Git projects you’re likely to encounter and "
"introduced a couple of new tools to help you manage this process. Next, "
"you’ll see how to work the other side of the coin: maintaining a Git "
"project. You’ll learn how to be a benevolent dictator or integration "
"manager."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:568
msgid "## Maintaining a Project ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:570
msgid ""
"In addition to knowing how to effectively contribute to a project, you’ll "
"likely need to know how to maintain one. This can consist of accepting and "
"applying patches generated via `format-patch` and e-mailed to you, or "
"integrating changes in remote branches for repositories you’ve added as "
"remotes to your project. Whether you maintain a canonical repository or want "
"to help by verifying or approving patches, you need to know how to accept "
"work in a way that is clearest for other contributors and sustainable by you "
"over the long run."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:572
msgid "### Working in Topic Branches ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:574
msgid ""
"When you’re thinking of integrating new work, it’s generally a good idea to "
"try it out in a topic branch — a temporary branch specifically made to try "
"out that new work. This way, it’s easy to tweak a patch individually and "
"leave it if it’s not working until you have time to come back to it. If you "
"create a simple branch name based on the theme of the work you’re going to "
"try, such as `ruby_client` or something similarly descriptive, you can "
"easily remember it if you have to abandon it for a while and come back "
"later. The maintainer of the Git project tends to namespace these branches "
"as well — such as `sc/ruby_client`, where `sc` is short for the person who "
"contributed the work.\n"
"As you’ll remember, you can create the branch based off your master branch "
"like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:577
msgid "\t$ git branch sc/ruby_client master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:579
msgid ""
"Or, if you want to also switch to it immediately, you can use the `checkout "
"-b` command:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:581
msgid "\t$ git checkout -b sc/ruby_client master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:583
msgid ""
"Now you’re ready to add your contributed work into this topic branch and "
"determine if you want to merge it into your longer-term branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:585
msgid "### Applying Patches from E-mail ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:587
msgid ""
"If you receive a patch over e-mail that you need to integrate into your "
"project, you need to apply the patch in your topic branch to evaluate it. "
"There are two ways to apply an e-mailed patch: with `git apply` or with `git "
"am`."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:589
msgid "#### Applying a Patch with apply ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:591
msgid ""
"If you received the patch from someone who generated it with the `git diff` "
"or a Unix `diff` command, you can apply it with the `git apply` command. "
"Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can "
"apply the patch like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:593
msgid "\t$ git apply /tmp/patch-ruby-client.patch"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:595
msgid ""
"This modifies the files in your working directory. It’s almost identical to "
"running a `patch -p1` command to apply the patch, although it’s more "
"paranoid and accepts fewer fuzzy matches than patch. It also handles file "
"adds, deletes, and renames if they’re described in the `git diff` format, "
"which `patch` won’t do. Finally, `git apply` is an \"apply all or abort all\" "
"model where either everything is applied or nothing is, whereas `patch` can "
"partially apply patchfiles, leaving your working directory in a weird state. "
"`git apply` is overall much more paranoid than `patch`. It won’t create a "
"commit for you — after running it, you must stage and commit the changes "
"introduced manually."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:597
msgid ""
"You can also use git apply to see if a patch applies cleanly before you try "
"actually applying it — you can run `git apply --check` with the patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:599
msgid ""
"\t$ git apply --check 0001-seeing-if-this-helps-the-gem.patch\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:603
msgid ""
"If there is no output, then the patch should apply cleanly. This command "
"also exits with a non-zero status if the check fails, so you can use it in "
"scripts if you want."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:605
msgid "#### Applying a Patch with am ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:607
msgid ""
"If the contributor is a Git user and was good enough to use the `format-"
"patch` command to generate their patch, then your job is easier because the "
"patch contains author information and a commit message for you. If you can, "
"encourage your contributors to use `format-patch` instead of `diff` to "
"generate patches for you. You should only have to use `git apply` for legacy "
"patches and things like that."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:609
msgid ""
"To apply a patch generated by `format-patch`, you use `git am`. Technically, "
"`git am` is built to read an mbox file, which is a simple, plain-text "
"format for storing one or more e-mail messages in one text file. It looks "
"something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:611
msgid ""
"\tFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tDate: Sun, 6 Apr 2008 10:17:23 -0700\n"
"\tSubject: [PATCH 1/2] add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:616
msgctxt "en/05-distributed-git/01-chapter5.markdown:616"
msgid "\tLimit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:618
msgid ""
"This is the beginning of the output of the format-patch command that you saw "
"in the previous section. This is also a valid mbox e-mail format. If "
"someone has e-mailed you the patch properly using git send-email, and you "
"download that into an mbox format, then you can point git am to that mbox "
"file, and it will start applying all the patches it sees. If you run a mail "
"client that can save several e-mails out in mbox format, you can save entire "
"patch series into a file and then use git am to apply them one at a time."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:620
msgid ""
"However, if someone uploaded a patch file generated via `format-patch` to a "
"ticketing system or something similar, you can save the file locally and "
"then pass that file saved on your disk to `git am` to apply it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:622
msgid ""
"\t$ git am 0001-limit-log-function.patch\n"
"\tApplying: add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:625
msgid ""
"You can see that it applied cleanly and automatically created the new commit "
"for you. The author information is taken from the e-mail’s `From` and "
"`Date` headers, and the message of the commit is taken from the `Subject` "
"and body (before the patch) of the e-mail. For example, if this patch was "
"applied from the mbox example I just showed, the commit generated would look "
"something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:627
msgid ""
"\t$ git log --pretty=fuller -1\n"
"\tcommit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\n"
"\tAuthor:     Jessica Smith <jessica@example.com>\n"
"\tAuthorDate: Sun Apr 6 10:17:23 2008 -0700\n"
"\tCommit:     Scott Chacon <schacon@gmail.com>\n"
"\tCommitDate: Thu Apr 9 09:19:06 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:634
msgid "\t   add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:636
msgid "\t   Limit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:638
msgid ""
"The `Commit` information indicates the person who applied the patch and the "
"time it was applied. The `Author` information is the individual who "
"originally created the patch and when it was originally created."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:640
msgid ""
"But it’s possible that the patch won’t apply cleanly. Perhaps your main "
"branch has diverged too far from the branch the patch was built from, or the "
"patch depends on another patch you haven’t applied yet. In that case, the "
"`git am` process will fail and ask you what you want to do:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:642
msgid ""
"\t$ git am 0001-seeing-if-this-helps-the-gem.patch\n"
"\tApplying: seeing if this helps the gem\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply\n"
"\tPatch failed at 0001.\n"
"\tWhen you have resolved this problem run \"git am --resolved\".\n"
"\tIf you would prefer to skip this patch, instead run \"git am --skip\".\n"
"\tTo restore the original branch and stop patching run \"git am --abort\"."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:651
msgid ""
"This command puts conflict markers in any files it has issues with, much "
"like a conflicted merge or rebase operation. You solve this issue much the "
"same way — edit the file to resolve the conflict, stage the new file, and "
"then run `git am --resolved` to continue to the next patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:653
msgid ""
"\t$ (fix the file)\n"
"\t$ git add ticgit.gemspec\n"
"\t$ git am --resolved\n"
"\tApplying: seeing if this helps the gem"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:658
msgid ""
"If you want Git to try a bit more intelligently to resolve the conflict, you "
"can pass a `-3` option to it, which makes Git attempt a three-way merge. "
"This option isn’t on by default because it doesn’t work if the commit the "
"patch says it was based on isn’t in your repository. If you do have that "
"commit — if the patch was based on a public commit — then the `-3` option is "
"generally much smarter about applying a conflicting patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:660
msgid ""
"\t$ git am -3 0001-seeing-if-this-helps-the-gem.patch\n"
"\tApplying: seeing if this helps the gem\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply\n"
"\tUsing index info to reconstruct a base tree...\n"
"\tFalling back to patching base and 3-way merge...\n"
"\tNo changes -- Patch already applied."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:668
msgid ""
"In this case, I was trying to apply a patch I had already applied. Without "
"the `-3` option, it looks like a conflict."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:670
msgid ""
"If you’re applying a number of patches from an mbox, you can also run the "
"`am` command in interactive mode, which stops at each patch it finds and "
"asks if you want to apply it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:672
msgid ""
"\t$ git am -3 -i mbox\n"
"\tCommit Body is:\n"
"\t--------------------------\n"
"\tseeing if this helps the gem\n"
"\t--------------------------\n"
"\tApply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:679
msgid ""
"This is nice if you have a number of patches saved, because you can view the "
"patch first if you don’t remember what it is, or not apply the patch if "
"you’ve already done so."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:681
msgid ""
"When all the patches for your topic are applied and committed into your "
"branch, you can choose whether and how to integrate them into a longer-"
"running branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:683
msgid "### Checking Out Remote Branches ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:685
msgid ""
"If your contribution came from a Git user who set up their own repository, "
"pushed a number of changes into it, and then sent you the URL to the "
"repository and the name of the remote branch the changes are in, you can add "
"them as a remote and do merges locally."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:687
msgid ""
"For instance, if Jessica sends you an e-mail saying that she has a great new "
"feature in the `ruby-client` branch of her repository, you can test it by "
"adding the remote and checking out that branch locally:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:689
msgid ""
"\t$ git remote add jessica git://github.com/jessica/myproject.git\n"
"\t$ git fetch jessica\n"
"\t$ git checkout -b rubyclient jessica/ruby-client"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:693
msgid ""
"If she e-mails you again later with another branch containing another great "
"feature, you can fetch and check out because you already have the remote "
"setup."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:695
msgid ""
"This is most useful if you’re working with a person consistently. If someone "
"only has a single patch to contribute once in a while, then accepting it "
"over e-mail may be less time consuming than requiring everyone to run their "
"own server and having to continually add and remove remotes to get a few "
"patches. You’re also unlikely to want to have hundreds of remotes, each for "
"someone who contributes only a patch or two. However, scripts and hosted "
"services may make this easier — it depends largely on how you develop and "
"how your contributors develop."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:697
msgid ""
"The other advantage of this approach is that you get the history of the "
"commits as well. Although you may have legitimate merge issues, you know "
"where in your history their work is based; a proper three-way merge is the "
"default rather than having to supply a `-3` and hope the patch was generated "
"off a public commit to which you have access."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:699
msgid ""
"If you aren’t working with a person consistently but still want to pull from "
"them in this way, you can provide the URL of the remote repository to the "
"`git pull` command. This does a one-time pull and doesn’t save the URL as a "
"remote reference:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:701
msgid ""
"\t$ git pull git://github.com/onetimeguy/project.git\n"
"\tFrom git://github.com/onetimeguy/project\n"
"\t * branch            HEAD       -> FETCH_HEAD\n"
"\tMerge made by recursive."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:706
msgid "### Determining What Is Introduced ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:708
msgid ""
"Now you have a topic branch that contains contributed work. At this point, "
"you can determine what you’d like to do with it. This section revisits a "
"couple of commands so you can see how you can use them to review exactly "
"what you’ll be introducing if you merge this into your main branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:710
msgid ""
"It’s often helpful to get a review of all the commits that are in this "
"branch but that aren’t in your master branch. You can exclude commits in the "
"master branch by adding the `--not` option before the branch name. For "
"example, if your contributor sends you two patches and you create a branch "
"called `contrib` and applied those patches there, you can run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:712
msgid ""
"\t$ git log contrib --not master\n"
"\tcommit 5b6235bd297351589efc4d73316f0a68d484f118\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri Oct 24 09:53:59 2008 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:717
msgid "\t    seeing if this helps the gem"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:719
msgid ""
"\tcommit 7482e0d16d04bea79d0dba8988cc78df655f16a0\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Mon Oct 22 19:38:36 2008 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:723
msgid "\t    updated the gemspec to hopefully work better"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:725
msgid ""
"To see what changes each commit introduces, remember that you can pass the "
"`-p` option to `git log` and it will append the diff introduced to each "
"commit."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:727
msgid ""
"To see a full diff of what would happen if you were to merge this topic "
"branch with another branch, you may have to use a weird trick to get the "
"correct results. You may think to run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:729
msgid "\t$ git diff master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:731
msgid ""
"This command gives you a diff, but it may be misleading. If your `master` "
"branch has moved forward since you created the topic branch from it, then "
"you’ll get seemingly strange results. This happens because Git directly "
"compares the snapshots of the last commit of the topic branch you’re on and "
"the snapshot of the last commit on the `master` branch. For example, if "
"you’ve added a line in a file on the `master` branch, a direct comparison of "
"the snapshots will look like the topic branch is going to remove that line."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:733
msgid ""
"If `master` is a direct ancestor of your topic branch, this isn’t a problem; "
"but if the two histories have diverged, the diff will look like you’re "
"adding all the new stuff in your topic branch and removing everything unique "
"to the `master` branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:735
msgid ""
"What you really want to see are the changes added to the topic branch — the "
"work you’ll introduce if you merge this branch with master. You do that by "
"having Git compare the last commit on your topic branch with the first "
"common ancestor it has with the master branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:737
msgid ""
"Technically, you can do that by explicitly figuring out the common ancestor "
"and then running your diff on it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:739
msgid ""
"\t$ git merge-base contrib master\n"
"\t36c7dba2c95e6bbb78dfa822519ecfec6e1ca649\n"
"\t$ git diff 36c7db"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:743
msgid ""
"However, that isn’t convenient, so Git provides another shorthand for doing "
"the same thing: the triple-dot syntax. In the context of the `diff` command, "
"you can put three periods after another branch to do a `diff` between the "
"last commit of the branch you’re on and its common ancestor with another "
"branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:745
msgid "\t$ git diff master...contrib"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:747
msgid ""
"This command shows you only the work your current topic branch has "
"introduced since its common ancestor with master. That is a very useful "
"syntax to remember."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:749
msgid "### Integrating Contributed Work ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:751
msgid ""
"When all the work in your topic branch is ready to be integrated into a more "
"mainline branch, the question is how to do it. Furthermore, what overall "
"workflow do you want to use to maintain your project? You have a number of "
"choices, so I’ll cover a few of them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:753
msgid "#### Merging Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:755
msgid ""
"One simple workflow merges your work into your `master` branch. In this "
"scenario, you have a `master` branch that contains basically stable code. "
"When you have work in a topic branch that you’ve done or that someone has "
"contributed and you’ve verified, you merge it into your master branch, "
"delete the topic branch, and then continue the process.  If we have a "
"repository with work in two branches named `ruby_client` and `php_client` "
"that looks like Figure 5-19 and merge `ruby_client` first and then "
"`php_client` next, then your history will end up looking like Figure 5-20."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:757
msgid ""
"Insert 18333fig0519.png\n"
"Figure 5-19. History with several topic branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:760
msgid ""
"Insert 18333fig0520.png\n"
"Figure 5-20. After a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:763
msgid ""
"That is probably the simplest workflow, but it’s problematic if you’re "
"dealing with larger repositories or projects."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:765
msgid ""
"If you have more developers or a larger project, you’ll probably want to use "
"at least a two-phase merge cycle. In this scenario, you have two long-"
"running branches, `master` and `develop`, in which you determine that "
"`master` is updated only when a very stable release is cut and all new code "
"is integrated into the `develop` branch. You regularly push both of these "
"branches to the public repository. Each time you have a new topic branch to "
"merge in (Figure 5-21), you merge it into `develop` (Figure 5-22); then, "
"when you tag a release, you fast-forward `master` to wherever the now-stable "
"`develop` branch is (Figure 5-23)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:767
msgid ""
"Insert 18333fig0521.png\n"
"Figure 5-21. Before a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:770
msgid ""
"Insert 18333fig0522.png\n"
"Figure 5-22. After a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:773
msgid ""
"Insert 18333fig0523.png\n"
"Figure 5-23. After a topic branch release."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:776
msgid ""
"This way, when people clone your project’s repository, they can either check "
"out master to build the latest stable version and keep up to date on that "
"easily, or they can check out develop, which is the more cutting-edge stuff.\n"
"You can also continue this concept, having an integrate branch where all the "
"work is merged together. Then, when the codebase on that branch is stable "
"and passes tests, you merge it into a develop branch; and when that has "
"proven itself stable for a while, you fast-forward your master branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:779
msgid "#### Large-Merging Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:781
msgid ""
"The Git project has four long-running branches: `master`, `next`, and `pu` "
"(proposed updates) for new work, and `maint` for maintenance backports. When "
"new work is introduced by contributors, it’s collected into topic branches "
"in the maintainer’s repository in a manner similar to what I’ve described "
"(see Figure 5-24). At this point, the topics are evaluated to determine "
"whether they’re safe and ready for consumption or whether they need more "
"work. If they’re safe, they’re merged into `next`, and that branch is pushed "
"up so everyone can try the topics integrated together."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:783
msgid ""
"Insert 18333fig0524.png\n"
"Figure 5-24. Managing a complex series of parallel contributed topic "
"branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:786
msgid ""
"If the topics still need work, they’re merged into `pu` instead. When it’s "
"determined that they’re totally stable, the topics are re-merged into "
"`master` and are then rebuilt from the topics that were in `next` but didn’t "
"yet graduate to `master`. This means `master` almost always moves forward, "
"`next` is rebased occasionally, and `pu` is rebased even more often (see "
"Figure 5-25)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:788
msgid ""
"Insert 18333fig0525.png\n"
"Figure 5-25. Merging contributed topic branches into long-term integration "
"branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:791
msgid ""
"When a topic branch has finally been merged into `master`, it’s removed from "
"the repository. The Git project also has a `maint` branch that is forked "
"off from the last release to provide backported patches in case a "
"maintenance release is required. Thus, when you clone the Git repository, "
"you have four branches that you can check out to evaluate the project in "
"different stages of development, depending on how cutting edge you want to "
"be or how you want to contribute; and the maintainer has a structured "
"workflow to help them vet new contributions."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:793
msgid "#### Rebasing and Cherry Picking Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:795
msgid ""
"Other maintainers prefer to rebase or cherry-pick contributed work on top of "
"their master branch, rather than merging it in, to keep a mostly linear "
"history. When you have work in a topic branch and have determined that you "
"want to integrate it, you move to that branch and run the rebase command to "
"rebuild the changes on top of your current master (or `develop`, and so on) "
"branch. If that works well, you can fast-forward your `master` branch, and "
"you’ll end up with a linear project history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:797
msgid ""
"The other way to move introduced work from one branch to another is to "
"cherry-pick it. A cherry-pick in Git is like a rebase for a single commit. "
"It takes the patch that was introduced in a commit and tries to reapply it "
"on the branch you’re currently on. This is useful if you have a number of "
"commits on a topic branch and you want to integrate only one of them, or if "
"you only have one commit on a topic branch and you’d prefer to cherry-pick "
"it rather than run rebase. For example, suppose you have a project that "
"looks like Figure 5-26."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:799
msgid ""
"Insert 18333fig0526.png\n"
"Figure 5-26. Example history before a cherry pick."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:802
msgid "If you want to pull commit `e43a6` into your master branch, you can run"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:804
msgid ""
"\t$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf\n"
"\tFinished one cherry-pick.\n"
"\t[master]: created a0a41a9: \"More friendly message when locking the index "
"fails.\"\n"
"\t 3 files changed, 17 insertions(+), 3 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:809
msgid ""
"This pulls the same change introduced in `e43a6`, but you get a new commit "
"SHA-1 value, because the date applied is different. Now your history looks "
"like Figure 5-27."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:811
msgid ""
"Insert 18333fig0527.png\n"
"Figure 5-27. History after cherry-picking a commit on a topic branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:814
msgid ""
"Now you can remove your topic branch and drop the commits you didn’t want to "
"pull in."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:816
msgid "### Tagging Your Releases ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:818
msgid ""
"When you’ve decided to cut a release, you’ll probably want to drop a tag so "
"you can re-create that release at any point going forward. You can create a "
"new tag as I discussed in Chapter 2. If you decide to sign the tag as the "
"maintainer, the tagging may look something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:820
msgid ""
"\t$ git tag -s v1.5 -m 'my signed 1.5 tag'\n"
"\tYou need a passphrase to unlock the secret key for\n"
"\tuser: \"Scott Chacon <schacon@gmail.com>\"\n"
"\t1024-bit DSA key, ID F721C45A, created 2009-02-09"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:825
msgid ""
"If you do sign your tags, you may have the problem of distributing the "
"public PGP key used to sign your tags. The maintainer of the Git project has "
"solved this issue by including their public key as a blob in the repository "
"and then adding a tag that points directly to that content. To do this, you "
"can figure out which key you want by running `gpg --list-keys`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:827
msgid ""
"\t$ gpg --list-keys\n"
"\t/Users/schacon/.gnupg/pubring.gpg\n"
"\t---------------------------------\n"
"\tpub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]\n"
"\tuid                  Scott Chacon <schacon@gmail.com>\n"
"\tsub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:834
msgid ""
"Then, you can directly import the key into the Git database by exporting it "
"and piping that through `git hash-object`, which writes a new blob with "
"those contents into Git and gives you back the SHA-1 of the blob:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:836
msgid ""
"\t$ gpg -a --export F721C45A | git hash-object -w --stdin\n"
"\t659ef797d181633c87ec71ac3f9ba29fe5775b92"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:839
msgid ""
"Now that you have the contents of your key in Git, you can create a tag that "
"points directly to it by specifying the new SHA-1 value that the `hash-"
"object` command gave you:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:841
msgid ""
"\t$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:843
msgid ""
"If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared "
"with everyone. If anyone wants to verify a tag, they can directly import "
"your PGP key by pulling the blob directly out of the database and importing "
"it into GPG:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:845
msgid "\t$ git show maintainer-pgp-pub | gpg --import"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:847
msgid ""
"They can use that key to verify all your signed tags. Also, if you include "
"instructions in the tag message, running `git show <tag>` will let you give "
"the end user more specific instructions about tag verification."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:849
msgid "### Generating a Build Number ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:851
msgid ""
"Because Git doesn’t have monotonically increasing numbers like 'v123' or the "
"equivalent to go with each commit, if you want to have a human-readable "
"name to go with a commit, you can run `git describe` on that commit. Git "
"gives you the name of the nearest tag with the number of commits on top of "
"that tag and a partial SHA-1 value of the commit you’re describing:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:853
msgid ""
"\t$ git describe master\n"
"\tv1.6.2-rc1-20-g8c5b85c"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:856
msgid ""
"This way, you can export a snapshot or build and name it something "
"understandable to people. In fact, if you build Git from source code cloned "
"from the Git repository, `git --version` gives you something that looks like "
"this. If you’re describing a commit that you have directly tagged, it gives "
"you the tag name."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:858
msgid ""
"The `git describe` command favors annotated tags (tags created with the `-a` "
"or `-s` flag), so release tags should be created this way if you’re using "
"`git describe`, to ensure the commit is named properly when described. You "
"can also use this string as the target of a checkout or show command, "
"although it relies on the abbreviated SHA-1 value at the end, so it may not "
"be valid forever. For instance, the Linux kernel recently jumped from 8 to "
"10 characters to ensure SHA-1 object uniqueness, so older `git describe` "
"output names were invalidated."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:860
msgid "### Preparing a Release ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:862
msgid ""
"Now you want to release a build. One of the things you’ll want to do is "
"create an archive of the latest snapshot of your code for those poor souls "
"who don’t use Git. The command to do this is `git archive`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:864
msgid ""
"\t$ git archive master --prefix='project/' | gzip > `git describe "
"master`.tar.gz\n"
"\t$ ls *.tar.gz\n"
"\tv1.6.2-rc1-20-g8c5b85c.tar.gz"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:868
msgid ""
"If someone opens that tarball, they get the latest snapshot of your project "
"under a project directory. You can also create a zip archive in much the "
"same way, but by passing the `--format=zip` option to `git archive`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:870
msgid ""
"\t$ git archive master --prefix='project/' --format=zip > `git describe "
"master`.zip"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:872
msgid ""
"You now have a nice tarball and a zip archive of your project release that "
"you can upload to your website or e-mail to people."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:874
msgid "### The Shortlog ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:876
msgid ""
"It’s time to e-mail your mailing list of people who want to know what’s "
"happening in your project. A nice way of quickly getting a sort of changelog "
"of what has been added to your project since your last release or e-mail is "
"to use the `git shortlog` command. It summarizes all the commits in the "
"range you give it; for example, the following gives you a summary of all the "
"commits since your last release, if your last release was named v1.0.1:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:878
msgid ""
"\t$ git shortlog --no-merges master --not v1.0.1\n"
"\tChris Wanstrath (8):\n"
"\t      Add support for annotated tags to Grit::Tag\n"
"\t      Add packed-refs annotated tag support.\n"
"\t      Add Grit::Commit#to_patch\n"
"\t      Update version and History.txt\n"
"\t      Remove stray `puts`\n"
"\t      Make ls_tree ignore nils"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:887
msgid ""
"\tTom Preston-Werner (4):\n"
"\t      fix dates in history\n"
"\t      dynamic version method\n"
"\t      Version bump to 1.0.2\n"
"\t      Regenerated gemspec for version 1.0.2"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:893
msgid ""
"You get a clean summary of all the commits since v1.0.1, grouped by author, "
"that you can e-mail to your list."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:895
msgid "## Summary ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:897
msgid ""
"You should feel fairly comfortable contributing to a project in Git as well "
"as maintaining your own project or integrating other users’ contributions. "
"Congratulations on being an effective Git developer! In the next chapter, "
"you’ll learn more powerful tools and tips for dealing with complex "
"situations, which will truly make you a Git master."
msgstr ""
