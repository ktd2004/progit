#. #-#-#-#-#  01.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/01-introduction/01-chapter1.markdown
#. #-#-#-#-#  02.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/02-git-basics/01-chapter2.markdown
#. #-#-#-#-#  03.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/03-git-branching/01-chapter3.markdown
#. #-#-#-#-#  04.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/04-git-server/01-chapter4.markdown
#. #-#-#-#-#  05.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/05-distributed-git/01-chapter5.markdown
#. #-#-#-#-#  06.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/06-git-tools/01-chapter6.markdown
#. #-#-#-#-#  07.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/07-customizing-git/01-chapter7.markdown
#. #-#-#-#-#  08.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/08-git-and-other-scms/01-chapter8.markdown
#. #-#-#-#-#  09.pot (PACKAGE VERSION)  #-#-#-#-#
#. extracted from en/09-git-internals/01-chapter9.markdown
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-01-03 12:40+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.9.0\n"

#: en/01-introduction/01-chapter1.markdown:1
msgid "# Getting Started #"
msgstr "# 시작하기 #"

#: en/01-introduction/01-chapter1.markdown:3
msgid ""
"This chapter will be about getting started with Git.  We will begin at the "
"beginning by explaining some background on version control tools, then move "
"on to how to get Git running on your system and finally how to get it setup "
"to start working with.  At the end of this chapter you should understand why "
"Git is around, why you should use it and you should be all setup to do so."
msgstr ""
"이 장에서는 처음 접하는 사람들에게 Git을 설명한다. 먼저 버전 관리 도구에 대한 이해를, 그리고 Git을 설치하는 방법을, 마지막으로 "
"Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git의 탄생 배경, Git을 사용하는 이유, Git을 "
"설정하고 사용하는 방법을 터득할 것이다."

#: en/01-introduction/01-chapter1.markdown:5
msgid "## About Version Control ##"
msgstr "## 버전 관리란? ##"

#: en/01-introduction/01-chapter1.markdown:7
msgid ""
"What is version control, and why should you care? Version control is a "
"system that records changes to a file or set of files over time so that you "
"can recall specific versions later. Even though the examples in this book "
"show software source code as the files under version control, in reality any "
"type of file on a computer can be placed under version control."
msgstr ""
"버전 관리는 무엇이고, 우리는 왜 이것을 알아야 할까? 버전 관리는 파일들의 변화를 시간에 따라 기록하는 것이다. 이 책에 있는 모든 "
"예제는 모두 버전 관리 시스템을 사용한다. 실제로 컴퓨터에서 사용하는 거의 모든 파일의 버전을 관리할 수 있다."

#: en/01-introduction/01-chapter1.markdown:9
msgid ""
"If you are a graphic or web designer and want to keep every version of an "
"image or layout (which you certainly would), it is very wise to use a "
"Version Control System (VCS). A VCS allows you to: revert files back to a "
"previous state, revert the entire project back to a previous state, compare "
"changes over time, see who last modified something that might be causing a "
"problem, who introduced an issue and when, and more. Using a VCS also means "
"that if you screw things up or lose files, you can generally recover easily. "
"In addition, you get all this for very little overhead."
msgstr ""
"그래픽 디자이너나 웹 디자이너도 이미지나 레이아웃의 모든 버전(변경 이력 혹은 수정 내용)을 관리하기 위해 버전 관리 시스템 (VCS - "
"Version Control System)을 사용하는 것이 현명하다. VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, "
"프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, "
"누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든 "
"장점을 큰 노력 없이 이용할 수 있다."

#: en/01-introduction/01-chapter1.markdown:11
msgid "### Local Version Control Systems ###"
msgstr "### 로컬 버전 관리 시스템 ###"

#: en/01-introduction/01-chapter1.markdown:13
msgid ""
"Many people’s version-control method of choice is to copy files into another "
"directory (perhaps a time-stamped directory, if they’re clever). This "
"approach is very common because it is so simple, but it is also incredibly "
"error prone. It is easy to forget which directory you’re in and accidentally "
"write to the wrong file or copy over files you don’t mean to."
msgstr ""
"많은 사람은 버전을 관리하기 위해 Directory로 파일을 복사하는 방법을 쓴다(똑똑한 사람이라면 Directory 이름으로 시간을 쓸 "
"거다). 이 방법은 간단하므로 자주 사용한다. 그렇지만, 정말 뭔가가 잘못되기 쉽다. 작업하는 Directory를 지워버리거나, 실수로 "
"파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다."

#: en/01-introduction/01-chapter1.markdown:15
msgid ""
"To deal with this issue, programmers long ago developed local VCSs that had "
"a simple database that kept all the changes to files under revision control "
"(see Figure 1-1)."
msgstr ""
"이런 이유로 프로그래머들은 오래전에 로컬 VCS를 만들었다. 그 VCS는 관리 중인 파일의 변경 정보를 저장하려고 아주 간단한 "
"데이터베이스를 사용했다. "

#: en/01-introduction/01-chapter1.markdown:17
#, fuzzy
msgid ""
"Insert 18333fig0101.png\n"
"Figure 1-1. Local version control diagram."
msgstr ""
"Insert 18333fig0101.png \n"
"그림 1-1. 로컬 버전 관리 다이어그램."

#: en/01-introduction/01-chapter1.markdown:20
msgid ""
"One of the more popular VCS tools was a system called rcs, which is still "
"distributed with many computers today. Even the popular Mac OS X operating "
"system includes the rcs command when you install the Developer Tools. This "
"tool basically works by keeping patch sets (that is, the differences between "
"files) from one change to another in a special format on disk; it can then "
"re-create what any file looked like at any point in time by adding up all "
"the patches."
msgstr ""
"많이 쓰는 VCS 도구 중에 rcs라고 부르는 것이 있는데 오늘날까지도 아직 많은 회사가 사용하고 있다. Mac OS X 운영체제에서도 "
"개발 도구를 설치하면 RCS가 함께 설치된다. RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch "
"Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다."

#: en/01-introduction/01-chapter1.markdown:22
msgid "### Centralized Version Control Systems ###"
msgstr "### 중앙집중식 버전 관리 시스템 (Centralized VCS) ###"

#: en/01-introduction/01-chapter1.markdown:24
msgid ""
"The next major issue that people encounter is that they need to collaborate "
"with developers on other systems. To deal with this problem, Centralized "
"Version Control Systems (CVCSs) were developed. These systems, such as CVS, "
"Subversion, and Perforce, have a single server that contains all the "
"versioned files, and a number of clients that check out files from that "
"central place. For many years, this has been the standard for version "
"control (see Figure 1-2)."
msgstr ""
"프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 "
"CVCS(Centralized Version Control System)가 개발됐다. CVS, Subversion, Perforce 같은 "
"시스템은 모든 파일을 관리하는 서버가 별도로 있고 많은 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 수년 동안 "
"이러한 시스템들이 많은 사랑을 받았다."

#: en/01-introduction/01-chapter1.markdown:26
#, fuzzy
msgid ""
"Insert 18333fig0102.png\n"
"Figure 1-2. Centralized version control diagram."
msgstr ""
"Insert 18333fig0102.png \n"
"그림 1-2. 중앙집중식 버전 관리 (CVCS) 다이어그램."

#: en/01-introduction/01-chapter1.markdown:29
msgid ""
"This setup offers many advantages, especially over local VCSs. For example, "
"everyone knows to a certain degree what everyone else on the project is "
"doing. Administrators have fine-grained control over who can do what; and "
"it’s far easier to administer a CVCS than it is to deal with local databases "
"on every client."
msgstr ""
"CVCS 환경은 로컬 VCS에 비해 장점이 많다. 프로젝트에 참여한 사람이면 누가 무엇을 하고 있는지 알 수 있다. 관리자는 누가 무엇을 "
"할 수 있는지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의 로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다."

#: en/01-introduction/01-chapter1.markdown:31
msgid ""
"However, this setup also has some serious downsides. The most obvious is the "
"single point of failure that the centralized server represents. If that "
"server goes down for an hour, then during that hour nobody can collaborate "
"at all or save versioned changes to anything they’re working on. If the hard "
"disk the central database is on becomes corrupted, and proper backups "
"haven’t been kept, you lose absolutely everything—the entire history of the "
"project except whatever single snapshots people happen to have on their "
"local machines. Local VCS systems suffer from this same problem—whenever you "
"have the entire history of the project in a single place, you risk losing "
"everything."
msgstr ""
"그러나 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 "
"다운되면 그동안 아무도 다른 사람과 협업할 수 없고 사람들이 하는 일을 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 "
"문제가 생기면 프로젝트의 모든 히스토리를 잃는다. 물론 사람마다 하나씩 가진 Snapshot은 괜찮다. 로컬 VCS 시스템도 이와 "
"비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다."

#: en/01-introduction/01-chapter1.markdown:33
msgid "### Distributed Version Control Systems ###"
msgstr "### 분산형 버전 관리 시스템(Distributed VCS) ###"

#: en/01-introduction/01-chapter1.markdown:35
msgid ""
"This is where Distributed Version Control Systems (DVCSs) step in. In a DVCS "
"(such as Git, Mercurial, Bazaar or Darcs), clients don’t just check out the "
"latest snapshot of the files: they fully mirror the repository. Thus if any "
"server dies, and these systems were collaborating via it, any of the client "
"repositories can be copied back up to the server to restore it. Every "
"checkout is really a full backup of all the data (see Figure 1-3)."
msgstr ""
"분산형 버전 관리 시스템(DVCS)을 설명할 차례다. Git, Mecurial, Bazaar, Darcs 같은 DVCS에서는 클라이언트가 "
"파일의 마지막 Snapshot을 Checkout 하지 않는다. 그냥 저장소를 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 "
"작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. 모든 Checkout은 모든 데이터를 가진 진정한 "
"백업이다."

#: en/01-introduction/01-chapter1.markdown:37
#, fuzzy
msgid ""
"Insert 18333fig0103.png\n"
"Figure 1-3. Distributed version control diagram."
msgstr ""
"Insert 18333fig0103.png\n"
"그림 1-3. 분산형 버전 관리 시스템(DVCS) 다이어그램."

#: en/01-introduction/01-chapter1.markdown:40
msgid ""
"Furthermore, many of these systems deal pretty well with having several "
"remote repositories they can work with, so you can collaborate with "
"different groups of people in different ways simultaneously within the same "
"project. This allows you to set up several types of workflows that aren’t "
"possible in centralized systems, such as hierarchical models."
msgstr ""
"게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재할 수 있다. 리모트 저장소가 많다고 해도 문제없다. 그래서 사람들은 동시에 "
"다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 몇 가지 워크플로우도 사용할 수 "
"있다."

#: en/01-introduction/01-chapter1.markdown:42
msgid "## A Short History of Git ##"
msgstr "## 짧게 보는 Git의 역사 ##"

#: en/01-introduction/01-chapter1.markdown:44
msgid ""
"As with many great things in life, Git began with a bit of creative "
"destruction and fiery controversy. The Linux kernel is an open source "
"software project of fairly large scope. For most of the lifetime of the "
"Linux kernel maintenance (1991–2002), changes to the software were passed "
"around as patches and archived files. In 2002, the Linux kernel project "
"began using a proprietary DVCS system called BitKeeper."
msgstr ""
"인생을 살다 보면 여러 가지 일들이 벌어지듯이 Git의 삶 또한 창조적인 파괴와 모순 속에서 시작되었다. 리눅스 커널은 굉장히 규모가 큰 "
"오픈소스 프로젝트다. 리눅스 커널의 일생에서 대부분 시절은 패치와 단순 파일(Archived file)로만 관리했다. 2002년에 "
"드디어 리눅스 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다."

#: en/01-introduction/01-chapter1.markdown:46
msgid ""
"In 2005, the relationship between the community that developed the Linux "
"kernel and the commercial company that developed BitKeeper broke down, and "
"the tool’s free-of-charge status was revoked. This prompted the Linux "
"development community (and in particular Linus Torvalds, the creator of "
"Linux) to develop their own tool based on some of the lessons they learned "
"while using BitKeeper. Some of the goals of the new system were as follows:"
msgstr ""
"2005년에 커뮤니티가 만드는 리눅스 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 "
"사용이 제고된 것이다. 이 사건은 리눅스 개발 커뮤니티(특히 리눅스 창시자 리누스 토발즈)가 자체 도구를 만드는 계기가 됐다. Git은 "
"BitKeeper를 사용하면서 배운 교훈을 기초로 다음과 같은 목표를 세웠다:"

#: en/01-introduction/01-chapter1.markdown:48
msgid ""
"*\tSpeed\n"
"*\tSimple design\n"
"*\tStrong support for non-linear development (thousands of parallel "
"branches)\n"
"*\tFully distributed\n"
"*\tAble to handle large projects like the Linux kernel efficiently (speed "
"and data size)"
msgstr ""
"* 빠른 속도\n"
"* 단순한 구조\n"
"* 비선형적인 개발(수천 개의 동시 다발적인 브랜치)\n"
"* 완벽한 분산\n"
"* 리눅스 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)"

#: en/01-introduction/01-chapter1.markdown:54
msgid ""
"Since its birth in 2005, Git has evolved and matured to be easy to use and "
"yet retain these initial qualities. It’s incredibly fast, it’s very "
"efficient with large projects, and it has an incredible branching system for "
"non-linear development (See Chapter 3)."
msgstr ""
"Git은 2005년 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있으면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 "
"빨라서 대형 프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이다 (3장 참고)."

#: en/01-introduction/01-chapter1.markdown:56
msgid "## Git Basics ##"
msgstr "## Git 기초 ##"

#: en/01-introduction/01-chapter1.markdown:58
msgid ""
"So, what is Git in a nutshell? This is an important section to absorb, "
"because if you understand what Git is and the fundamentals of how it works, "
"then using Git effectively will probably be much easier for you. As you "
"learn Git, try to clear your mind of the things you may know about other "
"VCSs, such as Subversion and Perforce; doing so will help you avoid subtle "
"confusion when using the tool. Git stores and thinks about information much "
"differently than these other systems, even though the user interface is "
"fairly similar; understanding those differences will help prevent you from "
"becoming confused while using it."
msgstr ""
"Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 "
"효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 지워버려야 "
"한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈릴 거다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 "
"방식이 다르다. 이런 차이점들을 이해하면 Git을 사용하는 것이 어렵지 않다."

#: en/01-introduction/01-chapter1.markdown:60
msgid "### Snapshots, Not Differences ###"
msgstr "### 차이점이 아니라 Snapshot ###"

#: en/01-introduction/01-chapter1.markdown:62
msgid ""
"The major difference between Git and any other VCS (Subversion and friends "
"included) is the way Git thinks about its data. Conceptually, most other "
"systems store information as a list of file-based changes. These systems "
"(CVS, Subversion, Perforce, Bazaar, and so on) think of the information they "
"keep as a set of files and the changes made to each file over time, as "
"illustrated in Figure 1-4."
msgstr ""
"Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 "
"대부분의 VCS 시스템이 관리하는 정보는 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 "
"파일의 집합으로 정보를 관리한다. 각 파일의 변화를 그림 1-4처럼 시간순으로 관리한다."

#: en/01-introduction/01-chapter1.markdown:64
#, fuzzy
msgid ""
"Insert 18333fig0104.png\n"
"Figure 1-4. Other systems tend to store data as changes to a base version of "
"each file."
msgstr ""
"Insert 18333fig0104.png \n"
"그림 1-4. 각 파일에 대한 변화(차이점)를 저장하는 시스템들."

#: en/01-introduction/01-chapter1.markdown:67
#, fuzzy
msgid ""
"Git doesn’t think of or store its data this way. Instead, Git thinks of its "
"data more like a set of snapshots of a mini filesystem. Every time you "
"commit, or save the state of your project in Git, it basically takes a "
"picture of what all your files look like at that moment and stores a "
"reference to that snapshot. To be efficient, if files have not changed, Git "
"doesn’t store the file again—just a link to the previous identical file it "
"has already stored. Git thinks about its data more like Figure 1-5."
msgstr ""
"Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git의 데이터는 파일 시스템의 Snapshot이라 할 수 있으며 "
"크기가 아주 작다. Git은 Commit 하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 "
"달라지지 않았으면 Git은 성능을 위해서 파일을 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 그림 "
"1-5처럼 동작한다."

#: en/01-introduction/01-chapter1.markdown:69
#, fuzzy
msgid ""
"Insert 18333fig0105.png\n"
"Figure 1-5. Git stores data as snapshots of the project over time."
msgstr ""
"Insert 18333fig0105.png \n"
"그림 1-5. Git은 시간순으로 프로젝트의 Snapshot을 저장한다."

#: en/01-introduction/01-chapter1.markdown:72
msgid ""
"This is an important distinction between Git and nearly all other VCSs. It "
"makes Git reconsider almost every aspect of version control that most other "
"systems copied from the previous generation. This makes Git more like a mini "
"filesystem with some incredibly powerful tools built on top of it, rather "
"than simply a VCS. We’ll explore some of the benefits you gain by thinking "
"of your data this way when we cover Git branching in Chapter 3."
msgstr ""
"이것이 Git이 다른 VCS와 구분되는 점이다. 이점 때문에 Git는 다른 시스템들이 과거로부터 답습해왔던 버전 컨트롤의 개념의 많은 "
"부분을 새로운 관점에서 바라본다. Git은 강력한 도구를 지원하는 작은 파일시스템이다. Git은 단순한 VCS가 아니다. 이제 3장에서 "
"설명할 Git 브랜치를 사용하면 얻게 되는 이득이 무엇인지 설명한다."

#: en/01-introduction/01-chapter1.markdown:74
msgid "### Nearly Every Operation Is Local ###"
msgstr "### 거의 모든 명령을 로컬에서 실행 ###"

#: en/01-introduction/01-chapter1.markdown:76
msgid ""
"Most operations in Git only need local files and resources to operate — "
"generally no information is needed from another computer on your network.  "
"If you’re used to a CVCS where most operations have that network latency "
"overhead, this aspect of Git will make you think that the gods of speed have "
"blessed Git with unworldly powers. Because you have the entire history of "
"the project right there on your local disk, most operations seem almost "
"instantaneous."
msgstr ""
"거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 "
"영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠듯한 속도는 오직 Git느님만이 구사할 "
"수 있는 초인적인 능력이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령을 순식간에 실행된다."

#: en/01-introduction/01-chapter1.markdown:78
msgid ""
"For example, to browse the history of the project, Git doesn’t need to go "
"out to the server to get the history and display it for you—it simply reads "
"it directly from your local database. This means you see the project history "
"almost instantly. If you want to see the changes introduced between the "
"current version of a file and the file a month ago, Git can look up the file "
"a month ago and do a local difference calculation, instead of having to "
"either ask a remote server to do it or pull an older version of the file "
"from the remote server to do it locally."
msgstr ""
"예를 들어 프로젝트의 히스토리를 조회하려 할 때 Git은 서버가 필요 없다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. "
"그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를 비교해보고 싶을 때도 Git은 그냥 한 "
"달 전의 파일과 지금의 파일을 로컬에서 찾는다. 파일을 비교하기 위해 리모트에 있는 서버에 접근하고 나서 예전 버전을 가져올 필요가 "
"없다."

#: en/01-introduction/01-chapter1.markdown:80
msgid ""
"This also means that there is very little you can’t do if you’re offline or "
"off VPN. If you get on an airplane or a train and want to do a little work, "
"you can commit happily until you get to a network connection to upload. If "
"you go home and can’t get your VPN client working properly, you can still "
"work. In many other systems, doing so is either impossible or painful. In "
"Perforce, for example, you can’t do much when you aren’t connected to the "
"server; and in Subversion and CVS, you can edit files, but you can’t commit "
"changes to your database (because your database is offline). This may not "
"seem like a huge deal, but you may be surprised what a big difference it can "
"make."
msgstr ""
"즉 오프라인 상태에서도 비교할 수 있다. 비행기나 기차 등에서 작업하고 네트워크에 접속하고 있지 않아도 Commit 할 수 있다. 다른 "
"VCS 시스템에서는 불가능한 일이다. Perforce는 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나 "
"CVS에서도 마찬가지다. 데이터베이스에 접근할 수 없어서 파일을 편집할 수는 있지만, Commit 할 수 없다. 매우 사소해 보이지만 "
"실제로 이 상황에 부닥쳐보면 느껴지는 차이가 매우 크다."

#: en/01-introduction/01-chapter1.markdown:82
msgid "### Git Has Integrity ###"
msgstr "### Git의 무결성 ###"

#: en/01-introduction/01-chapter1.markdown:84
msgid ""
"Everything in Git is check-summed before it is stored and is then referred "
"to by that checksum. This means it’s impossible to change the contents of "
"any file or directory without Git knowing about it. This functionality is "
"built into Git at the lowest levels and is integral to its philosophy. You "
"can’t lose information in transit or get file corruption without Git being "
"able to detect it."
msgstr ""
"Git은 모든 데이터를 저장하기 전에 체크섬(Checksum 또는 Hash)을 구하고 그 체크섬으로 데이터를 관리한다. 체크섬 없이 "
"어떠한 파일이나 Directory도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 "
"기본 철학이다. Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 데이터를 잃어버릴 수도 없다."

#: en/01-introduction/01-chapter1.markdown:86
msgid ""
"The mechanism that Git uses for this checksumming is called a SHA-1 hash. "
"This is a 40-character string composed of hexadecimal characters (0–9 and a–"
"f) and calculated based on the contents of a file or directory structure in "
"Git. A SHA-1 hash looks something like this:"
msgstr ""
"Git은 SHA-1 Hash를 사용하여 체크섬을 만든다. 만든 체크섬은 40자 길이의 16진수 문자열이다. 파일의 내용이나 "
"Directory 구조를 이용하여 체크섬을 구한다. SHA-1은 아래처럼 생겼다."

#: en/01-introduction/01-chapter1.markdown:88
msgid "\t24b9da6552252987aa493b52f8696cd6d3b00373"
msgstr "\t24b9da6552252987aa493b52f8696cd6d3b00373"

#: en/01-introduction/01-chapter1.markdown:90
msgid ""
"You will see these hash values all over the place in Git because it uses "
"them so much. In fact, Git stores everything not by file name but in the Git "
"database addressable by the hash value of its contents."
msgstr ""
"Git은 모든 것을 Hash로 식별하기 때문에 이런 값은 여기저기서 보일 것이다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 "
"파일의 Hash로 저장한다."

#: en/01-introduction/01-chapter1.markdown:92
msgid "### Git Generally Only Adds Data ###"
msgstr "### Git은 데이터를 추가할 뿐 ###"

#: en/01-introduction/01-chapter1.markdown:94
msgid ""
"When you do actions in Git, nearly all of them only add data to the Git "
"database. It is very difficult to get the system to do anything that is not "
"undoable or to make it erase data in any way. As in any VCS, you can lose or "
"mess up changes you haven’t committed yet; but after you commit a snapshot "
"into Git, it is very difficult to lose, especially if you regularly push "
"your database to another repository."
msgstr ""
"Git으로 무얼 하든 데이터가 추가된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS처럼 Git도 Commit 하지 않으면 "
"변경사항을 잃어버릴 수 있다. 하지만, 일단 Snapshot을 Commit하고 나면 데이터를 잃어버리기 어렵다."

#: en/01-introduction/01-chapter1.markdown:96
msgid ""
"This makes using Git a joy because we know we can experiment without the "
"danger of severely screwing things up. For a more in-depth look at how Git "
"stores its data and how you can recover data that seems lost, see Chapter 9."
msgstr ""
"Git을 사용하면 프로젝트가 심각하게 망가질 걱정 없이 매우 즐겁게 여러 가지 실험을 해 볼 수 있다. Git이 데이터를 어떻게 저장하고 "
"손실을 복구할 수 있는지 좀 더 알아보려면 9장 살펴본다."

#: en/01-introduction/01-chapter1.markdown:98
msgid "### The Three States ###"
msgstr "### 세 가지 상태 ###"

#: en/01-introduction/01-chapter1.markdown:100
msgid ""
"Now, pay attention. This is the main thing to remember about Git if you want "
"the rest of your learning process to go smoothly. Git has three main states "
"that your files can reside in: committed, modified, and staged. Committed "
"means that the data is safely stored in your local database. Modified means "
"that you have changed the file but have not committed it to your database "
"yet. Staged means that you have marked a modified file in its current "
"version to go into your next commit snapshot."
msgstr ""
"이 부분은 중요하기에 집중해서 읽어야 한다. Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을 Commited, "
"Modified, Staged 이렇게 세 가지 상태로 관리한다. Commited란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 "
"의미한다. Modified는 수정한 파일을 아직 로컬 데이터베이스에 Commit 하지 않은 것을 말한다. Staged란 현재 수정한 "
"파일을 곧 Commit 할 것이라고 표시한 상태를 의미한다."

#: en/01-introduction/01-chapter1.markdown:102
msgid ""
"This leads us to the three main sections of a Git project: the Git "
"directory, the working directory, and the staging area."
msgstr ""
"이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git Directory, Working Directory, "
"Staging Area 이 세 가지 단계를 이해하고 넘어가자."

#: en/01-introduction/01-chapter1.markdown:104
#, fuzzy
msgid ""
"Insert 18333fig0106.png\n"
"Figure 1-6. Working directory, staging area, and git directory."
msgstr ""
"Insert 18333fig0106.png \n"
"그림 1-5. Working Directory, Staging Area, Git Directory"

#: en/01-introduction/01-chapter1.markdown:107
msgid ""
"The Git directory is where Git stores the metadata and object database for "
"your project. This is the most important part of Git, and it is what is "
"copied when you clone a repository from another computer."
msgstr ""
"Git Directory는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. Git Directory가 Git의 "
"핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git Directory가 만들어진다."

#: en/01-introduction/01-chapter1.markdown:109
msgid ""
"The working directory is a single checkout of one version of the project. "
"These files are pulled out of the compressed database in the Git directory "
"and placed on disk for you to use or modify."
msgstr ""
"Working Directory는 프로젝트의 특정 버전을 Checkout 한 것이다. Git Directory는 지금 작업하는 디스크에 "
"있고 그 Directory에 압축된 데이터베이스에서 파일을 가져와서 Working Directory를 만든다."

#: en/01-introduction/01-chapter1.markdown:111
msgid ""
"The staging area is a simple file, generally contained in your Git "
"directory, that stores information about what will go into your next commit. "
"It’s sometimes referred to as the index, but it’s becoming standard to refer "
"to it as the staging area."
msgstr ""
"Staging Area는 Git Directory에 있다. 단순한 파일이고 곧 Commit 할 파일에 대한 정보를 저장한다. 종종 "
"인덱스라고 불리기도 하지만, Staging Area라는 명칭이 표준이 되어가고 있다."

#: en/01-introduction/01-chapter1.markdown:113
msgid "The basic Git workflow goes something like this:"
msgstr "Git으로 하는 일은 기본적으로 다음과 같다:"

#: en/01-introduction/01-chapter1.markdown:115
msgid ""
"1. You modify files in your working directory.\n"
"2. You stage the files, adding snapshots of them to your staging area.\n"
"3. You do a commit, which takes the files as they are in the staging area "
"and stores that snapshot permanently to your Git directory."
msgstr ""
"- Working Directory에서 파일을 수정한다.\n"
"- Staging Area에 파일을 Stage 해서 Commit 할 Snapshot을 만든다.\n"
"- Staging Area에 있는 파일들을 Commit 해서 Git Directory에 영구적인 Snapshot으로 저장한다."

#: en/01-introduction/01-chapter1.markdown:119
msgid ""
"If a particular version of a file is in the git directory, it’s considered "
"committed. If it’s modified but has been added to the staging area, it is "
"staged. And if it was changed since it was checked out but has not been "
"staged, it is modified. In Chapter 2, you’ll learn more about these states "
"and how you can either take advantage of them or skip the staged part "
"entirely."
msgstr ""
"Git directory에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 "
"Staged이다. 그리고 Checkout하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다. "
"2장에서 이 상태에 대해 좀 더 자세히 배운다. 특히 Staging Area를 어떻게 이용하는지 혹은 아예 생략하는 방법도 설명한다."

#: en/01-introduction/01-chapter1.markdown:121
msgid "## Installing Git ##"
msgstr "## Git 설치 ##"

#: en/01-introduction/01-chapter1.markdown:123
msgid ""
"Let’s get into using some Git. First things first—you have to install it. "
"You can get it a number of ways; the two major ones are to install it from "
"source or to install an existing package for your platform."
msgstr ""
"Git을 사용해 보려면 우선 설치해야 한다. 다양한 방법으로 Git을 설치할 수 있지만 가장 일반적인 방법은 두 가지가 있다. 하나는 "
"소스코드로 컴파일하여 설치하는 방법이고 다른 하나는 각 운영체제(혹은 Platform)의 패키지를 사용하여 설치하는 방법이다."

#: en/01-introduction/01-chapter1.markdown:125
msgid "### Installing from Source ###"
msgstr "### 소스코드로 설치하기 ###"

#: en/01-introduction/01-chapter1.markdown:127
msgid ""
"If you can, it’s generally useful to install Git from source, because you’ll "
"get the most recent version. Each version of Git tends to include useful UI "
"enhancements, so getting the latest version is often the best route if you "
"feel comfortable compiling software from source. It is also the case that "
"many Linux distributions contain very old packages; so unless you’re on a "
"very up-to-date distro or are using backports, installing from source may be "
"the best bet."
msgstr ""
"소스코드로 설치하면 Git의 가장 최신 버전을 설치할 수 있기 때문에 컴파일하여 설치할 시간이 있으면 소스코드로 Git을 설치하는 것이 "
"좋다. Git은 계속 UI를 개선하고 있기 때문에 최신 버전을 사용하면 좋은 기능을 빨리 사용할 수 있다. 리눅스 패키지는 보통 최신 "
"버전이 아니고 예전 버전이다. 그래서 Backport를 사용하거나 소스코드로 설치하는 것도 좋은 대안이다."

#: en/01-introduction/01-chapter1.markdown:129
msgid ""
"To install Git, you need to have the following libraries that Git depends "
"on: curl, zlib, openssl, expat, and libiconv. For example, if you’re on a "
"system that has yum (such as Fedora) or apt-get (such as a Debian based "
"system), you can use one of these commands to install all of the "
"dependencies:"
msgstr ""
"Git을 설치하려면 다음과 같은 라이브러리들이 필요하다. Git은 curl, zlib, openssl, expat, libiconv를 "
"필요로 한다. 예를 들어 Fedora처럼 yum을 가지는 시스템을 사용하고 있거나 apt-get이 있는 데비안류 시스템을 사용하면 다음의 "
"명령어를 실행하여 의존 패키지를 설치할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:131
msgid ""
"\t$ yum install curl-devel expat-devel gettext-devel \\\n"
"\t  openssl-devel zlib-devel"
msgstr ""
"\t$ yum install curl-devel expat-devel gettext-devel \\\n"
"\t  openssl-devel zlib-devel"

#: en/01-introduction/01-chapter1.markdown:134
msgid ""
"\t$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n"
"\t  libz-dev libssl-dev"
msgstr ""
"\t$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n"
"\t  libz-dev libssl-dev"

#: en/01-introduction/01-chapter1.markdown:137
msgid ""
"When you have all the necessary dependencies, you can go ahead and grab the "
"latest snapshot from the Git web site:"
msgstr "필요한 라이브러리를 모두 설치하고 다음 단계를 진행한다. Git 웹 사이트에서 최신 Snapshot을 가져온다:"

#: en/01-introduction/01-chapter1.markdown:139
msgid "\thttp://git-scm.com/download"
msgstr "\thttp://git-scm.com/download"

#: en/01-introduction/01-chapter1.markdown:141
msgid "Then, compile and install:"
msgstr "그리고 컴파일하고 설치한다:"

#: en/01-introduction/01-chapter1.markdown:143
msgid ""
"\t$ tar -zxf git-1.7.2.2.tar.gz\n"
"\t$ cd git-1.7.2.2\n"
"\t$ make prefix=/usr/local all\n"
"\t$ sudo make prefix=/usr/local install"
msgstr ""
"\t$ tar -zxf git-1.7.2.2.tar.gz\n"
"\t$ cd git-1.7.2.2\n"
"\t$ make prefix=/usr/local all\n"
"\t$ sudo make prefix=/usr/local install"

#: en/01-introduction/01-chapter1.markdown:148
msgid "After this is done, you can also get Git via Git itself for updates:"
msgstr "설치한 다음부터는 Git을 사용하여 Git 소스코드를 갱신할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:150
msgid "\t$ git clone git://git.kernel.org/pub/scm/git/git.git"
msgstr "\t$ git clone git://git.kernel.org/pub/scm/git/git.git"

#: en/01-introduction/01-chapter1.markdown:152
msgid "### Installing on Linux ###"
msgstr "### 리눅스에 설치 ###"

#: en/01-introduction/01-chapter1.markdown:154
msgid ""
"If you want to install Git on Linux via a binary installer, you can "
"generally do so through the basic package-management tool that comes with "
"your distribution. If you’re on Fedora, you can use yum:"
msgstr ""
"리눅스에서 패키지로 Git을 설치할 때에는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora에서는 다음과 "
"같이 한다:"

#: en/01-introduction/01-chapter1.markdown:156
msgid "\t$ yum install git-core"
msgstr "\t$ yum install git-core"

#: en/01-introduction/01-chapter1.markdown:158
msgid "Or if you’re on a Debian-based distribution like Ubuntu, try apt-get:"
msgstr "Ubuntu같은 데비안류 배포판에서는 apt-get을 사용한다:"

#: en/01-introduction/01-chapter1.markdown:160
msgid "\t$ apt-get install git-core"
msgstr "\t$ apt-get install git-core"

#: en/01-introduction/01-chapter1.markdown:162
msgid "### Installing on Mac ###"
msgstr "### Mac에 설치하기 ###"

#: en/01-introduction/01-chapter1.markdown:164
msgid ""
"There are two easy ways to install Git on a Mac. The easiest is to use the "
"graphical Git installer, which you can download from the Google Code page "
"(see Figure 1-7):"
msgstr ""
"Mac에 Git을 쉽게 설치하는 방법은 두 가지가 있다. GUI 인스톨러를 사용하기가 가장 쉽다. Google Code 페이지에서 "
"내려받는다:"

#: en/01-introduction/01-chapter1.markdown:166
msgid "\thttp://code.google.com/p/git-osx-installer"
msgstr "\thttp://code.google.com/p/git-osx-installer"

#: en/01-introduction/01-chapter1.markdown:168
#, fuzzy
msgid ""
"Insert 18333fig0107.png\n"
"Figure 1-7. Git OS X installer."
msgstr ""
"Insert 18333fig0107.png \n"
"그림 1-7. OS X Git 인스톨러."

#: en/01-introduction/01-chapter1.markdown:171
msgid ""
"The other major way is to install Git via MacPorts (`http://www.macports."
"org`). If you have MacPorts installed, install Git via"
msgstr ""
"MacPorts(`http://www.macports.org`)를 사용하는 방법도 있다. MacPorts가 설치돼 있으면 다음과 같이 "
"Git을 설치한다:"

#: en/01-introduction/01-chapter1.markdown:173
msgid "\t$ sudo port install git-core +svn +doc +bash_completion +gitweb"
msgstr "\t$ sudo port install git-core +svn +doc +bash_completion +gitweb"

#: en/01-introduction/01-chapter1.markdown:175
msgid ""
"You don’t have to add all the extras, but you’ll probably want to include "
"+svn in case you ever have to use Git with Subversion repositories (see "
"Chapter 8)."
msgstr "이제 설치는 했다. 만약 Subversion 저장소를 Git과 함께 사용해야 하면 svn도 필요하다."

#: en/01-introduction/01-chapter1.markdown:177
msgid "### Installing on Windows ###"
msgstr "### 윈도우에 설치 ###"

#: en/01-introduction/01-chapter1.markdown:179
msgid ""
"Installing Git on Windows is very easy. The msysGit project has one of the "
"easier installation procedures. Simply download the installer exe file from "
"the Google Code page, and run it:"
msgstr "Git을 윈도우에 설치하기도 쉽다. 그저 구글 코드 페이지에서 msysGit 인스톨러를 내려받고 실행하면 된다:"

#: en/01-introduction/01-chapter1.markdown:181
msgid "\thttp://code.google.com/p/msysgit"
msgstr "\thttp://code.google.com/p/msysgit"

#: en/01-introduction/01-chapter1.markdown:183
msgid ""
"After it’s installed, you have both a command-line version (including an SSH "
"client that will come in handy later) and the standard GUI."
msgstr ""
"설치가 완료되면 CLI 프로그램과 GUI 프로그램을 둘 다 사용할 수 있다. CLI 프로그램에는 SSH 클라이언트가 포함돼 있기 때문에 "
"유용하다."

#: en/01-introduction/01-chapter1.markdown:185
msgid ""
"Note on Windows usage: you should use Git with the provided msysGit shell "
"(Unix style), it allows to use the complex lines of command given in this "
"book. If you need, for some reason, to use the native Windows shell / "
"command line console, you have to use double quotes instead of simple quotes "
"(for parameters with spaces in them) and you must quote the parameters "
"ending with the circumflex accent (^) if they are last on the line, as it is "
"a continuation symbol in Windows."
msgstr ""

#: en/01-introduction/01-chapter1.markdown:187
msgid "## First-Time Git Setup ##"
msgstr "## Git 최초 설정 ##"

#: en/01-introduction/01-chapter1.markdown:189
msgid ""
"Now that you have Git on your system, you’ll want to do a few things to "
"customize your Git environment. You should have to do these things only "
"once; they’ll stick around between upgrades. You can also change them at any "
"time by running through the commands again."
msgstr ""
"Git을 설치하고 나면 Git의 사용 환경을 적절히 설정해 주어야 한다. 한 번만 설정하면 된다. 설정한 내용은 Git을 업그레이드해도 "
"유지된다. 또한, 명령어로 언제든지 다시 바꿀 수 있다."

#: en/01-introduction/01-chapter1.markdown:191
msgid ""
"Git comes with a tool called git config that lets you get and set "
"configuration variables that control all aspects of how Git looks and "
"operates. These variables can be stored in three different places:"
msgstr ""
"Git은 'git config'라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이 설정 파일은 세 "
"가지나 된다."

#: en/01-introduction/01-chapter1.markdown:193
#, fuzzy
msgid ""
"*\t`/etc/gitconfig` file: Contains values for every user on the system and "
"all their repositories. If you pass the option` --system` to `git config`, "
"it reads and writes from this file specifically.\n"
"*\t`~/.gitconfig` file: Specific to your user. You can make Git read and "
"write to this file specifically by passing the `--global` option.\n"
"*\tconfig file in the git directory (that is, `.git/config`) of whatever "
"repository you’re currently using: Specific to that single repository. Each "
"level overrides values in the previous level, so values in `.git/config` "
"trump those in `/etc/gitconfig`."
msgstr ""
"* `/etc/gitconfig` 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. `git config --system` "
"옵션으로 이 파일을 읽고 쓸 수 있다.\n"
"* `~/.gitconfig` 파일: 특정 사용자에게만 적용되는 설정이다. `git config --global` 옵션으로 이 파일을 "
"읽고 쓸 수 있다.\n"
"* `.git/config`: 이 파일은 Git Directory에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. 각 "
"설정은 역순으로 우선시 된다. 그래서 `.git/config`가 `/etc/gitconfig`보다 우선한다."

#: en/01-introduction/01-chapter1.markdown:197
msgid ""
"On Windows systems, Git looks for the `.gitconfig` file in the `$HOME` "
"directory (`%USERPROFILE%` in Windows’ environment), which is `C:\\Documents "
"and Settings\\$USER` or `C:\\Users\\$USER` for most people, depending on "
"version (`$USER` is `%USERNAME%` in Windows’ environment). It also still "
"looks for /etc/gitconfig, although it’s relative to the MSys root, which is "
"wherever you decide to install Git on your Windows system when you run the "
"installer."
msgstr ""

#: en/01-introduction/01-chapter1.markdown:199
msgid "### Your Identity ###"
msgstr "### 사용자 정보 ###"

#: en/01-introduction/01-chapter1.markdown:201
msgid ""
"The first thing you should do when you install Git is to set your user name "
"and e-mail address. This is important because every Git commit uses this "
"information, and it’s immutably baked into the commits you pass around:"
msgstr ""
"Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자 이름과 이메일 주소를 설정하는 것이다. Git은 Commit 할 때마다 이 "
"정보를 사용한다. 한 번 Commit 한 후에는 정보를 변경할 수 없다."

#: en/01-introduction/01-chapter1.markdown:203
#: en/07-customizing-git/01-chapter7.markdown:9
msgid ""
"\t$ git config --global user.name \"John Doe\"\n"
"\t$ git config --global user.email johndoe@example.com"
msgstr ""
"\t$ git config --global user.name \"John Doe\"\n"
"\t$ git config --global user.email johndoe@example.com"

#: en/01-introduction/01-chapter1.markdown:206
msgid ""
"Again, you need to do this only once if you pass the `--global` option, "
"because then Git will always use that information for anything you do on "
"that system. If you want to override this with a different name or e-mail "
"address for specific projects, you can run the command without the `--"
"global` option when you’re in that project."
msgstr ""
"다시 말하자면 `--global` 옵션으로 설정한 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때에는 이 정보를 "
"사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 `--global` 옵션을 빼고 명령을 실행한다."

#: en/01-introduction/01-chapter1.markdown:208
msgid "### Your Editor ###"
msgstr "### 편집기 ###"

#: en/01-introduction/01-chapter1.markdown:210
msgid ""
"Now that your identity is set up, you can configure the default text editor "
"that will be used when Git needs you to type in a message. By default, Git "
"uses your system’s default editor, which is generally Vi or Vim. If you want "
"to use a different text editor, such as Emacs, you can do the following:"
msgstr ""
"사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용하고 보통 이것은 "
"Vi나 Vim이다. 하지만, Emacs 같은 다른 텍스트 편집기를 사용하고 싶다면 다음과 같이 실행한다.:"

#: en/01-introduction/01-chapter1.markdown:212
#: en/07-customizing-git/01-chapter7.markdown:32
msgid "\t$ git config --global core.editor emacs"
msgstr "\t$ git config --global core.editor emacs"

#: en/01-introduction/01-chapter1.markdown:214
msgid "### Your Diff Tool ###"
msgstr "### Diff 도구 ###"

#: en/01-introduction/01-chapter1.markdown:216
msgid ""
"Another useful option you may want to configure is the default diff tool to "
"use to resolve merge conflicts. Say you want to use vimdiff:"
msgstr ""
"Merge 충돌을 해결하기 위해 사용하는 Diff 도구를 설정할 수 있다. vimdiff를 사용하고 싶으면 다음과 같이 실행한다:"

#: en/01-introduction/01-chapter1.markdown:218
msgid "\t$ git config --global merge.tool vimdiff"
msgstr "\t$ git config --global merge.tool vimdiff"

#: en/01-introduction/01-chapter1.markdown:220
msgid ""
"Git accepts kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, "
"ecmerge, and opendiff as valid merge tools. You can also set up a custom "
"tool; see Chapter 7 for more information about doing that."
msgstr ""
"이렇게 kdiff3, tkdiff, meld, xxdif, emerge, vimdiff, gvimdiff, ecmerge, "
"opendiff를 사용할 수 있다. 물론 다른 도구도 사용할 수 있다. 자세한 내용은 7장에서 다룬다."

#: en/01-introduction/01-chapter1.markdown:222
msgid "### Checking Your Settings ###"
msgstr "### 설정 확인 ###"

#: en/01-introduction/01-chapter1.markdown:224
msgid ""
"If you want to check your settings, you can use the `git config --list` "
"command to list all the settings Git can find at that point:"
msgstr "`git config --list` 명령을 실행하면 모든 설정 내용을 확인할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:226
msgid ""
"\t$ git config --list\n"
"\tuser.name=Scott Chacon\n"
"\tuser.email=schacon@gmail.com\n"
"\tcolor.status=auto\n"
"\tcolor.branch=auto\n"
"\tcolor.interactive=auto\n"
"\tcolor.diff=auto\n"
"\t..."
msgstr ""
"\t$ git config --list\n"
"\tuser.name=Scott Chacon\n"
"\tuser.email=schacon@gmail.com\n"
"\tcolor.status=auto\n"
"\tcolor.branch=auto\n"
"\tcolor.interactive=auto\n"
"\tcolor.diff=auto\n"
"\t..."

#: en/01-introduction/01-chapter1.markdown:235
msgid ""
"You may see keys more than once, because Git reads the same key from "
"different files (`/etc/gitconfig` and `~/.gitconfig`, for example). In this "
"case, Git uses the last value for each unique key it sees."
msgstr ""
"Git은 같은 키를 여러 파일(`/etc/gitconfig`와 `~/.gitconfig`같은)에서 읽기 때문에 같은 키가 하나 이상 나올 "
"수도 있다. 이 경우에 Git은 나중 값을 사용한다."

#: en/01-introduction/01-chapter1.markdown:237
msgid ""
"You can also check what Git thinks a specific key’s value is by typing `git "
"config {key}`:"
msgstr "`git config {key}` 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다:"

#: en/01-introduction/01-chapter1.markdown:239
msgid ""
"\t$ git config user.name\n"
"\tScott Chacon"
msgstr ""
"\t$ git config user.name\n"
"\tScott Chacon"

#: en/01-introduction/01-chapter1.markdown:242
msgid "## Getting Help ##"
msgstr "## 도움말 보기 ##"

#: en/01-introduction/01-chapter1.markdown:244
msgid ""
"If you ever need help while using Git, there are three ways to get the "
"manual page (manpage) help for any of the Git commands:"
msgstr "명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 세 가지이다:"

#: en/01-introduction/01-chapter1.markdown:246
msgid ""
"\t$ git help <verb>\n"
"\t$ git <verb> --help\n"
"\t$ man git-<verb>"
msgstr ""
"\t$ git help <verb>\n"
"\t$ git <verb> --help\n"
"\t$ man git-<verb>"

#: en/01-introduction/01-chapter1.markdown:250
msgid ""
"For example, you can get the manpage help for the config command by running"
msgstr "예를 들어 다음과 같이 실행하면 config 명령에 대한 도움말을 볼 수 있다:"

#: en/01-introduction/01-chapter1.markdown:252
msgid "\t$ git help config"
msgstr "\t$ git help config"

#: en/01-introduction/01-chapter1.markdown:254
msgid ""
"These commands are nice because you can access them anywhere, even offline.\n"
"If the manpages and this book aren’t enough and you need in-person help, you "
"can try the `#git` or `#github` channel on the Freenode IRC server (irc."
"freenode.net). These channels are regularly filled with hundreds of people "
"who are all very knowledgeable about Git and are often willing to help."
msgstr ""
"도움말은 언제 어디서나 볼 수 있다. 오프라인 상태에서도 가능하다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. "
"Freenode IRC 서버(irc.freenode.net)에 있는 `#git`이나 `#github` 채널로 찾아가라. 이 채널은 보통 "
"수백 명의 사람이 접속해 있다. 이 사람들은 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다."

#: en/01-introduction/01-chapter1.markdown:257
#: en/02-git-basics/01-chapter2.markdown:1120
#: en/03-git-branching/01-chapter3.markdown:596
#: en/04-git-server/01-chapter4.markdown:856
#: en/05-distributed-git/01-chapter5.markdown:895
#: en/06-git-tools/01-chapter6.markdown:1124
#: en/07-customizing-git/01-chapter7.markdown:935
#: en/08-git-and-other-scms/01-chapter8.markdown:687
#: en/09-git-internals/01-chapter9.markdown:973
msgid "## Summary ##"
msgstr "## 요약 ##"

#: en/01-introduction/01-chapter1.markdown:259
msgid ""
"You should have a basic understanding of what Git is and how it’s different "
"from the CVCS you may have been using. You should also now have a working "
"version of Git on your system that’s set up with your personal identity. "
"It’s now time to learn some Git basics."
msgstr ""
"우리는 Git이 무엇이고 지금까지 사용해 왔던 다른 CVCS와 어떻게 다른지 배웠다. 시스템에 Git을 설치하고 사용자 정보도 설정했다. "
"다음 장에서는 Git의 사용법을 배운다."

#: en/02-git-basics/01-chapter2.markdown:1
#, fuzzy
msgid "# Git Basics #"
msgstr "## Git 기초 ##"

#: en/02-git-basics/01-chapter2.markdown:3
msgid ""
"If you can read only one chapter to get going with Git, this is it. This "
"chapter covers every basic command you need to do the vast majority of the "
"things you’ll eventually spend your time doing with Git. By the end of the "
"chapter, you should be able to configure and initialize a repository, begin "
"and stop tracking files, and stage and commit changes. We’ll also show you "
"how to set up Git to ignore certain files and file patterns, how to undo "
"mistakes quickly and easily, how to browse the history of your project and "
"view changes between commits, and how to push and pull from remote "
"repositories."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:5
msgid "## Getting a Git Repository ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:7
msgid ""
"You can get a Git project using two main approaches. The first takes an "
"existing project or directory and imports it into Git. The second clones an "
"existing Git repository from another server."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:9
msgid "### Initializing a Repository in an Existing Directory ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:11
msgid ""
"If you’re starting to track an existing project in Git, you need to go to "
"the project’s directory and type"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:13
msgid "\t$ git init"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:15
msgid ""
"This creates a new subdirectory named `.git` that contains all of your "
"necessary repository files — a Git repository skeleton. At this point, "
"nothing in your project is tracked yet. (See *Chapter 9* for more "
"information about exactly what files are contained in the `.git` directory "
"you just created.)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:17
msgid ""
"If you want to start version-controlling existing files (as opposed to an "
"empty directory), you should probably begin tracking those files and do an "
"initial commit. You can accomplish that with a few `git add` commands that "
"specify the files you want to track, followed by a commit:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:19
msgid ""
"\t$ git add *.c\n"
"\t$ git add README\n"
"\t$ git commit -m 'initial project version'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:23
msgid ""
"We’ll go over what these commands do in just a minute. At this point, you "
"have a Git repository with tracked files and an initial commit."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:25
msgid "### Cloning an Existing Repository ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:27
msgid ""
"If you want to get a copy of an existing Git repository — for example, a "
"project you’d like to contribute to — the command you need is `git clone`. "
"If you’re familiar with other VCS systems such as Subversion, you’ll notice "
"that the command is `clone` and not `checkout`. This is an important "
"distinction — Git receives a copy of nearly all data that the server has. "
"Every version of every file for the history of the project is pulled down "
"when you run `git clone`. In fact, if your server disk gets corrupted, you "
"can use any of the clones on any client to set the server back to the state "
"it was in when it was cloned (you may lose some server-side hooks and such, "
"but all the versioned data would be there — see *Chapter 4* for more "
"details)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:29
msgid ""
"You clone a repository with `git clone [url]`. For example, if you want to "
"clone the Ruby Git library called Grit, you can do so like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:31
msgid "\t$ git clone git://github.com/schacon/grit.git"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:33
msgid ""
"That creates a directory named `grit`, initializes a `.git` directory inside "
"it, pulls down all the data for that repository, and checks out a working "
"copy of the latest version. If you go into the new `grit` directory, you’ll "
"see the project files in there, ready to be worked on or used. If you want "
"to clone the repository into a directory named something other than grit, "
"you can specify that as the next command-line option:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:35
msgid "\t$ git clone git://github.com/schacon/grit.git mygrit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:37
msgid ""
"That command does the same thing as the previous one, but the target "
"directory is called `mygrit`."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:39
msgid ""
"Git has a number of different transfer protocols you can use. The previous "
"example uses the `git://` protocol, but you may also see `http(s)://` or "
"`user@server:/path.git`, which uses the SSH transfer protocol. *Chapter 4* "
"will introduce all of the available options the server can set up to access "
"your Git repository and the pros and cons of each."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:41
msgid "## Recording Changes to the Repository ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:43
msgid ""
"You have a bona fide Git repository and a checkout or working copy of the "
"files for that project. You need to make some changes and commit snapshots "
"of those changes into your repository each time the project reaches a state "
"you want to record."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:45
msgid ""
"Remember that each file in your working directory can be in one of two "
"states: *tracked* or *untracked*. *Tracked* files are files that were in the "
"last snapshot; they can be *unmodified*, *modified*, or *staged*. "
"*Untracked* files are everything else — any files in your working directory "
"that were not in your last snapshot and are not in your staging area.  When "
"you first clone a repository, all of your files will be tracked and "
"unmodified because you just checked them out and haven’t edited anything."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:47
msgid ""
"As you edit files, Git sees them as modified, because you’ve changed them "
"since your last commit. You *stage* these modified files and then commit all "
"your staged changes, and the cycle repeats. This lifecycle is illustrated in "
"Figure 2-1."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:49
msgid ""
"Insert 18333fig0201.png\n"
"Figure 2-1. The lifecycle of the status of your files."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:52
msgid "### Checking the Status of Your Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:54
msgid ""
"The main tool you use to determine which files are in which state is the "
"`git status` command. If you run this command directly after a clone, you "
"should see something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:56
#: en/06-git-tools/01-chapter6.markdown:441
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\tnothing to commit (working directory clean)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:60
msgid ""
"This means you have a clean working directory — in other words, no tracked "
"files are modified. Git also doesn’t see any untracked files, or they would "
"be listed here. Finally, the command tells you which branch you’re on. For "
"now, that is always `master`, which is the default; you won’t worry about it "
"here. The next chapter will go over branches and references in detail."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:62
msgid ""
"Let’s say you add a new file to your project, a simple `README` file. If the "
"file didn’t exist before, and you run `git status`, you see your untracked "
"file like so:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:64
msgid ""
"\t$ vim README\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Untracked files:\n"
"\t#   (use \"git add <file>...\" to include in what will be committed)\n"
"\t#\n"
"\t#\tREADME\n"
"\tnothing added to commit but untracked files present (use \"git add\" to "
"track)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:73
msgid ""
"You can see that your new `README` file is untracked, because it’s under the "
"“Untracked files” heading in your status output. Untracked basically means "
"that Git sees a file you didn’t have in the previous snapshot (commit); Git "
"won’t start including it in your commit snapshots until you explicitly tell "
"it to do so. It does this so you don’t accidentally begin including "
"generated binary files or other files that you did not mean to include. You "
"do want to start including README, so let’s start tracking the file."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:75
msgid "### Tracking New Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:77
msgid ""
"In order to begin tracking a new file, you use the command `git add`. To "
"begin tracking the `README` file, you can run this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:79
msgid "\t$ git add README"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:81
msgid ""
"If you run your status command again, you can see that your `README` file is "
"now tracked and staged:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:83
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:91
msgid ""
"You can tell that it’s staged because it’s under the “Changes to be "
"committed” heading. If you commit at this point, the version of the file at "
"the time you ran `git add` is what will be in the historical snapshot. You "
"may recall that when you ran `git init` earlier, you then ran `git add "
"(files)` — that was to begin tracking files in your directory. The `git add` "
"command takes a path name for either a file or a directory; if it’s a "
"directory, the command adds all the files in that directory recursively."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:93
msgid "### Staging Modified Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:95
msgid ""
"Let’s change a file that was already tracked. If you change a previously "
"tracked file called `benchmarks.rb` and then run your `status` command "
"again, you get something that looks like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:97
msgctxt "en/02-git-basics/01-chapter2.markdown:97"
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:110
msgid ""
"The `benchmarks.rb` file appears under a section named “Changes not staged "
"for commit” — which means that a file that is tracked has been modified in "
"the working directory but not yet staged. To stage it, you run the `git add` "
"command (it’s a multipurpose command — you use it to begin tracking new "
"files, to stage files, and to do other things like marking merge-conflicted "
"files as resolved). Let’s run `git add` now to stage the `benchmarks.rb` "
"file, and then run `git status` again:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:112
msgctxt "en/02-git-basics/01-chapter2.markdown:112"
msgid ""
"\t$ git add benchmarks.rb\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:122
msgid ""
"Both files are staged and will go into your next commit. At this point, "
"suppose you remember one little change that you want to make in `benchmarks."
"rb` before you commit it. You open it again and make that change, and you’re "
"ready to commit. However, let’s run `git status` one more time:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:124
msgid ""
"\t$ vim benchmarks.rb\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:139
msgid ""
"What the heck? Now `benchmarks.rb` is listed as both staged and unstaged. "
"How is that possible? It turns out that Git stages a file exactly as it is "
"when you run the `git add` command. If you commit now, the version of "
"`benchmarks.rb` as it was when you last ran the `git add` command is how it "
"will go into the commit, not the version of the file as it looks in your "
"working directory when you run `git commit`. If you modify a file after you "
"run `git add`, you have to run `git add` again to stage the latest version "
"of the file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:141
msgctxt "en/02-git-basics/01-chapter2.markdown:141"
msgid ""
"\t$ git add benchmarks.rb\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:151
msgid "### Ignoring Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:153
msgid ""
"Often, you’ll have a class of files that you don’t want Git to automatically "
"add or even show you as being untracked. These are generally automatically "
"generated files such as log files or files produced by your build system. In "
"such cases, you can create a file listing patterns to match them named `."
"gitignore`.  Here is an example `.gitignore` file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:155
msgid ""
"\t$ cat .gitignore\n"
"\t*.[oa]\n"
"\t*~"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:159
msgid ""
"The first line tells Git to ignore any files ending in `.o` or `.a` — "
"*object* and *archive* files that may be the product of building your code. "
"The second line tells Git to ignore all files that end with a tilde (`~`), "
"which is used by many text editors such as Emacs to mark temporary files. "
"You may also include a `log`, `tmp`, or `pid` directory; automatically "
"generated documentation; and so on. Setting up a `.gitignore` file before "
"you get going is generally a good idea so you don’t accidentally commit "
"files that you really don’t want in your Git repository."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:161
msgid ""
"The rules for the patterns you can put in the `.gitignore` file are as "
"follows:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:163
msgid ""
"*\tBlank lines or lines starting with `#` are ignored.\n"
"*\tStandard glob patterns work.\n"
"*\tYou can end patterns with a forward slash (`/`) to specify a directory.\n"
"*\tYou can negate a pattern by starting it with an exclamation point (`!`)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:168
msgid ""
"Glob patterns are like simplified regular expressions that shells use. An "
"asterisk (`*`) matches zero or more characters; `[abc]` matches any "
"character inside the brackets (in this case `a`, `b`, or `c`); a question "
"mark (`?`) matches a single character; and brackets enclosing characters "
"separated by a hyphen(`[0-9]`) matches any character in the range (in this "
"case 0 through 9) ."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:170
msgid "Here is another example `.gitignore` file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:172
msgid ""
"\t# a comment - this is ignored\n"
"\t*.a       # no .a files\n"
"\t!lib.a    # but do track lib.a, even though you're ignoring .a files "
"above\n"
"\t/TODO     # only ignore the root TODO file, not subdir/TODO\n"
"\tbuild/    # ignore all files in the build/ directory\n"
"\tdoc/*.txt # ignore doc/notes.txt, but not doc/server/arch.txt"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:179
msgid "### Viewing Your Staged and Unstaged Changes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:181
msgid ""
"If the `git status` command is too vague for you — you want to know exactly "
"what you changed, not just which files were changed — you can use the `git "
"diff` command. We’ll cover `git diff` in more detail later; but you’ll "
"probably use it most often to answer these two questions: What have you "
"changed but not yet staged? And what have you staged that you are about to "
"commit? Although `git status` answers those questions very generally, `git "
"diff` shows you the exact lines added and removed — the patch, as it were."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:183
msgid ""
"Let’s say you edit and stage the `README` file again and then edit the "
"`benchmarks.rb` file without staging it. If you run your `status` command, "
"you once again see something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:185
msgctxt "en/02-git-basics/01-chapter2.markdown:185"
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tnew file:   README\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:198
msgid ""
"To see what you’ve changed but not yet staged, type `git diff` with no other "
"arguments:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:200
msgid ""
"\t$ git diff\n"
"\tdiff --git a/benchmarks.rb b/benchmarks.rb\n"
"\tindex 3cb747f..da65585 100644\n"
"\t--- a/benchmarks.rb\n"
"\t+++ b/benchmarks.rb\n"
"\t@@ -36,6 +36,10 @@ def main\n"
"\t           @commit.parents[0].parents[0].parents[0]\n"
"\t         end"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:209
msgid ""
"\t+        run_code(x, 'commits 1') do\n"
"\t+          git.commits.size\n"
"\t+        end\n"
"\t+\n"
"\t         run_code(x, 'commits 2') do\n"
"\t           log = git.commits('master', 15)\n"
"\t           log.size"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:217
msgid ""
"That command compares what is in your working directory with what is in your "
"staging area. The result tells you the changes you’ve made that you haven’t "
"yet staged."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:219
msgid ""
"If you want to see what you’ve staged that will go into your next commit, "
"you can use `git diff --cached`. (In Git versions 1.6.1 and later, you can "
"also use `git diff --staged`, which may be easier to remember.) This command "
"compares your staged changes to your last commit:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:221
msgid ""
"\t$ git diff --cached\n"
"\tdiff --git a/README b/README\n"
"\tnew file mode 100644\n"
"\tindex 0000000..03902a1\n"
"\t--- /dev/null\n"
"\t+++ b/README2\n"
"\t@@ -0,0 +1,5 @@\n"
"\t+grit\n"
"\t+ by Tom Preston-Werner, Chris Wanstrath\n"
"\t+ http://github.com/mojombo/grit\n"
"\t+\n"
"\t+Grit is a Ruby library for extracting information from a Git repository"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:234
msgid ""
"It’s important to note that `git diff` by itself doesn’t show all changes "
"made since your last commit — only changes that are still unstaged. This can "
"be confusing, because if you’ve staged all of your changes, `git diff` will "
"give you no output."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:236
msgid ""
"For another example, if you stage the `benchmarks.rb` file and then edit it, "
"you can use `git diff` to see the changes in the file that are staged and "
"the changes that are unstaged:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:238
msgid ""
"\t$ git add benchmarks.rb\n"
"\t$ echo '# test line' >> benchmarks.rb\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t#\n"
"\t# Changes to be committed:\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:252
msgid "Now you can use `git diff` to see what is still unstaged"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:254
msgid ""
"\t$ git diff\n"
"\tdiff --git a/benchmarks.rb b/benchmarks.rb\n"
"\tindex e445e28..86b2f7c 100644\n"
"\t--- a/benchmarks.rb\n"
"\t+++ b/benchmarks.rb\n"
"\t@@ -127,3 +127,4 @@ end\n"
"\t main()"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:262
msgid ""
"\t ##pp Grit::GitRuby.cache_client.stats\n"
"\t+# test line"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:265
msgid "and `git diff --cached` to see what you’ve staged so far:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:267
msgid ""
"\t$ git diff --cached\n"
"\tdiff --git a/benchmarks.rb b/benchmarks.rb\n"
"\tindex 3cb747f..e445e28 100644\n"
"\t--- a/benchmarks.rb\n"
"\t+++ b/benchmarks.rb\n"
"\t@@ -36,6 +36,10 @@ def main\n"
"\t          @commit.parents[0].parents[0].parents[0]\n"
"\t        end"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:276
msgid ""
"\t+        run_code(x, 'commits 1') do\n"
"\t+          git.commits.size\n"
"\t+        end\n"
"\t+\n"
"\t        run_code(x, 'commits 2') do\n"
"\t          log = git.commits('master', 15)\n"
"\t          log.size"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:284
msgid "### Committing Your Changes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:286
msgid ""
"Now that your staging area is set up the way you want it, you can commit "
"your changes. Remember that anything that is still unstaged — any files you "
"have created or modified that you haven’t run `git add` on since you edited "
"them — won’t go into this commit. They will stay as modified files on your "
"disk.\n"
"In this case, the last time you ran `git status`, you saw that everything "
"was staged, so you’re ready to commit your changes. The simplest way to "
"commit is to type `git commit`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:289
msgid "\t$ git commit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:291
msgid ""
"Doing so launches your editor of choice. (This is set by your shell’s `"
"$EDITOR` environment variable — usually vim or emacs, although you can "
"configure it with whatever you want using the `git config --global core."
"editor` command as you saw in *Chapter 1*)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:293
msgid "The editor displays the following text (this example is a Vim screen):"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:295
msgid ""
"\t# Please enter the commit message for your changes. Lines starting\n"
"\t# with '#' will be ignored, and an empty message aborts the commit.\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       new file:   README\n"
"\t#       modified:   benchmarks.rb\n"
"\t~\n"
"\t~\n"
"\t~\n"
"\t\".git/COMMIT_EDITMSG\" 10L, 283C"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:308
msgid ""
"You can see that the default commit message contains the latest output of "
"the `git status` command commented out and one empty line on top. You can "
"remove these comments and type your commit message, or you can leave them "
"there to help you remember what you’re committing. (For an even more "
"explicit reminder of what you’ve modified, you can pass the `-v` option to "
"`git commit`. Doing so also puts the diff of your change in the editor so "
"you can see exactly what you did.) When you exit the editor, Git creates "
"your commit with that commit message (with the comments and diff stripped "
"out)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:310
msgid ""
"Alternatively, you can type your commit message inline with the `commit` "
"command by specifying it after a `-m` flag, like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:312
msgid ""
"\t$ git commit -m \"Story 182: Fix benchmarks for speed\"\n"
"\t[master]: created 463dc4f: \"Fix benchmarks for speed\"\n"
"\t 2 files changed, 3 insertions(+), 0 deletions(-)\n"
"\t create mode 100644 README"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:317
msgid ""
"Now you’ve created your first commit! You can see that the commit has given "
"you some output about itself: which branch you committed to (`master`), what "
"SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and "
"statistics about lines added and removed in the commit."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:319
msgid ""
"Remember that the commit records the snapshot you set up in your staging "
"area. Anything you didn’t stage is still sitting there modified; you can do "
"another commit to add it to your history. Every time you perform a commit, "
"you’re recording a snapshot of your project that you can revert to or "
"compare to later."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:321
msgid "### Skipping the Staging Area ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:323
msgid ""
"Although it can be amazingly useful for crafting commits exactly how you "
"want them, the staging area is sometimes a bit more complex than you need in "
"your workflow. If you want to skip the staging area, Git provides a simple "
"shortcut. Providing the `-a` option to the `git commit` command makes Git "
"automatically stage every file that is already tracked before doing the "
"commit, letting you skip the `git add` part:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:325
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#\n"
"\t#\tmodified:   benchmarks.rb\n"
"\t#\n"
"\t$ git commit -a -m 'added new benchmarks'\n"
"\t[master 83e38c7] added new benchmarks\n"
"\t 1 files changed, 5 insertions(+), 0 deletions(-)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:336
msgid ""
"Notice how you don’t have to run `git add` on the `benchmarks.rb` file in "
"this case before you commit."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:338
msgid "### Removing Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:340
msgid ""
"To remove a file from Git, you have to remove it from your tracked files "
"(more accurately, remove it from your staging area) and then commit. The "
"`git rm` command does that and also removes the file from your working "
"directory so you don’t see it as an untracked file next time around."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:342
msgid ""
"If you simply remove the file from your working directory, it shows up under "
"the “Changes not staged for commit” (that is, _unstaged_) area of your `git "
"status` output:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:344
msgid ""
"\t$ rm grit.gemspec\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add/rm <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#       deleted:    grit.gemspec\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:354
msgid "Then, if you run `git rm`, it stages the file’s removal:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:356
msgid ""
"\t$ git rm grit.gemspec\n"
"\trm 'grit.gemspec'\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t#\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       deleted:    grit.gemspec\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:367
msgid ""
"The next time you commit, the file will be gone and no longer tracked. If "
"you modified the file and added it to the index already, you must force the "
"removal with the `-f` option. This is a safety feature to prevent accidental "
"removal of data that hasn’t yet been recorded in a snapshot and that can’t "
"be recovered from Git."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:369
msgid ""
"Another useful thing you may want to do is to keep the file in your working "
"tree but remove it from your staging area. In other words, you may want to "
"keep the file on your hard drive but not have Git track it anymore. This is "
"particularly useful if you forgot to add something to your `.gitignore` file "
"and accidentally added it, like a large log file or a bunch of `.a` compiled "
"files. To do this, use the `--cached` option:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:371
msgid "\t$ git rm --cached readme.txt"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:373
msgid ""
"You can pass files, directories, and file-glob patterns to the `git rm` "
"command. That means you can do things such as"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:375
msgid "\t$ git rm log/\\*.log"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:377
msgid ""
"Note the backslash (`\\`) in front of the `*`. This is necessary because Git "
"does its own filename expansion in addition to your shell’s filename "
"expansion. On Windows with the system console, the backslash must be "
"omitted. This command removes all files that have the `.log` extension in "
"the `log/` directory. Or, you can do something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:379
msgid "\t$ git rm \\*~"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:381
msgid "This command removes all files that end with `~`."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:383
msgid "### Moving Files ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:385
msgid ""
"Unlike many other VCS systems, Git doesn’t explicitly track file movement. "
"If you rename a file in Git, no metadata is stored in Git that tells it you "
"renamed the file. However, Git is pretty smart about figuring that out after "
"the fact — we’ll deal with detecting file movement a bit later."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:387
msgid ""
"Thus it’s a bit confusing that Git has a `mv` command. If you want to rename "
"a file in Git, you can run something like"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:389
msgid "\t$ git mv file_from file_to"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:391
msgid ""
"and it works fine. In fact, if you run something like this and look at the "
"status, you’ll see that Git considers it a renamed file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:393
msgid ""
"\t$ git mv README.txt README\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Your branch is ahead of 'origin/master' by 1 commit.\n"
"\t#\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       renamed:    README.txt -> README\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:404
msgid "However, this is equivalent to running something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:406
msgid ""
"\t$ mv README.txt README\n"
"\t$ git rm README.txt\n"
"\t$ git add README"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:410
msgid ""
"Git figures out that it’s a rename implicitly, so it doesn’t matter if you "
"rename a file that way or with the `mv` command. The only real difference is "
"that `mv` is one command instead of three — it’s a convenience function. "
"More important, you can use any tool you like to rename a file, and address "
"the add/rm later, before you commit."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:412
msgid "## Viewing the Commit History ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:414
msgid ""
"After you have created several commits, or if you have cloned a repository "
"with an existing commit history, you’ll probably want to look back to see "
"what has happened. The most basic and powerful tool to do this is the `git "
"log` command."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:416
msgid ""
"These examples use a very simple project called `simplegit` that I often use "
"for demonstrations. To get the project, run"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:418
msgid "\tgit clone git://github.com/schacon/simplegit-progit.git"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:420
msgid ""
"When you run `git log` in this project, you should get output that looks "
"something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:422
msgid ""
"\t$ git log\n"
"\tcommit ca82a6dff817ec66f44342007202690a93763949\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Mar 17 21:52:11 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:427
msgctxt "en/02-git-basics/01-chapter2.markdown:427"
msgid "\t    changed the version number"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:429
msgctxt "en/02-git-basics/01-chapter2.markdown:429"
msgid ""
"\tcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sat Mar 15 16:40:33 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:433
msgctxt "en/02-git-basics/01-chapter2.markdown:433"
msgid "\t    removed unnecessary test code"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:435
msgctxt "en/02-git-basics/01-chapter2.markdown:435"
msgid ""
"\tcommit a11bef06a3f659402fe7563abf99ad00de2209e6\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sat Mar 15 10:31:28 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:439
msgctxt "en/02-git-basics/01-chapter2.markdown:439"
msgid "\t    first commit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:441
msgid ""
"By default, with no arguments, `git log` lists the commits made in that "
"repository in reverse chronological order. That is, the most recent commits "
"show up first. As you can see, this command lists each commit with its SHA-1 "
"checksum, the author’s name and e-mail, the date written, and the commit "
"message."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:443
msgid ""
"A huge number and variety of options to the `git log` command are available "
"to show you exactly what you’re looking for. Here, we’ll show you some of "
"the most-used options."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:445
msgid ""
"One of the more helpful options is `-p`, which shows the diff introduced in "
"each commit. You can also use `-2`, which limits the output to only the last "
"two entries:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:447
msgid ""
"\t$ git log -p -2\n"
"\tcommit ca82a6dff817ec66f44342007202690a93763949\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Mar 17 21:52:11 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:452
msgctxt "en/02-git-basics/01-chapter2.markdown:452"
msgid "\t    changed the version number"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:454
msgid ""
"\tdiff --git a/Rakefile b/Rakefile\n"
"\tindex a874b73..8f94139 100644\n"
"\t--- a/Rakefile\n"
"\t+++ b/Rakefile\n"
"\t@@ -5,7 +5,7 @@ require 'rake/gempackagetask'\n"
"\t spec = Gem::Specification.new do |s|\n"
"\t-    s.version   =   \"0.1.0\"\n"
"\t+    s.version   =   \"0.1.1\"\n"
"\t     s.author    =   \"Scott Chacon\""
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:464
msgctxt "en/02-git-basics/01-chapter2.markdown:464"
msgid ""
"\tcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sat Mar 15 16:40:33 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:468
msgctxt "en/02-git-basics/01-chapter2.markdown:468"
msgid "\t    removed unnecessary test code"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:470
msgid ""
"\tdiff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"\tindex a0a60ae..47c6340 100644\n"
"\t--- a/lib/simplegit.rb\n"
"\t+++ b/lib/simplegit.rb\n"
"\t@@ -18,8 +18,3 @@ class SimpleGit\n"
"\t     end"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:477
msgid ""
"\t end\n"
"\t-\n"
"\t-if $0 == __FILE__\n"
"\t-  git = SimpleGit.new\n"
"\t-  puts git.show\n"
"\t-end\n"
"\t\\ No newline at end of file"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:485
msgid ""
"This option displays the same information but with a diff directly following "
"each entry. This is very helpful for code review or to quickly browse what "
"happened during a series of commits that a collaborator has added.\n"
"You can also use a series of summarizing options with `git log`. For "
"example, if you want to see some abbreviated stats for each commit, you can "
"use the `--stat` option:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:488
msgid ""
"\t$ git log --stat\n"
"\tcommit ca82a6dff817ec66f44342007202690a93763949\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Mar 17 21:52:11 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:493
msgctxt "en/02-git-basics/01-chapter2.markdown:493"
msgid "\t    changed the version number"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:495
msgid ""
"\t Rakefile |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:498
msgctxt "en/02-git-basics/01-chapter2.markdown:498"
msgid ""
"\tcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sat Mar 15 16:40:33 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:502
msgctxt "en/02-git-basics/01-chapter2.markdown:502"
msgid "\t    removed unnecessary test code"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:504
msgid ""
"\t lib/simplegit.rb |    5 -----\n"
"\t 1 files changed, 0 insertions(+), 5 deletions(-)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:507
msgctxt "en/02-git-basics/01-chapter2.markdown:507"
msgid ""
"\tcommit a11bef06a3f659402fe7563abf99ad00de2209e6\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sat Mar 15 10:31:28 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:511
msgctxt "en/02-git-basics/01-chapter2.markdown:511"
msgid "\t    first commit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:513
msgid ""
"\t README           |    6 ++++++\n"
"\t Rakefile         |   23 +++++++++++++++++++++++\n"
"\t lib/simplegit.rb |   25 +++++++++++++++++++++++++\n"
"\t 3 files changed, 54 insertions(+), 0 deletions(-)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:518
msgid ""
"As you can see, the `--stat` option prints below each commit entry a list of "
"modified files, how many files were changed, and how many lines in those "
"files were added and removed. It also puts a summary of the information at "
"the end.\n"
"Another really useful option is `--pretty`. This option changes the log "
"output to formats other than the default. A few prebuilt options are "
"available for you to use. The `oneline` option prints each commit on a "
"single line, which is useful if you’re looking at a lot of commits. In "
"addition, the `short`, `full`, and `fuller` options show the output in "
"roughly the same format but with less or more information, respectively:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:521
msgid ""
"\t$ git log --pretty=oneline\n"
"\tca82a6dff817ec66f44342007202690a93763949 changed the version number\n"
"\t085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code\n"
"\ta11bef06a3f659402fe7563abf99ad00de2209e6 first commit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:526
msgid ""
"The most interesting option is `format`, which allows you to specify your "
"own log output format. This is especially useful when you’re generating "
"output for machine parsing — because you specify the format explicitly, you "
"know it won’t change with updates to Git:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:528
msgid ""
"\t$ git log --pretty=format:\"%h - %an, %ar : %s\"\n"
"\tca82a6d - Scott Chacon, 11 months ago : changed the version number\n"
"\t085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code\n"
"\ta11bef0 - Scott Chacon, 11 months ago : first commit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:533
msgid "Table 2-1 lists some of the more useful options that format takes."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:535
msgid ""
"\tOption\tDescription of Output\n"
"\t%H\tCommit hash\n"
"\t%h\tAbbreviated commit hash\n"
"\t%T\tTree hash\n"
"\t%t\tAbbreviated tree hash\n"
"\t%P\tParent hashes\n"
"\t%p\tAbbreviated parent hashes\n"
"\t%an\tAuthor name\n"
"\t%ae\tAuthor e-mail\n"
"\t%ad\tAuthor date (format respects the --date= option)\n"
"\t%ar\tAuthor date, relative\n"
"\t%cn\tCommitter name\n"
"\t%ce\tCommitter email\n"
"\t%cd\tCommitter date\n"
"\t%cr\tCommitter date, relative\n"
"\t%s\tSubject"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:552
msgid ""
"You may be wondering what the difference is between _author_ and "
"_committer_. The _author_ is the person who originally wrote the patch, "
"whereas the _committer_ is the person who last applied the patch. So, if you "
"send in a patch to a project and one of the core members applies the patch, "
"both of you get credit — you as the author and the core member as the "
"committer. We’ll cover this distinction a bit more in *Chapter 5*."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:554
msgid ""
"The `oneline` and `format` options are particularly useful with another "
"`log` option called `--graph`. This option adds a nice little ASCII graph "
"showing your branch and merge history, which we can see our copy of the Grit "
"project repository:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:556
msgid ""
"\t$ git log --pretty=format:\"%h %s\" --graph\n"
"\t* 2d3acf9 ignore errors from SIGCHLD on trap\n"
"\t*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n"
"\t|\\\n"
"\t| * 420eac9 Added a method for getting the current branch.\n"
"\t* | 30e367c timeout code and tests\n"
"\t* | 5a09431 add timeout protection to grit\n"
"\t* | e1193f8 support for heads with slashes in them\n"
"\t|/\n"
"\t* d6016bc require time for xmlschema\n"
"\t*  11d191e Merge branch 'defunkt' into local"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:568
msgid ""
"Those are only some simple output-formatting options to `git log` — there "
"are many more. Table 2-2 lists the options we’ve covered so far and some "
"other common formatting options that may be useful, along with how they "
"change the output of the `log` command."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:570
msgid ""
"\tOption\tDescription\n"
"\t-p\tShow the patch introduced with each commit.\n"
"\t--stat\tShow statistics for files modified in each commit.\n"
"\t--shortstat\tDisplay only the changed/insertions/deletions line from the --"
"stat command.\n"
"\t--name-only\tShow the list of files modified after the commit "
"information.\n"
"\t--name-status\tShow the list of files affected with added/modified/deleted "
"information as well.\n"
"\t--abbrev-commit\tShow only the first few characters of the SHA-1 checksum "
"instead of all 40.\n"
"\t--relative-date\tDisplay the date in a relative format (for example, “2 "
"weeks ago”) instead of using the full date format.\n"
"\t--graph\tDisplay an ASCII graph of the branch and merge history beside the "
"log output.\n"
"\t--pretty\tShow commits in an alternate format. Options include oneline, "
"short, full, fuller, and format (where you specify your own format)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:581
msgid "### Limiting Log Output ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:583
msgid ""
"In addition to output-formatting options, `git log` takes a number of useful "
"limiting options — that is, options that let you show only a subset of "
"commits. You’ve seen one such option already — the `-2` option, which shows "
"only the last two commits. In fact, you can do `-<n>`, where `n` is any "
"integer to show the last `n` commits. In reality, you’re unlikely to use "
"that often, because Git by default pipes all output through a pager so you "
"see only one page of log output at a time."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:585
msgid ""
"However, the time-limiting options such as `--since` and `--until` are very "
"useful. For example, this command gets the list of commits made in the last "
"two weeks:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:587
msgid "\t$ git log --since=2.weeks"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:589
msgid ""
"This command works with lots of formats — you can specify a specific date "
"(“2008-01-15”) or a relative date such as “2 years 1 day 3 minutes ago”."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:591
msgid ""
"You can also filter the list to commits that match some search criteria. The "
"`--author` option allows you to filter on a specific author, and the `--"
"grep` option lets you search for keywords in the commit messages. (Note that "
"if you want to specify both author and grep options, you have to add `--all-"
"match` or the command will match commits with either.)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:593
msgid ""
"The last really useful option to pass to `git log` as a filter is a path. If "
"you specify a directory or file name, you can limit the log output to "
"commits that introduced a change to those files. This is always the last "
"option and is generally preceded by double dashes (`--`) to separate the "
"paths from the options."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:595
msgid ""
"In Table 2-3 we’ll list these and a few other common options for your "
"reference."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:597
msgid ""
"\tOption\tDescription\n"
"\t-(n)\tShow only the last n commits\n"
"\t--since, --after\tLimit the commits to those made after the specified "
"date.\n"
"\t--until, --before\tLimit the commits to those made before the specified "
"date.\n"
"\t--author\tOnly show commits in which the author entry matches the "
"specified string.\n"
"\t--committer\tOnly show commits in which the committer entry matches the "
"specified string."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:604
msgid ""
"For example, if you want to see which commits modifying test files in the "
"Git source code history were committed by Junio Hamano in the month of "
"October 2008 and were not merges, you can run something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:606
msgid ""
"\t$ git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" \\\n"
"\t   --before=\"2008-11-01\" --no-merges -- t/\n"
"\t5610e3b - Fix testcase failure when extended attribute\n"
"\tacd3b9e - Enhance hold_lock_file_for_{update,append}()\n"
"\tf563754 - demonstrate breakage of detached checkout wi\n"
"\td1a43f2 - reset --hard/read-tree --reset -u: remove un\n"
"\t51a94af - Fix \"checkout --track -b newbranch\" on detac\n"
"\tb0ad11e - pull: allow \"git pull origin $something:$cur"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:615
msgid ""
"Of the nearly 20,000 commits in the Git source code history, this command "
"shows the 6 that match those criteria."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:617
msgid "### Using a GUI to Visualize History ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:619
msgid ""
"If you like to use a more graphical tool to visualize your commit history, "
"you may want to take a look at a Tcl/Tk program called `gitk` that is "
"distributed with Git. Gitk is basically a visual `git log` tool, and it "
"accepts nearly all the filtering options that `git log` does. If you type "
"`gitk` on the command line in your project, you should see something like "
"Figure 2-2."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:621
msgid ""
"Insert 18333fig0202.png\n"
"Figure 2-2. The gitk history visualizer."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:624
msgid ""
"You can see the commit history in the top half of the window along with a "
"nice ancestry graph. The diff viewer in the bottom half of the window shows "
"you the changes introduced at any commit you click."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:626
msgid "## Undoing Things ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:628
msgid ""
"At any stage, you may want to undo something. Here, we’ll review a few basic "
"tools for undoing changes that you’ve made. Be careful, because you can’t "
"always revert some of these undos. This is one of the few areas in Git where "
"you may lose some work if you do it wrong."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:630
msgid "### Changing Your Last Commit ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:632
msgid ""
"One of the common undos takes place when you commit too early and possibly "
"forget to add some files, or you mess up your commit message. If you want to "
"try that commit again, you can run commit with the `--amend` option:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:634
msgid "\t$ git commit --amend"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:636
msgid ""
"This command takes your staging area and uses it for the commit. If you’ve "
"made no changes since your last commit (for instance, you run this command "
"immediately after your previous commit), then your snapshot will look "
"exactly the same and all you’ll change is your commit message."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:638
msgid ""
"The same commit-message editor fires up, but it already contains the message "
"of your previous commit. You can edit the message the same as always, but it "
"overwrites your previous commit."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:640
msgid ""
"As an example, if you commit and then realize you forgot to stage the "
"changes in a file you wanted to add to this commit, you can do something "
"like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:642
msgid ""
"\t$ git commit -m 'initial commit'\n"
"\t$ git add forgotten_file\n"
"\t$ git commit --amend"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:646
msgid ""
"After these three commands, you end up with a single commit — the second "
"commit replaces the results of the first."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:648
msgid "### Unstaging a Staged File ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:650
msgid ""
"The next two sections demonstrate how to wrangle your staging area and "
"working directory changes. The nice part is that the command you use to "
"determine the state of those two areas also reminds you how to undo changes "
"to them. For example, let’s say you’ve changed two files and want to commit "
"them as two separate changes, but you accidentally type `git add *` and "
"stage them both. How can you unstage one of the two? The `git status` "
"command reminds you:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:652
msgid ""
"\t$ git add .\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       modified:   README.txt\n"
"\t#       modified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:662
msgid ""
"Right below the “Changes to be committed” text, it says \"use `git reset "
"HEAD <file>...` to unstage\". So, let’s use that advice to unstage the "
"`benchmarks.rb` file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:664
msgid ""
"\t$ git reset HEAD benchmarks.rb\n"
"\tbenchmarks.rb: locally modified\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       modified:   README.txt\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#   (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
"\t#\n"
"\t#       modified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:680
msgid ""
"The command is a bit strange, but it works. The `benchmarks.rb` file is "
"modified but once again unstaged."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:682
msgid "### Unmodifying a Modified File ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:684
msgid ""
"What if you realize that you don’t want to keep your changes to the "
"`benchmarks.rb` file? How can you easily unmodify it — revert it back to "
"what it looked like when you last committed (or initially cloned, or however "
"you got it into your working directory)? Luckily, `git status` tells you how "
"to do that, too. In the last example output, the unstaged area looks like "
"this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:686
msgid ""
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#   (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
"\t#\n"
"\t#       modified:   benchmarks.rb\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:693
msgid ""
"It tells you pretty explicitly how to discard the changes you’ve made (at "
"least, the newer versions of Git, 1.6.1 and later, do this — if you have an "
"older version, we highly recommend upgrading it to get some of these nicer "
"usability features). Let’s do what it says:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:695
msgid ""
"\t$ git checkout -- benchmarks.rb\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#       modified:   README.txt\n"
"\t#"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:704
msgid ""
"You can see that the changes have been reverted. You should also realize "
"that this is a dangerous command: any changes you made to that file are gone "
"— you just copied another file over it. Don’t ever use this command unless "
"you absolutely know that you don’t want the file. If you just need to get it "
"out of the way, we’ll go over stashing and branching in the next chapter; "
"these are generally better ways to go."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:706
msgid ""
"Remember, anything that is committed in Git can almost always be recovered. "
"Even commits that were on branches that were deleted or commits that were "
"overwritten with an `--amend` commit can be recovered (see *Chapter 9* for "
"data recovery). However, anything you lose that was never committed is "
"likely never to be seen again."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:708
msgid "## Working with Remotes ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:710
msgid ""
"To be able to collaborate on any Git project, you need to know how to manage "
"your remote repositories. Remote repositories are versions of your project "
"that are hosted on the Internet or network somewhere. You can have several "
"of them, each of which generally is either read-only or read/write for you. "
"Collaborating with others involves managing these remote repositories and "
"pushing and pulling data to and from them when you need to share work.\n"
"Managing remote repositories includes knowing how to add remote "
"repositories, remove remotes that are no longer valid, manage various remote "
"branches and define them as being tracked or not, and more. In this section, "
"we’ll cover these remote-management skills."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:713
msgid "### Showing Your Remotes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:715
msgid ""
"To see which remote servers you have configured, you can run the `git "
"remote` command. It lists the shortnames of each remote handle you’ve "
"specified. If you’ve cloned your repository, you should at least see "
"*origin* — that is the default name Git gives to the server you cloned from:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:717
msgid ""
"\t$ git clone git://github.com/schacon/ticgit.git\n"
"\tInitialized empty Git repository in /private/tmp/ticgit/.git/\n"
"\tremote: Counting objects: 595, done.\n"
"\tremote: Compressing objects: 100% (269/269), done.\n"
"\tremote: Total 595 (delta 255), reused 589 (delta 253)\n"
"\tReceiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.\n"
"\tResolving deltas: 100% (255/255), done.\n"
"\t$ cd ticgit\n"
"\t$ git remote\n"
"\torigin"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:728
msgid ""
"You can also specify `-v`, which shows you the URL that Git has stored for "
"the shortname to be expanded to:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:730
msgid ""
"\t$ git remote -v\n"
"\torigin  git://github.com/schacon/ticgit.git (fetch)\n"
"\torigin  git://github.com/schacon/ticgit.git (push)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:734
msgid ""
"If you have more than one remote, the command lists them all. For example, "
"my Grit repository looks something like this."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:736
msgid ""
"\t$ cd grit\n"
"\t$ git remote -v\n"
"\tbakkdoor  git://github.com/bakkdoor/grit.git\n"
"\tcho45     git://github.com/cho45/grit.git\n"
"\tdefunkt   git://github.com/defunkt/grit.git\n"
"\tkoke      git://github.com/koke/grit.git\n"
"\torigin    git@github.com:mojombo/grit.git"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:744
msgid ""
"This means we can pull contributions from any of these users pretty easily. "
"But notice that only the origin remote is an SSH URL, so it’s the only one I "
"can push to (we’ll cover why this is in *Chapter 4*)."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:746
msgid "### Adding Remote Repositories ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:748
msgid ""
"I’ve mentioned and given some demonstrations of adding remote repositories "
"in previous sections, but here is how to do it explicitly. To add a new "
"remote Git repository as a shortname you can reference easily, run `git "
"remote add [shortname] [url]`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:750
msgid ""
"\t$ git remote\n"
"\torigin\n"
"\t$ git remote add pb git://github.com/paulboone/ticgit.git\n"
"\t$ git remote -v\n"
"\torigin\tgit://github.com/schacon/ticgit.git\n"
"\tpb\tgit://github.com/paulboone/ticgit.git"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:757
msgid ""
"Now you can use the string `pb` on the command line in lieu of the whole "
"URL. For example, if you want to fetch all the information that Paul has but "
"that you don’t yet have in your repository, you can run git fetch pb:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:759
msgid ""
"\t$ git fetch pb\n"
"\tremote: Counting objects: 58, done.\n"
"\tremote: Compressing objects: 100% (41/41), done.\n"
"\tremote: Total 44 (delta 24), reused 1 (delta 0)\n"
"\tUnpacking objects: 100% (44/44), done.\n"
"\tFrom git://github.com/paulboone/ticgit\n"
"\t * [new branch]      master     -> pb/master\n"
"\t * [new branch]      ticgit     -> pb/ticgit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:768
msgid ""
"Paul’s master branch is accessible locally as `pb/master` — you can merge it "
"into one of your branches, or you can check out a local branch at that point "
"if you want to inspect it."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:770
msgid "### Fetching and Pulling from Your Remotes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:772
msgid "As you just saw, to get data from your remote projects, you can run:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:774
msgid "\t$ git fetch [remote-name]"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:776
msgid ""
"The command goes out to that remote project and pulls down all the data from "
"that remote project that you don’t have yet. After you do this, you should "
"have references to all the branches from that remote, which you can merge in "
"or inspect at any time. (We’ll go over what branches are and how to use them "
"in much more detail in *Chapter 3*.)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:778
msgid ""
"If you clone a repository, the command automatically adds that remote "
"repository under the name *origin*. So, `git fetch origin` fetches any new "
"work that has been pushed to that server since you cloned (or last fetched "
"from) it. It’s important to note that the `fetch` command pulls the data to "
"your local repository — it doesn’t automatically merge it with any of your "
"work or modify what you’re currently working on. You have to merge it "
"manually into your work when you’re ready."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:780
msgid ""
"If you have a branch set up to track a remote branch (see the next section "
"and *Chapter 3* for more information), you can use the `git pull` command to "
"automatically fetch and then merge a remote branch into your current branch. "
"This may be an easier or more comfortable workflow for you; and by default, "
"the `git clone` command automatically sets up your local master branch to "
"track the remote master branch on the server you cloned from (assuming the "
"remote has a master branch). Running `git pull` generally fetches data from "
"the server you originally cloned from and automatically tries to merge it "
"into the code you’re currently working on."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:782
msgid "### Pushing to Your Remotes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:784
msgid ""
"When you have your project at a point that you want to share, you have to "
"push it upstream. The command for this is simple: `git push [remote-name] "
"[branch-name]`. If you want to push your master branch to your `origin` "
"server (again, cloning generally sets up both of those names for you "
"automatically), then you can run this to push your work back up to the "
"server:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:786
msgid "\t$ git push origin master"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:788
msgid ""
"This command works only if you cloned from a server to which you have write "
"access and if nobody has pushed in the meantime. If you and someone else "
"clone at the same time and they push upstream and then you push upstream, "
"your push will rightly be rejected. You’ll have to pull down their work "
"first and incorporate it into yours before you’ll be allowed to push. See "
"*Chapter 3* for more detailed information on how to push to remote servers."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:790
msgid "### Inspecting a Remote ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:792
msgid ""
"If you want to see more information about a particular remote, you can use "
"the `git remote show [remote-name]` command. If you run this command with a "
"particular shortname, such as `origin`, you get something like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:794
msgid ""
"\t$ git remote show origin\n"
"\t* remote origin\n"
"\t  URL: git://github.com/schacon/ticgit.git\n"
"\t  Remote branch merged with 'git pull' while on branch master\n"
"\t    master\n"
"\t  Tracked remote branches\n"
"\t    master\n"
"\t    ticgit"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:803
msgid ""
"It lists the URL for the remote repository as well as the tracking branch "
"information. The command helpfully tells you that if you’re on the master "
"branch and you run `git pull`, it will automatically merge in the master "
"branch on the remote after it fetches all the remote references. It also "
"lists all the remote references it has pulled down."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:805
msgid ""
"That is a simple example you’re likely to encounter. When you’re using Git "
"more heavily, however, you may see much more information from `git remote "
"show`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:807
msgid ""
"\t$ git remote show origin\n"
"\t* remote origin\n"
"\t  URL: git@github.com:defunkt/github.git\n"
"\t  Remote branch merged with 'git pull' while on branch issues\n"
"\t    issues\n"
"\t  Remote branch merged with 'git pull' while on branch master\n"
"\t    master\n"
"\t  New remote branches (next fetch will store in remotes/origin)\n"
"\t    caching\n"
"\t  Stale tracking branches (use 'git remote prune')\n"
"\t    libwalker\n"
"\t    walker2\n"
"\t  Tracked remote branches\n"
"\t    acl\n"
"\t    apiv2\n"
"\t    dashboard2\n"
"\t    issues\n"
"\t    master\n"
"\t    postgres\n"
"\t  Local branch pushed with 'git push'\n"
"\t    master:master"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:829
msgid ""
"This command shows which branch is automatically pushed when you run `git "
"push` on certain branches. It also shows you which remote branches on the "
"server you don’t yet have, which remote branches you have that have been "
"removed from the server, and multiple branches that are automatically merged "
"when you run `git pull`."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:831
msgid "### Removing and Renaming Remotes ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:833
msgid ""
"If you want to rename a reference, in newer versions of Git you can run `git "
"remote rename` to change a remote’s shortname. For instance, if you want to "
"rename `pb` to `paul`, you can do so with `git remote rename`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:835
msgid ""
"\t$ git remote rename pb paul\n"
"\t$ git remote\n"
"\torigin\n"
"\tpaul"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:840
msgid ""
"It’s worth mentioning that this changes your remote branch names, too. What "
"used to be referenced at `pb/master` is now at `paul/master`."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:842
msgid ""
"If you want to remove a reference for some reason — you’ve moved the server "
"or are no longer using a particular mirror, or perhaps a contributor isn’t "
"contributing anymore — you can use `git remote rm`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:844
msgid ""
"\t$ git remote rm paul\n"
"\t$ git remote\n"
"\torigin"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:848
msgid "## Tagging ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:850
msgid ""
"Like most VCSs, Git has the ability to tag specific points in history as "
"being important. Generally, people use this functionality to mark release "
"points (`v1.0`, and so on). In this section, you’ll learn how to list the "
"available tags, how to create new tags, and what the different types of tags "
"are."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:852
msgid "### Listing Your Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:854
msgid ""
"Listing the available tags in Git is straightforward. Just type `git tag`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:856
msgid ""
"\t$ git tag\n"
"\tv0.1\n"
"\tv1.3"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:860
msgid ""
"This command lists the tags in alphabetical order; the order in which they "
"appear has no real importance."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:862
msgid ""
"You can also search for tags with a particular pattern. The Git source repo, "
"for instance, contains more than 240 tags. If you’re only interested in "
"looking at the 1.4.2 series, you can run this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:864
msgid ""
"\t$ git tag -l 'v1.4.2.*'\n"
"\tv1.4.2.1\n"
"\tv1.4.2.2\n"
"\tv1.4.2.3\n"
"\tv1.4.2.4"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:870
msgid "### Creating Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:872
msgid ""
"Git uses two main types of tags: lightweight and annotated. A lightweight "
"tag is very much like a branch that doesn’t change — it’s just a pointer to "
"a specific commit. Annotated tags, however, are stored as full objects in "
"the Git database. They’re checksummed; contain the tagger name, e-mail, and "
"date; have a tagging message; and can be signed and verified with GNU "
"Privacy Guard (GPG). It’s generally recommended that you create annotated "
"tags so you can have all this information; but if you want a temporary tag "
"or for some reason don’t want to keep the other information, lightweight "
"tags are available too."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:874
msgid "### Annotated Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:876
msgid ""
"Creating an annotated tag in Git is simple. The easiest way is to specify `-"
"a` when you run the `tag` command:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:878
msgid ""
"\t$ git tag -a v1.4 -m 'my version 1.4'\n"
"\t$ git tag\n"
"\tv0.1\n"
"\tv1.3\n"
"\tv1.4"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:884
msgid ""
"The `-m` specifies a tagging message, which is stored with the tag. If you "
"don’t specify a message for an annotated tag, Git launches your editor so "
"you can type it in."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:886
msgid ""
"You can see the tag data along with the commit that was tagged by using the "
"`git show` command:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:888
msgid ""
"\t$ git show v1.4\n"
"\ttag v1.4\n"
"\tTagger: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Feb 9 14:45:11 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:893
msgid ""
"\tmy version 1.4\n"
"\tcommit 15027957951b64cf874c3557a0f3547bd83b3ff6\n"
"\tMerge: 4a447f7... a6b4c97...\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sun Feb 8 19:02:46 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:899
msgctxt "en/02-git-basics/01-chapter2.markdown:899"
msgid "\t    Merge branch 'experiment'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:901
msgid ""
"That shows the tagger information, the date the commit was tagged, and the "
"annotation message before showing the commit information."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:903
msgid "### Signed Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:905
msgid ""
"You can also sign your tags with GPG, assuming you have a private key. All "
"you have to do is use `-s` instead of `-a`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:907
msgid ""
"\t$ git tag -s v1.5 -m 'my signed 1.5 tag'\n"
"\tYou need a passphrase to unlock the secret key for\n"
"\tuser: \"Scott Chacon <schacon@gee-mail.com>\"\n"
"\t1024-bit DSA key, ID F721C45A, created 2009-02-09"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:912
msgid ""
"If you run `git show` on that tag, you can see your GPG signature attached "
"to it:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:914
msgid ""
"\t$ git show v1.5\n"
"\ttag v1.5\n"
"\tTagger: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Feb 9 15:22:20 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:919
msgid ""
"\tmy signed 1.5 tag\n"
"\t-----BEGIN PGP SIGNATURE-----\n"
"\tVersion: GnuPG v1.4.8 (Darwin)"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:923
msgid ""
"\tiEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN\n"
"\tKi0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/\n"
"\t=WryJ\n"
"\t-----END PGP SIGNATURE-----\n"
"\tcommit 15027957951b64cf874c3557a0f3547bd83b3ff6\n"
"\tMerge: 4a447f7... a6b4c97...\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sun Feb 8 19:02:46 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:932
msgctxt "en/02-git-basics/01-chapter2.markdown:932"
msgid "\t    Merge branch 'experiment'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:934
msgid "A bit later, you’ll learn how to verify signed tags."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:936
msgid "### Lightweight Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:938
msgid ""
"Another way to tag commits is with a lightweight tag. This is basically the "
"commit checksum stored in a file — no other information is kept. To create a "
"lightweight tag, don’t supply the `-a`, `-s`, or `-m` option:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:940
msgid ""
"\t$ git tag v1.4-lw\n"
"\t$ git tag\n"
"\tv0.1\n"
"\tv1.3\n"
"\tv1.4\n"
"\tv1.4-lw\n"
"\tv1.5"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:948
msgid ""
"This time, if you run `git show` on the tag, you don’t see the extra tag "
"information. The command just shows the commit:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:950
msgid ""
"\t$ git show v1.4-lw\n"
"\tcommit 15027957951b64cf874c3557a0f3547bd83b3ff6\n"
"\tMerge: 4a447f7... a6b4c97...\n"
"\tAuthor: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Sun Feb 8 19:02:46 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:956
msgctxt "en/02-git-basics/01-chapter2.markdown:956"
msgid "\t    Merge branch 'experiment'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:958
msgid "### Verifying Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:960
msgid ""
"To verify a signed tag, you use `git tag -v [tag-name]`. This command uses "
"GPG to verify the signature. You need the signer’s public key in your "
"keyring for this to work properly:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:962
msgid ""
"\t$ git tag -v v1.4.2.1\n"
"\tobject 883653babd8ee7ea23e6a5c392bb739348b1eb61\n"
"\ttype commit\n"
"\ttag v1.4.2.1\n"
"\ttagger Junio C Hamano <junkio@cox.net> 1158138501 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:968
msgid "\tGIT 1.4.2.1"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:970
msgid ""
"\tMinor fixes since 1.4.2, including git-mv and git-http with alternates.\n"
"\tgpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID "
"F3119B9A\n"
"\tgpg: Good signature from \"Junio C Hamano <junkio@cox.net>\"\n"
"\tgpg:                 aka \"[jpeg image of size 1513]\"\n"
"\tPrimary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:976
msgid ""
"If you don’t have the signer’s public key, you get something like this "
"instead:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:978
msgid ""
"\tgpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID "
"F3119B9A\n"
"\tgpg: Can't check signature: public key not found\n"
"\terror: could not verify the tag 'v1.4.2.1'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:982
msgid "### Tagging Later ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:984
msgid ""
"You can also tag commits after you’ve moved past them. Suppose your commit "
"history looks like this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:986
msgid ""
"\t$ git log --pretty=oneline\n"
"\t15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\n"
"\ta6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n"
"\t0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n"
"\t6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n"
"\t0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n"
"\t4682c3261057305bdd616e23b64b0857d832627b added a todo file\n"
"\t166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n"
"\t9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n"
"\t964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n"
"\t8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:998
msgid ""
"Now, suppose you forgot to tag the project at `v1.2`, which was at the "
"\"updated rakefile\" commit. You can add it after the fact. To tag that "
"commit, you specify the commit checksum (or part of it) at the end of the "
"command:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1000
msgid "\t$ git tag -a v1.2 -m 'version 1.2' 9fceb02"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1002
msgid "You can see that you’ve tagged the commit:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1004
msgid ""
"\t$ git tag\n"
"\tv0.1\n"
"\tv1.2\n"
"\tv1.3\n"
"\tv1.4\n"
"\tv1.4-lw\n"
"\tv1.5"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1012
msgid ""
"\t$ git show v1.2\n"
"\ttag v1.2\n"
"\tTagger: Scott Chacon <schacon@gee-mail.com>\n"
"\tDate:   Mon Feb 9 15:32:16 2009 -0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1017
msgid ""
"\tversion 1.2\n"
"\tcommit 9fceb02d0ae598e95dc970b74767f19372d61af8\n"
"\tAuthor: Magnus Chacon <mchacon@gee-mail.com>\n"
"\tDate:   Sun Apr 27 20:43:35 2008 -0700"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1022
msgid ""
"\t    updated rakefile\n"
"\t..."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1025
msgid "### Sharing Tags ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1027
msgid ""
"By default, the `git push` command doesn’t transfer tags to remote servers. "
"You will have to explicitly push tags to a shared server after you have "
"created them.  This process is just like sharing remote branches — you can "
"run `git push origin [tagname]`."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1029
msgid ""
"\t$ git push origin v1.5\n"
"\tCounting objects: 50, done.\n"
"\tCompressing objects: 100% (38/38), done.\n"
"\tWriting objects: 100% (44/44), 4.56 KiB, done.\n"
"\tTotal 44 (delta 18), reused 8 (delta 1)\n"
"\tTo git@github.com:schacon/simplegit.git\n"
"\t* [new tag]         v1.5 -> v1.5"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1037
msgid ""
"If you have a lot of tags that you want to push up at once, you can also use "
"the `--tags` option to the `git push` command.  This will transfer all of "
"your tags to the remote server that are not already there."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1039
msgid ""
"\t$ git push origin --tags\n"
"\tCounting objects: 50, done.\n"
"\tCompressing objects: 100% (38/38), done.\n"
"\tWriting objects: 100% (44/44), 4.56 KiB, done.\n"
"\tTotal 44 (delta 18), reused 8 (delta 1)\n"
"\tTo git@github.com:schacon/simplegit.git\n"
"\t * [new tag]         v0.1 -> v0.1\n"
"\t * [new tag]         v1.2 -> v1.2\n"
"\t * [new tag]         v1.4 -> v1.4\n"
"\t * [new tag]         v1.4-lw -> v1.4-lw\n"
"\t * [new tag]         v1.5 -> v1.5"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1051
msgid ""
"Now, when someone else clones or pulls from your repository, they will get "
"all your tags as well."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1053
msgid "## Tips and Tricks ##"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1055
msgid ""
"Before we finish this chapter on basic Git, a few little tips and tricks may "
"make your Git experience a bit simpler, easier, or more familiar. Many "
"people use Git without using any of these tips, and we won’t refer to them "
"or assume you’ve used them later in the book; but you should probably know "
"how to do them."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1057
msgid "### Auto-Completion ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1059
msgid ""
"If you use the Bash shell, Git comes with a nice auto-completion script you "
"can enable. Download the Git source code, and look in the `contrib/"
"completion` directory; there should be a file called `git-completion.bash`. "
"Copy this file to your home directory, and add this to your `.bashrc` file:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1061
msgid "\tsource ~/.git-completion.bash"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1063
msgid ""
"If you want to set up Git to automatically have Bash shell completion for "
"all users, copy this script to the `/opt/local/etc/bash_completion.d` "
"directory on Mac systems or to the `/etc/bash_completion.d/` directory on "
"Linux systems. This is a directory of scripts that Bash will automatically "
"load to provide shell completions."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1065
msgid ""
"If you’re using Windows with Git Bash, which is the default when installing "
"Git on Windows with msysGit, auto-completion should be preconfigured."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1067
msgid ""
"Press the Tab key when you’re writing a Git command, and it should return a "
"set of suggestions for you to pick from:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1069
msgid ""
"\t$ git co<tab><tab>\n"
"\tcommit config"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1072
msgid ""
"In this case, typing `git co` and then pressing the Tab key twice suggests "
"commit and config. Adding `m<tab>` completes `git commit` automatically."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1074
msgid ""
"This also works with options, which is probably more useful. For instance, "
"if you’re running a `git log` command and can’t remember one of the options, "
"you can start typing it and press Tab to see what matches:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1076
msgid ""
"\t$ git log --s<tab>\n"
"\t--shortstat  --since=  --src-prefix=  --stat   --summary"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1079
msgid ""
"That’s a pretty nice trick and may save you some time and documentation "
"reading."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1081
msgid "### Git Aliases ###"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1083
msgid ""
"Git doesn’t infer your command if you type it in partially. If you don’t "
"want to type the entire text of each of the Git commands, you can easily set "
"up an alias for each command using `git config`. Here are a couple of "
"examples you may want to set up:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1085
msgid ""
"\t$ git config --global alias.co checkout\n"
"\t$ git config --global alias.br branch\n"
"\t$ git config --global alias.ci commit\n"
"\t$ git config --global alias.st status"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1090
msgid ""
"This means that, for example, instead of typing `git commit`, you just need "
"to type `git ci`. As you go on using Git, you’ll probably use other commands "
"frequently as well; in this case, don’t hesitate to create new aliases."
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1092
msgid ""
"This technique can also be very useful in creating commands that you think "
"should exist. For example, to correct the usability problem you encountered "
"with unstaging a file, you can add your own unstage alias to Git:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1094
msgid "\t$ git config --global alias.unstage 'reset HEAD --'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1096
msgid "This makes the following two commands equivalent:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1098
msgid ""
"\t$ git unstage fileA\n"
"\t$ git reset HEAD fileA"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1101
msgid ""
"This seems a bit clearer. It’s also common to add a `last` command, like "
"this:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1103
msgid "\t$ git config --global alias.last 'log -1 HEAD'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1105
msgid "This way, you can see the last commit easily:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1107
msgid ""
"\t$ git last\n"
"\tcommit 66938dae3329c7aebe598c2246a8e6af90d04646\n"
"\tAuthor: Josh Goebel <dreamer3@example.com>\n"
"\tDate:   Tue Aug 26 19:48:51 2008 +0800"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1112
msgid "\t    test for current head"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1114
msgid "\t    Signed-off-by: Scott Chacon <schacon@example.com>"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1116
msgid ""
"As you can tell, Git simply replaces the new command with whatever you alias "
"it to. However, maybe you want to run an external command, rather than a Git "
"subcommand. In that case, you start the command with a `!` character. This "
"is useful if you write your own tools that work with a Git repository. We "
"can demonstrate by aliasing `git visual` to run `gitk`:"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1118
msgid "\t$ git config --global alias.visual '!gitk'"
msgstr ""

#: en/02-git-basics/01-chapter2.markdown:1122
msgid ""
"At this point, you can do all the basic local Git operations — creating or "
"cloning a repository, making changes, staging and committing those changes, "
"and viewing the history of all the changes the repository has been through. "
"Next, we’ll cover Git’s killer feature: its branching model."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:1
msgid "# Git Branching #"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:3
msgid ""
"Nearly every VCS has some form of branching support. Branching means you "
"diverge from the main line of development and continue to do work without "
"messing with that main line. In many VCS tools, this is a somewhat expensive "
"process, often requiring you to create a new copy of your source code "
"directory, which can take a long time for large projects."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:5
msgid ""
"Some people refer to the branching model in Git as its “killer feature”  , "
"and it certainly sets Git apart in the VCS community. Why is it so special? "
"The way Git branches is incredibly lightweight, making branching operations "
"nearly instantaneous and switching back and forth between branches generally "
"just as fast. Unlike many other VCSs, Git encourages a workflow that "
"branches and merges often, even multiple times in a day. Understanding and "
"mastering this feature gives you a powerful and unique tool and can "
"literally change the way that you develop."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:7
msgid "## What a Branch Is ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:9
msgid ""
"To really understand the way Git does branching, we need to take a step back "
"and examine how Git stores its data. As you may remember from Chapter 1, Git "
"doesn’t store data as a series of changesets or deltas, but instead as a "
"series of snapshots."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:11
msgid ""
"When you commit in Git, Git stores a commit object that contains a pointer "
"to the snapshot of the content you staged, the author and message metadata, "
"and zero or more pointers to the commit or commits that were the direct "
"parents of this commit: zero parents for the first commit, one parent for a "
"normal commit, and multiple parents for a commit that results from a merge "
"of two or more branches."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:13
msgid ""
"To visualize this, let’s assume that you have a directory containing three "
"files, and you stage them all and commit. Staging the files checksums each "
"one (the SHA-1 hash we mentioned in Chapter 1), stores that version of the "
"file in the Git repository (Git refers to them as blobs), and adds that "
"checksum to the staging area:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:15
msgid ""
"\t$ git add README test.rb LICENSE\n"
"\t$ git commit -m 'initial commit of my project'"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:18
msgid ""
"When you create the commit by running `git commit`, Git checksums each "
"subdirectory (in this case, just the root project directory) and stores "
"those tree objects in the Git repository. Git then creates a commit object "
"that has the metadata and a pointer to the root project tree so it can re-"
"create that snapshot when needed."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:20
msgid ""
"Your Git repository now contains five objects: one blob for the contents of "
"each of your three files, one tree that lists the contents of the directory "
"and specifies which file names are stored as which blobs, and one commit "
"with the pointer to that root tree and all the commit metadata. "
"Conceptually, the data in your Git repository looks something like Figure "
"3-1."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:22
msgid ""
"Insert 18333fig0301.png\n"
"Figure 3-1. Single commit repository data."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:25
msgid ""
"If you make some changes and commit again, the next commit stores a pointer "
"to the commit that came immediately before it. After two more commits, your "
"history might look something like Figure 3-2."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:27
msgid ""
"Insert 18333fig0302.png\n"
"Figure 3-2. Git object data for multiple commits."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:30
msgid ""
"A branch in Git is simply a lightweight movable pointer to one of these "
"commits. The default branch name in Git is master. As you initially make "
"commits, you’re given a `master` branch that points to the last commit you "
"made. Every time you commit, it moves forward automatically."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:32
msgid ""
"Insert 18333fig0303.png\n"
"Figure 3-3. Branch pointing into the commit data’s history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:35
msgid ""
"What happens if you create a new branch? Well, doing so creates a new "
"pointer for you to move around. Let’s say you create a new branch called "
"testing. You do this with the `git branch` command:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:37
msgid "\t$ git branch testing"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:39
msgid ""
"This creates a new pointer at the same commit you’re currently on (see "
"Figure 3-4)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:41
msgid ""
"Insert 18333fig0304.png\n"
"Figure 3-4. Multiple branches pointing into the commit’s data history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:44
msgid ""
"How does Git know what branch you’re currently on? It keeps a special "
"pointer called HEAD. Note that this is a lot different than the concept of "
"HEAD in other VCSs you may be used to, such as Subversion or CVS. In Git, "
"this is a pointer to the local branch you’re currently on. In this case, "
"you’re still on master. The git branch command only created a new branch — "
"it didn’t switch to that branch (see Figure 3-5)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:46
msgid ""
"Insert 18333fig0305.png\n"
"Figure 3-5. HEAD file pointing to the branch you’re on."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:49
msgid ""
"To switch to an existing branch, you run the `git checkout` command. Let’s "
"switch to the new testing branch:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:51
msgid "\t$ git checkout testing"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:53
msgid "This moves HEAD to point to the testing branch (see Figure 3-6)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:55
msgid ""
"Insert 18333fig0306.png\n"
"Figure 3-6. HEAD points to another branch when you switch branches."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:58
msgid "What is the significance of that? Well, let’s do another commit:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:60
msgid ""
"\t$ vim test.rb\n"
"\t$ git commit -a -m 'made a change'"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:63
msgid "Figure 3-7 illustrates the result."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:65
msgid ""
"Insert 18333fig0307.png\n"
"Figure 3-7. The branch that HEAD points to moves forward with each commit."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:68
msgid ""
"This is interesting, because now your testing branch has moved forward, but "
"your `master` branch still points to the commit you were on when you ran "
"`git checkout` to switch branches. Let’s switch back to the `master` branch:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:70
msgid "\t$ git checkout master"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:72
msgid "Figure 3-8 shows the result."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:74
msgid ""
"Insert 18333fig0308.png\n"
"Figure 3-8. HEAD moves to another branch on a checkout."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:77
msgid ""
"That command did two things. It moved the HEAD pointer back to point to the "
"`master` branch, and it reverted the files in your working directory back to "
"the snapshot that `master` points to. This also means the changes you make "
"from this point forward will diverge from an older version of the project. "
"It essentially rewinds the work you’ve done in your testing branch "
"temporarily so you can go in a different direction."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:79
msgid "Let’s make a few changes and commit again:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:81
msgid ""
"\t$ vim test.rb\n"
"\t$ git commit -a -m 'made other changes'"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:84
msgid ""
"Now your project history has diverged (see Figure 3-9). You created and "
"switched to a branch, did some work on it, and then switched back to your "
"main branch and did other work. Both of those changes are isolated in "
"separate branches: you can switch back and forth between the branches and "
"merge them together when you’re ready. And you did all that with simple "
"`branch` and `checkout` commands."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:86
msgid ""
"Insert 18333fig0309.png\n"
"Figure 3-9. The branch histories have diverged."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:89
msgid ""
"Because a branch in Git is in actuality a simple file that contains the 40 "
"character SHA-1 checksum of the commit it points to, branches are cheap to "
"create and destroy. Creating a new branch is as quick and simple as writing "
"41 bytes to a file (40 characters and a newline)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:91
msgid ""
"This is in sharp contrast to the way most VCS tools branch, which involves "
"copying all of the project’s files into a second directory. This can take "
"several seconds or even minutes, depending on the size of the project, "
"whereas in Git the process is always instantaneous. Also, because we’re "
"recording the parents when we commit, finding a proper merge base for "
"merging is automatically done for us and is generally very easy to do. These "
"features help encourage developers to create and use branches often."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:93
msgid "Let’s see why you should do so."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:95
msgid "## Basic Branching and Merging ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:97
msgid ""
"Let’s go through a simple example of branching and merging with a workflow "
"that you might use in the real world. You’ll follow these steps:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:99
msgid ""
"1. Do work on a web site.\n"
"2. Create a branch for a new story you’re working on.\n"
"3. Do some work in that branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:103
msgid ""
"At this stage, you’ll receive a call that another issue is critical and you "
"need a hotfix. You’ll do the following:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:105
msgid ""
"1. Revert back to your production branch.\n"
"2. Create a branch to add the hotfix.\n"
"3. After it’s tested, merge the hotfix branch, and push to production.\n"
"4. Switch back to your original story and continue working."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:110
msgid "### Basic Branching ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:112
msgid ""
"First, let’s say you’re working on your project and have a couple of commits "
"already (see Figure 3-10)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:114
msgid ""
"Insert 18333fig0310.png\n"
"Figure 3-10. A short and simple commit history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:117
msgid ""
"You’ve decided that you’re going to work on issue #53 in whatever issue-"
"tracking system your company uses. To be clear, Git isn’t tied into any "
"particular issue-tracking system; but because issue #53 is a focused topic "
"that you want to work on, you’ll create a new branch in which to work. To "
"create a branch and switch to it at the same time, you can run the `git "
"checkout` command with the `-b` switch:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:119
msgid ""
"\t$ git checkout -b iss53\n"
"\tSwitched to a new branch \"iss53\""
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:122
msgid "This is shorthand for:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:124
msgid ""
"\t$ git branch iss53\n"
"\t$ git checkout iss53"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:127
msgid "Figure 3-11 illustrates the result."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:129
msgid ""
"Insert 18333fig0311.png\n"
"Figure 3-11. Creating a new branch pointer."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:132
msgid ""
"You work on your web site and do some commits. Doing so moves the `iss53` "
"branch forward, because you have it checked out (that is, your HEAD is "
"pointing to it; see Figure 3-12):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:134
msgid ""
"\t$ vim index.html\n"
"\t$ git commit -a -m 'added a new footer [issue 53]'"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:137
msgid ""
"Insert 18333fig0312.png\n"
"Figure 3-12. The iss53 branch has moved forward with your work."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:140
msgid ""
"Now you get the call that there is an issue with the web site, and you need "
"to fix it immediately. With Git, you don’t have to deploy your fix along "
"with the `iss53` changes you’ve made, and you don’t have to put a lot of "
"effort into reverting those changes before you can work on applying your fix "
"to what is in production. All you have to do is switch back to your master "
"branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:142
msgid ""
"However, before you do that, note that if your working directory or staging "
"area has uncommitted changes that conflict with the branch you’re checking "
"out, Git won’t let you switch branches. It’s best to have a clean working "
"state when you switch branches. There are ways to get around this (namely, "
"stashing and commit amending) that we’ll cover later. For now, you’ve "
"committed all your changes, so you can switch back to your master branch:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:144
msgid ""
"\t$ git checkout master\n"
"\tSwitched to branch \"master\""
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:147
msgid ""
"At this point, your project working directory is exactly the way it was "
"before you started working on issue #53, and you can concentrate on your "
"hotfix. This is an important point to remember: Git resets your working "
"directory to look like the snapshot of the commit that the branch you check "
"out points to. It adds, removes, and modifies files automatically to make "
"sure your working copy is what the branch looked like on your last commit to "
"it."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:149
msgid ""
"Next, you have a hotfix to make. Let’s create a hotfix branch on which to "
"work until it’s completed (see Figure 3-13):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:151
msgid ""
"\t$ git checkout -b hotfix\n"
"\tSwitched to a new branch \"hotfix\"\n"
"\t$ vim index.html\n"
"\t$ git commit -a -m 'fixed the broken email address'\n"
"\t[hotfix]: created 3a0874c: \"fixed the broken email address\"\n"
"\t 1 files changed, 0 insertions(+), 1 deletions(-)"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:158
msgid ""
"Insert 18333fig0313.png\n"
"Figure 3-13. hotfix branch based back at your master branch point."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:161
msgid ""
"You can run your tests, make sure the hotfix is what you want, and merge it "
"back into your master branch to deploy to production. You do this with the "
"`git merge` command:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:163
msgid ""
"\t$ git checkout master\n"
"\t$ git merge hotfix\n"
"\tUpdating f42c576..3a0874c\n"
"\tFast forward\n"
"\t README |    1 -\n"
"\t 1 files changed, 0 insertions(+), 1 deletions(-)"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:170
msgid ""
"You’ll notice the phrase \"Fast forward\" in that merge. Because the commit "
"pointed to by the branch you merged in was directly upstream of the commit "
"you’re on, Git moves the pointer forward. To phrase that another way, when "
"you try to merge one commit with a commit that can be reached by following "
"the first commit’s history, Git simplifies things by moving the pointer "
"forward because there is no divergent work to merge together — this is "
"called a \"fast forward\"."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:172
msgid ""
"Your change is now in the snapshot of the commit pointed to by the `master` "
"branch, and you can deploy your change (see Figure 3-14)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:174
msgid ""
"Insert 18333fig0314.png\n"
"Figure 3-14. Your master branch points to the same place as your hotfix "
"branch after the merge."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:177
msgid ""
"After your super-important fix is deployed, you’re ready to switch back to "
"the work you were doing before you were interrupted. However, first you’ll "
"delete the `hotfix` branch, because you no longer need it — the `master` "
"branch points at the same place. You can delete it with the `-d` option to "
"`git branch`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:179
msgid ""
"\t$ git branch -d hotfix\n"
"\tDeleted branch hotfix (3a0874c)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:182
msgid ""
"Now you can switch back to your work-in-progress branch on issue #53 and "
"continue working on it (see Figure 3-15):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:184
msgid ""
"\t$ git checkout iss53\n"
"\tSwitched to branch \"iss53\"\n"
"\t$ vim index.html\n"
"\t$ git commit -a -m 'finished the new footer [issue 53]'\n"
"\t[iss53]: created ad82d7a: \"finished the new footer [issue 53]\"\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:191
msgid ""
"Insert 18333fig0315.png\n"
"Figure 3-15. Your iss53 branch can move forward independently."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:194
msgid ""
"It’s worth noting here that the work you did in your `hotfix` branch is not "
"contained in the files in your `iss53` branch. If you need to pull it in, "
"you can merge your `master` branch into your `iss53` branch by running `git "
"merge master`, or you can wait to integrate those changes until you decide "
"to pull the `iss53` branch back into `master` later."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:196
msgid "### Basic Merging ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:198
msgid ""
"Suppose you’ve decided that your issue #53 work is complete and ready to be "
"merged into your `master` branch. In order to do that, you’ll merge in your "
"`iss53` branch, much like you merged in your `hotfix` branch earlier. All "
"you have to do is check out the branch you wish to merge into and then run "
"the `git merge` command:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:200
msgid ""
"\t$ git checkout master\n"
"\t$ git merge iss53\n"
"\tMerge made by recursive.\n"
"\t README |    1 +\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:206
msgid ""
"This looks a bit different than the `hotfix` merge you did earlier. In this "
"case, your development history has diverged from some older point. Because "
"the commit on the branch you’re on isn’t a direct ancestor of the branch "
"you’re merging in, Git has to do some work. In this case, Git does a simple "
"three-way merge, using the two snapshots pointed to by the branch tips and "
"the common ancestor of the two. Figure 3-16 highlights the three snapshots "
"that Git uses to do its merge in this case."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:208
msgid ""
"Insert 18333fig0316.png\n"
"Figure 3-16. Git automatically identifies the best common-ancestor merge "
"base for branch merging."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:211
msgid ""
"Instead of just moving the branch pointer forward, Git creates a new "
"snapshot that results from this three-way merge and automatically creates a "
"new commit that points to it (see Figure 3-17). This is referred to as a "
"merge commit and is special in that it has more than one parent."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:213
msgid ""
"It’s worth pointing out that Git determines the best common ancestor to use "
"for its merge base; this is different than CVS or Subversion (before version "
"1.5), where the developer doing the merge has to figure out the best merge "
"base for themselves. This makes merging a heck of a lot easier in Git than "
"in these other systems."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:215
msgid ""
"Insert 18333fig0317.png\n"
"Figure 3-17. Git automatically creates a new commit object that contains the "
"merged work."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:218
msgid ""
"Now that your work is merged in, you have no further need for the `iss53` "
"branch. You can delete it and then manually close the ticket in your ticket-"
"tracking system:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:220
msgid "\t$ git branch -d iss53"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:222
msgid "### Basic Merge Conflicts ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:224
msgid ""
"Occasionally, this process doesn’t go smoothly. If you changed the same part "
"of the same file differently in the two branches you’re merging together, "
"Git won’t be able to merge them cleanly. If your fix for issue #53 modified "
"the same part of a file as the `hotfix`, you’ll get a merge conflict that "
"looks something like this:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:226
msgid ""
"\t$ git merge iss53\n"
"\tAuto-merging index.html\n"
"\tCONFLICT (content): Merge conflict in index.html\n"
"\tAutomatic merge failed; fix conflicts and then commit the result."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:231
msgid ""
"Git hasn’t automatically created a new merge commit. It has paused the "
"process while you resolve the conflict. If you want to see which files are "
"unmerged at any point after a merge conflict, you can run `git status`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:233
msgid ""
"\t[master*]$ git status\n"
"\tindex.html: needs merge\n"
"\t# On branch master\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#   (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
"\t#\n"
"\t#\tunmerged:   index.html\n"
"\t#"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:243
msgid ""
"Anything that has merge conflicts and hasn’t been resolved is listed as "
"unmerged. Git adds standard conflict-resolution markers to the files that "
"have conflicts, so you can open them manually and resolve those conflicts. "
"Your file contains a section that looks something like this:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:245
msgid ""
"\t<<<<<<< HEAD:index.html\n"
"\t<div id=\"footer\">contact : email.support@github.com</div>\n"
"\t=======\n"
"\t<div id=\"footer\">\n"
"\t  please contact us at support@github.com\n"
"\t</div>\n"
"\t>>>>>>> iss53:index.html"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:253
msgid ""
"This means the version in HEAD (your master branch, because that was what "
"you had checked out when you ran your merge command) is the top part of that "
"block (everything above the `=======`), while the version in your `iss53` "
"branch looks like everything in the bottom part. In order to resolve the "
"conflict, you have to either choose one side or the other or merge the "
"contents yourself. For instance, you might resolve this conflict by "
"replacing the entire block with this:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:255
msgid ""
"\t<div id=\"footer\">\n"
"\tplease contact us at email.support@github.com\n"
"\t</div>"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:259
msgid ""
"This resolution has a little of each section, and I’ve fully removed the "
"`<<<<<<<`, `=======`, and `>>>>>>>` lines. After you’ve resolved each of "
"these sections in each conflicted file, run `git add` on each file to mark "
"it as resolved. Staging the file marks it as resolved in Git.\n"
"If you want to use a graphical tool to resolve these issues, you can run "
"`git mergetool`, which fires up an appropriate visual merge tool and walks "
"you through the conflicts:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:262
msgid ""
"\t$ git mergetool\n"
"\tmerge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge "
"vimdiff\n"
"\tMerging the files: index.html"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:266
msgid ""
"\tNormal merge conflict for 'index.html':\n"
"\t  {local}: modified\n"
"\t  {remote}: modified\n"
"\tHit return to start merge resolution tool (opendiff):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:271
msgid ""
"If you want to use a merge tool other than the default (Git chose `opendiff` "
"for me in this case because I ran the command on a Mac), you can see all the "
"supported tools listed at the top after “merge tool candidates”. Type the "
"name of the tool you’d rather use. In Chapter 7, we’ll discuss how you can "
"change this default value for your environment."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:273
msgid ""
"After you exit the merge tool, Git asks you if the merge was successful. If "
"you tell the script that it was, it stages the file to mark it as resolved "
"for you."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:275
msgid ""
"You can run `git status` again to verify that all conflicts have been "
"resolved:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:277
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#\tmodified:   index.html\n"
"\t#"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:285
msgid ""
"If you’re happy with that, and you verify that everything that had conflicts "
"has been staged, you can type `git commit` to finalize the merge commit. The "
"commit message by default looks something like this:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:287
msgid "\tMerge branch 'iss53'"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:289
msgid ""
"\tConflicts:\n"
"\t  index.html\n"
"\t#\n"
"\t# It looks like you may be committing a MERGE.\n"
"\t# If this is not correct, please remove the file\n"
"\t# .git/MERGE_HEAD\n"
"\t# and try again.\n"
"\t#"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:298
msgid ""
"You can modify that message with details about how you resolved the merge if "
"you think it would be helpful to others looking at this merge in the future "
"— why you did what you did, if it’s not obvious."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:300
msgid "## Branch Management ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:302
msgid ""
"Now that you’ve created, merged, and deleted some branches, let’s look at "
"some branch-management tools that will come in handy when you begin using "
"branches all the time."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:304
msgid ""
"The `git branch` command does more than just create and delete branches. If "
"you run it with no arguments, you get a simple listing of your current "
"branches:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:306
msgid ""
"\t$ git branch\n"
"\t  iss53\n"
"\t* master\n"
"\t  testing"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:311
msgid ""
"Notice the `*` character that prefixes the `master` branch: it indicates the "
"branch that you currently have checked out. This means that if you commit at "
"this point, the `master` branch will be moved forward with your new work. To "
"see the last commit on each branch, you can run `git branch -v`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:313
msgid ""
"\t$ git branch -v\n"
"\t  iss53   93b412c fix javascript issue\n"
"\t* master  7a98805 Merge branch 'iss53'\n"
"\t  testing 782fd34 add scott to the author list in the readmes"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:318
msgid ""
"Another useful option to figure out what state your branches are in is to "
"filter this list to branches that you have or have not yet merged into the "
"branch you’re currently on. The useful `--merged` and `--no-merged` options "
"have been available in Git since version 1.5.6 for this purpose. To see "
"which branches are already merged into the branch you’re on, you can run "
"`git branch --merged`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:320
msgid ""
"\t$ git branch --merged\n"
"\t  iss53\n"
"\t* master"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:324
msgid ""
"Because you already merged in `iss53` earlier, you see it in your list. "
"Branches on this list without the `*` in front of them are generally fine to "
"delete with `git branch -d`; you’ve already incorporated their work into "
"another branch, so you’re not going to lose anything."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:326
msgid ""
"To see all the branches that contain work you haven’t yet merged in, you can "
"run `git branch --no-merged`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:328
msgid ""
"\t$ git branch --no-merged\n"
"\t  testing"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:331
msgid ""
"This shows your other branch. Because it contains work that isn’t merged in "
"yet, trying to delete it with `git branch -d` will fail:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:333
msgid ""
"\t$ git branch -d testing\n"
"\terror: The branch 'testing' is not an ancestor of your current HEAD.\n"
"\tIf you are sure you want to delete it, run 'git branch -D testing'."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:337
msgid ""
"If you really do want to delete the branch and lose that work, you can force "
"it with `-D`, as the helpful message points out."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:339
msgid "## Branching Workflows ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:341
msgid ""
"Now that you have the basics of branching and merging down, what can or "
"should you do with them? In this section, we’ll cover some common workflows "
"that this lightweight branching makes possible, so you can decide if you "
"would like to incorporate it into your own development cycle."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:343
msgid "### Long-Running Branches ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:345
msgid ""
"Because Git uses a simple three-way merge, merging from one branch into "
"another multiple times over a long period is generally easy to do. This "
"means you can have several branches that are always open and that you use "
"for different stages of your development cycle; you can merge regularly from "
"some of them into others."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:347
msgid ""
"Many Git developers have a workflow that embraces this approach, such as "
"having only code that is entirely stable in their `master` branch — possibly "
"only code that has been or will be released. They have another parallel "
"branch named develop or next that they work from or use to test stability — "
"it isn’t necessarily always stable, but whenever it gets to a stable state, "
"it can be merged into `master`. It’s used to pull in topic branches (short-"
"lived branches, like your earlier `iss53` branch) when they’re ready, to "
"make sure they pass all the tests and don’t introduce bugs."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:349
msgid ""
"In reality, we’re talking about pointers moving up the line of commits "
"you’re making. The stable branches are farther down the line in your commit "
"history, and the bleeding-edge branches are farther up the history (see "
"Figure 3-18)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:351
msgid ""
"Insert 18333fig0318.png\n"
"Figure 3-18. More stable branches are generally farther down the commit "
"history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:354
msgid ""
"It’s generally easier to think about them as work silos, where sets of "
"commits graduate to a more stable silo when they’re fully tested (see Figure "
"3-19)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:356
msgid ""
"Insert 18333fig0319.png\n"
"Figure 3-19. It may be helpful to think of your branches as silos."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:359
msgid ""
"You can keep doing this for several levels of stability. Some larger "
"projects also have a `proposed` or `pu` (proposed updates) branch that has "
"integrated branches that may not be ready to go into the `next` or `master` "
"branch. The idea is that your branches are at various levels of stability; "
"when they reach a more stable level, they’re merged into the branch above "
"them.\n"
"Again, having multiple long-running branches isn’t necessary, but it’s often "
"helpful, especially when you’re dealing with very large or complex projects."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:362
msgid "### Topic Branches ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:364
msgid ""
"Topic branches, however, are useful in projects of any size. A topic branch "
"is a short-lived branch that you create and use for a single particular "
"feature or related work. This is something you’ve likely never done with a "
"VCS before because it’s generally too expensive to create and merge "
"branches. But in Git it’s common to create, work on, merge, and delete "
"branches several times a day."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:366
msgid ""
"You saw this in the last section with the `iss53` and `hotfix` branches you "
"created. You did a few commits on them and deleted them directly after "
"merging them into your main branch. This technique allows you to context-"
"switch quickly and completely — because your work is separated into silos "
"where all the changes in that branch have to do with that topic, it’s easier "
"to see what has happened during code review and such. You can keep the "
"changes there for minutes, days, or months, and merge them in when they’re "
"ready, regardless of the order in which they were created or worked on."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:368
msgid ""
"Consider an example of doing some work (on `master`), branching off for an "
"issue (`iss91`), working on it for a bit, branching off the second branch to "
"try another way of handling the same thing (`iss91v2`), going back to your "
"master branch and working there for a while, and then branching off there to "
"do some work that you’re not sure is a good idea (`dumbidea` branch). Your "
"commit history will look something like Figure 3-20."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:370
msgid ""
"Insert 18333fig0320.png\n"
"Figure 3-20. Your commit history with multiple topic branches."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:373
msgid ""
"Now, let’s say you decide you like the second solution to your issue best "
"(`iss91v2`); and you showed the `dumbidea` branch to your coworkers, and it "
"turns out to be genius. You can throw away the original `iss91` branch "
"(losing commits C5 and C6) and merge in the other two. Your history then "
"looks like Figure 3-21."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:375
msgid ""
"Insert 18333fig0321.png\n"
"Figure 3-21. Your history after merging in dumbidea and iss91v2."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:378
msgid ""
"It’s important to remember when you’re doing all this that these branches "
"are completely local. When you’re branching and merging, everything is being "
"done only in your Git repository — no server communication is happening."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:380
msgid "## Remote Branches ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:382
msgid ""
"Remote branches are references to the state of branches on your remote "
"repositories. They’re local branches that you can’t move; they’re moved "
"automatically whenever you do any network communication. Remote branches act "
"as bookmarks to remind you where the branches on your remote repositories "
"were the last time you connected to them."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:384
msgid ""
"They take the form `(remote)/(branch)`. For instance, if you wanted to see "
"what the `master` branch on your `origin` remote looked like as of the last "
"time you communicated with it, you would check the `origin/master` branch. "
"If you were working on an issue with a partner and they pushed up an `iss53` "
"branch, you might have your own local `iss53` branch; but the branch on the "
"server would point to the commit at `origin/iss53`."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:386
msgid ""
"This may be a bit confusing, so let’s look at an example. Let’s say you have "
"a Git server on your network at `git.ourcompany.com`. If you clone from "
"this, Git automatically names it `origin` for you, pulls down all its data, "
"creates a pointer to where its `master` branch is, and names it `origin/"
"master` locally; and you can’t move it. Git also gives you your own `master` "
"branch starting at the same place as origin’s `master` branch, so you have "
"something to work from (see Figure 3-22)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:388
msgid ""
"Insert 18333fig0322.png\n"
"Figure 3-22. A Git clone gives you your own master branch and origin/master "
"pointing to origin’s master branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:391
msgid ""
"If you do some work on your local master branch, and, in the meantime, "
"someone else pushes to `git.ourcompany.com` and updates its master branch, "
"then your histories move forward differently. Also, as long as you stay out "
"of contact with your origin server, your `origin/master` pointer doesn’t "
"move (see Figure 3-23)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:393
msgid ""
"Insert 18333fig0323.png\n"
"Figure 3-23. Working locally and having someone push to your remote server "
"makes each history move forward differently."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:396
msgid ""
"To synchronize your work, you run a `git fetch origin` command. This command "
"looks up which server origin is (in this case, it’s `git.ourcompany.com`), "
"fetches any data from it that you don’t yet have, and updates your local "
"database, moving your `origin/master` pointer to its new, more up-to-date "
"position (see Figure 3-24)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:398
msgid ""
"Insert 18333fig0324.png\n"
"Figure 3-24. The git fetch command updates your remote references."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:401
msgid ""
"To demonstrate having multiple remote servers and what remote branches for "
"those remote projects look like, let’s assume you have another internal Git "
"server that is used only for development by one of your sprint teams. This "
"server is at `git.team1.ourcompany.com`. You can add it as a new remote "
"reference to the project you’re currently working on by running the `git "
"remote add` command as we covered in Chapter 2. Name this remote `teamone`, "
"which will be your shortname for that whole URL (see Figure 3-25)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:403
msgid ""
"Insert 18333fig0325.png\n"
"Figure 3-25. Adding another server as a remote."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:406
msgid ""
"Now, you can run `git fetch teamone` to fetch everything the remote "
"`teamone` server has that you don’t have yet. Because that server has a "
"subset of the data your `origin` server has right now, Git fetches no data "
"but sets a remote branch called `teamone/master` to point to the commit that "
"`teamone` has as its `master` branch (see Figure 3-26)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:408
msgid ""
"Insert 18333fig0326.png\n"
"Figure 3-26. You get a reference to teamone’s master branch position locally."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:411
msgid "### Pushing ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:413
msgid ""
"When you want to share a branch with the world, you need to push it up to a "
"remote that you have write access to. Your local branches aren’t "
"automatically synchronized to the remotes you write to — you have to "
"explicitly push the branches you want to share. That way, you can use "
"private branches for work you don’t want to share, and push up only the "
"topic branches you want to collaborate on."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:415
msgid ""
"If you have a branch named `serverfix` that you want to work on with others, "
"you can push it up the same way you pushed your first branch. Run `git push "
"(remote) (branch)`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:417
msgid ""
"\t$ git push origin serverfix\n"
"\tCounting objects: 20, done.\n"
"\tCompressing objects: 100% (14/14), done.\n"
"\tWriting objects: 100% (15/15), 1.74 KiB, done.\n"
"\tTotal 15 (delta 5), reused 0 (delta 0)\n"
"\tTo git@github.com:schacon/simplegit.git\n"
"\t * [new branch]      serverfix -> serverfix"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:425
msgid ""
"This is a bit of a shortcut. Git automatically expands the `serverfix` "
"branchname out to `refs/heads/serverfix:refs/heads/serverfix`, which means, "
"“Take my serverfix local branch and push it to update the remote’s serverfix "
"branch.” We’ll go over the `refs/heads/` part in detail in Chapter 9, but "
"you can generally leave it off. You can also do `git push origin serverfix:"
"serverfix`, which does the same thing — it says, “Take my serverfix and make "
"it the remote’s serverfix.” You can use this format to push a local branch "
"into a remote branch that is named differently. If you didn’t want it to be "
"called `serverfix` on the remote, you could instead run `git push origin "
"serverfix:awesomebranch` to push your local `serverfix` branch to the "
"`awesomebranch` branch on the remote project."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:427
msgid ""
"The next time one of your collaborators fetches from the server, they will "
"get a reference to where the server’s version of `serverfix` is under the "
"remote branch `origin/serverfix`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:429
msgid ""
"\t$ git fetch origin\n"
"\tremote: Counting objects: 20, done.\n"
"\tremote: Compressing objects: 100% (14/14), done.\n"
"\tremote: Total 15 (delta 5), reused 0 (delta 0)\n"
"\tUnpacking objects: 100% (15/15), done.\n"
"\tFrom git@github.com:schacon/simplegit\n"
"\t * [new branch]      serverfix    -> origin/serverfix"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:437
msgid ""
"It’s important to note that when you do a fetch that brings down new remote "
"branches, you don’t automatically have local, editable copies of them. In "
"other words, in this case, you don’t have a new `serverfix` branch — you "
"only have an `origin/serverfix` pointer that you can’t modify."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:439
msgid ""
"To merge this work into your current working branch, you can run `git merge "
"origin/serverfix`. If you want your own `serverfix` branch that you can work "
"on, you can base it off your remote branch:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:441
msgid ""
"\t$ git checkout -b serverfix origin/serverfix\n"
"\tBranch serverfix set up to track remote branch refs/remotes/origin/"
"serverfix.\n"
"\tSwitched to a new branch \"serverfix\""
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:445
msgid ""
"This gives you a local branch that you can work on that starts where `origin/"
"serverfix` is."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:447
msgid "### Tracking Branches ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:449
msgid ""
"Checking out a local branch from a remote branch automatically creates what "
"is called a _tracking branch_. Tracking branches are local branches that "
"have a direct relationship to a remote branch. If you’re on a tracking "
"branch and type `git push`, Git automatically knows which server and branch "
"to push to. Also, running `git pull` while on one of these branches fetches "
"all the remote references and then automatically merges in the corresponding "
"remote branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:451
msgid ""
"When you clone a repository, it generally automatically creates a `master` "
"branch that tracks `origin/master`. That’s why `git push` and `git pull` "
"work out of the box with no other arguments. However, you can set up other "
"tracking branches if you wish — ones that don’t track branches on `origin` "
"and don’t track the `master` branch. The simple case is the example you just "
"saw, running `git checkout -b [branch] [remotename]/[branch]`. If you have "
"Git version 1.6.2 or later, you can also use the `--track` shorthand:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:453
msgid ""
"\t$ git checkout --track origin/serverfix\n"
"\tBranch serverfix set up to track remote branch refs/remotes/origin/"
"serverfix.\n"
"\tSwitched to a new branch \"serverfix\""
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:457
msgid ""
"To set up a local branch with a different name than the remote branch, you "
"can easily use the first version with a different local branch name:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:459
msgid ""
"\t$ git checkout -b sf origin/serverfix\n"
"\tBranch sf set up to track remote branch refs/remotes/origin/serverfix.\n"
"\tSwitched to a new branch \"sf\""
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:463
msgid ""
"Now, your local branch sf will automatically push to and pull from origin/"
"serverfix."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:465
msgid "### Deleting Remote Branches ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:467
msgid ""
"Suppose you’re done with a remote branch — say, you and your collaborators "
"are finished with a feature and have merged it into your remote’s `master` "
"branch (or whatever branch your stable codeline is in). You can delete a "
"remote branch using the rather obtuse syntax `git push [remotename] :[branch]"
"`. If you want to delete your `serverfix` branch from the server, you run "
"the following:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:469
msgid ""
"\t$ git push origin :serverfix\n"
"\tTo git@github.com:schacon/simplegit.git\n"
"\t - [deleted]         serverfix"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:473
msgid ""
"Boom. No more branch on your server. You may want to dog-ear this page, "
"because you’ll need that command, and you’ll likely forget the syntax. A way "
"to remember this command is by recalling the `git push [remotename] "
"[localbranch]:[remotebranch]` syntax that we went over a bit earlier. If you "
"leave off the `[localbranch]` portion, then you’re basically saying, “Take "
"nothing on my side and make it be `[remotebranch]`.”"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:475
msgid "## Rebasing ##"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:477
msgid ""
"In Git, there are two main ways to integrate changes from one branch into "
"another: the `merge` and the `rebase`. In this section you’ll learn what "
"rebasing is, how to do it, why it’s a pretty amazing tool, and in what cases "
"you won’t want to use it."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:479
msgid "### The Basic Rebase ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:481
msgid ""
"If you go back to an earlier example from the Merge section (see Figure "
"3-27), you can see that you diverged your work and made commits on two "
"different branches."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:483
msgid ""
"Insert 18333fig0327.png\n"
"Figure 3-27. Your initial diverged commit history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:486
msgid ""
"The easiest way to integrate the branches, as we’ve already covered, is the "
"`merge` command. It performs a three-way merge between the two latest branch "
"snapshots (C3 and C4) and the most recent common ancestor of the two (C2), "
"creating a new snapshot (and commit), as shown in Figure 3-28."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:488
msgid ""
"Insert 18333fig0328.png\n"
"Figure 3-28. Merging a branch to integrate the diverged work history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:491
msgid ""
"However, there is another way: you can take the patch of the change that was "
"introduced in C3 and reapply it on top of C4. In Git, this is called "
"_rebasing_. With the `rebase` command, you can take all the changes that "
"were committed on one branch and replay them on another one."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:493
msgid "In this example, you’d run the following:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:495
msgid ""
"\t$ git checkout experiment\n"
"\t$ git rebase master\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tApplying: added staged command"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:500
msgid ""
"It works by going to the common ancestor of the two branches (the one you’re "
"on and the one you’re rebasing onto), getting the diff introduced by each "
"commit of the branch you’re on, saving those diffs to temporary files, "
"resetting the current branch to the same commit as the branch you are "
"rebasing onto, and finally applying each change in turn. Figure 3-29 "
"illustrates this process."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:502
msgid ""
"Insert 18333fig0329.png\n"
"Figure 3-29. Rebasing the change introduced in C3 onto C4."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:505
msgid ""
"At this point, you can go back to the master branch and do a fast-forward "
"merge (see Figure 3-30)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:507
msgid ""
"Insert 18333fig0330.png\n"
"Figure 3-30. Fast-forwarding the master branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:510
msgid ""
"Now, the snapshot pointed to by C3' is exactly the same as the one that was "
"pointed to by C5 in the merge example. There is no difference in the end "
"product of the integration, but rebasing makes for a cleaner history. If you "
"examine the log of a rebased branch, it looks like a linear history: it "
"appears that all the work happened in series, even when it originally "
"happened in parallel."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:512
msgid ""
"Often, you’ll do this to make sure your commits apply cleanly on a remote "
"branch — perhaps in a project to which you’re trying to contribute but that "
"you don’t maintain. In this case, you’d do your work in a branch and then "
"rebase your work onto `origin/master` when you were ready to submit your "
"patches to the main project. That way, the maintainer doesn’t have to do any "
"integration work — just a fast-forward or a clean apply."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:514
msgid ""
"Note that the snapshot pointed to by the final commit you end up with, "
"whether it’s the last of the rebased commits for a rebase or the final merge "
"commit after a merge, is the same snapshot — it’s only the history that is "
"different. Rebasing replays changes from one line of work onto another in "
"the order they were introduced, whereas merging takes the endpoints and "
"merges them together."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:516
msgid "### More Interesting Rebases ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:518
msgid ""
"You can also have your rebase replay on something other than the rebase "
"branch. Take a history like Figure 3-31, for example. You branched a topic "
"branch (`server`) to add some server-side functionality to your project, and "
"made a commit. Then, you branched off that to make the client-side changes "
"(`client`) and committed a few times. Finally, you went back to your server "
"branch and did a few more commits."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:520
msgid ""
"Insert 18333fig0331.png\n"
"Figure 3-31. A history with a topic branch off another topic branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:523
msgid ""
"Suppose you decide that you want to merge your client-side changes into your "
"mainline for a release, but you want to hold off on the server-side changes "
"until it’s tested further. You can take the changes on client that aren’t on "
"server (C8 and C9) and replay them on your master branch by using the `--"
"onto` option of `git rebase`:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:525
msgid "\t$ git rebase --onto master server client"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:527
msgid ""
"This basically says, “Check out the client branch, figure out the patches "
"from the common ancestor of the `client` and `server` branches, and then "
"replay them onto `master`.” It’s a bit complex; but the result, shown in "
"Figure 3-32, is pretty cool."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:529
msgid ""
"Insert 18333fig0332.png\n"
"Figure 3-32. Rebasing a topic branch off another topic branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:532
msgid "Now you can fast-forward your master branch (see Figure 3-33):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:534
msgid ""
"\t$ git checkout master\n"
"\t$ git merge client"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:537
msgid ""
"Insert 18333fig0333.png\n"
"Figure 3-33. Fast-forwarding your master branch to include the client branch "
"changes."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:540
msgid ""
"Let’s say you decide to pull in your server branch as well. You can rebase "
"the server branch onto the master branch without having to check it out "
"first by running `git rebase [basebranch] [topicbranch]` — which checks out "
"the topic branch (in this case, `server`) for you and replays it onto the "
"base branch (`master`):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:542
msgid "\t$ git rebase master server"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:544
msgid ""
"This replays your `server` work on top of your `master` work, as shown in "
"Figure 3-34."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:546
msgid ""
"Insert 18333fig0334.png\n"
"Figure 3-34. Rebasing your server branch on top of your master branch."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:549
msgid "Then, you can fast-forward the base branch (`master`):"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:551
msgid ""
"\t$ git checkout master\n"
"\t$ git merge server"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:554
msgid ""
"You can remove the `client` and `server` branches because all the work is "
"integrated and you don’t need them anymore, leaving your history for this "
"entire process looking like Figure 3-35:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:556
msgid ""
"\t$ git branch -d client\n"
"\t$ git branch -d server"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:559
msgid ""
"Insert 18333fig0335.png\n"
"Figure 3-35. Final commit history."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:562
msgid "### The Perils of Rebasing ###"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:564
msgid ""
"Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be "
"summed up in a single line:"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:566
msgid "**Do not rebase commits that you have pushed to a public repository.**"
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:568
msgid ""
"If you follow that guideline, you’ll be fine. If you don’t, people will hate "
"you, and you’ll be scorned by friends and family."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:570
msgid ""
"When you rebase stuff, you’re abandoning existing commits and creating new "
"ones that are similar but different. If you push commits somewhere and "
"others pull them down and base work on them, and then you rewrite those "
"commits with `git rebase` and push them up again, your collaborators will "
"have to re-merge their work and things will get messy when you try to pull "
"their work back into yours."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:572
msgid ""
"Let’s look at an example of how rebasing work that you’ve made public can "
"cause problems. Suppose you clone from a central server and then do some "
"work off that. Your commit history looks like Figure 3-36."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:574
msgid ""
"Insert 18333fig0336.png\n"
"Figure 3-36. Clone a repository, and base some work on it."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:577
msgid ""
"Now, someone else does more work that includes a merge, and pushes that work "
"to the central server. You fetch them and merge the new remote branch into "
"your work, making your history look something like Figure 3-37."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:579
msgid ""
"Insert 18333fig0337.png\n"
"Figure 3-37. Fetch more commits, and merge them into your work."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:582
msgid ""
"Next, the person who pushed the merged work decides to go back and rebase "
"their work instead; they do a `git push --force` to overwrite the history on "
"the server. You then fetch from that server, bringing down the new commits."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:584
msgid ""
"Insert 18333fig0338.png\n"
"Figure 3-38. Someone pushes rebased commits, abandoning commits you’ve based "
"your work on."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:587
msgid ""
"At this point, you have to merge this work in again, even though you’ve "
"already done so. Rebasing changes the SHA-1 hashes of these commits so to "
"Git they look like new commits, when in fact you already have the C4 work in "
"your history (see Figure 3-39)."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:589
msgid ""
"Insert 18333fig0339.png\n"
"Figure 3-39. You merge in the same work again into a new merge commit."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:592
msgid ""
"You have to merge that work in at some point so you can keep up with the "
"other developer in the future. After you do that, your commit history will "
"contain both the C4 and C4' commits, which have different SHA-1 hashes but "
"introduce the same work and have the same commit message. If you run a `git "
"log` when your history looks like this, you’ll see two commits that have the "
"same author date and message, which will be confusing. Furthermore, if you "
"push this history back up to the server, you’ll reintroduce all those "
"rebased commits to the central server, which can further confuse people."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:594
msgid ""
"If you treat rebasing as a way to clean up and work with commits before you "
"push them, and if you only rebase commits that have never been available "
"publicly, then you’ll be fine. If you rebase commits that have already been "
"pushed publicly, and people may have based work on those commits, then you "
"may be in for some frustrating trouble."
msgstr ""

#: en/03-git-branching/01-chapter3.markdown:598
msgid ""
"We’ve covered basic branching and merging in Git. You should feel "
"comfortable creating and switching to new branches, switching between "
"branches and merging local branches together.  You should also be able to "
"share your branches by pushing them to a shared server, working with others "
"on shared branches and rebasing your branches before they are shared."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:1
msgid "# Git on the Server #"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:3
msgid ""
"At this point, you should be able to do most of the day-to-day tasks for "
"which you’ll be using Git. However, in order to do any collaboration in Git, "
"you’ll need to have a remote Git repository. Although you can technically "
"push changes to and pull changes from individuals’ repositories, doing so is "
"discouraged because you can fairly easily confuse what they’re working on if "
"you’re not careful. Furthermore, you want your collaborators to be able to "
"access the repository even if your computer is offline — having a more "
"reliable common repository is often useful. Therefore, the preferred method "
"for collaborating with someone is to set up an intermediate repository that "
"you both have access to, and push to and pull from that. We’ll refer to this "
"repository as a \"Git server\"; but you’ll notice that it generally takes a "
"tiny amount of resources to host a Git repository, so you’ll rarely need to "
"use an entire server for it."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:5
msgid ""
"Running a Git server is simple. First, you choose which protocols you want "
"your server to communicate with. The first section of this chapter will "
"cover the available protocols and the pros and cons of each. The next "
"sections will explain some typical setups using those protocols and how to "
"get your server running with them. Last, we’ll go over a few hosted options, "
"if you don’t mind hosting your code on someone else’s server and don’t want "
"to go through the hassle of setting up and maintaining your own server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:7
msgid ""
"If you have no interest in running your own server, you can skip to the last "
"section of the chapter to see some options for setting up a hosted account "
"and then move on to the next chapter, where we discuss the various ins and "
"outs of working in a distributed source control environment."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:9
msgid ""
"A remote repository is generally a _bare repository_ — a Git repository that "
"has no working directory. Because the repository is only used as a "
"collaboration point, there is no reason to have a snapshot checked out on "
"disk; it’s just the Git data. In the simplest terms, a bare repository is "
"the contents of your project’s `.git` directory and nothing else."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:11
msgid "## The Protocols ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:13
msgid ""
"Git can use four major network protocols to transfer data: Local, Secure "
"Shell (SSH), Git, and HTTP. Here we’ll discuss what they are and in what "
"basic circumstances you would want (or not want) to use them."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:15
msgid ""
"It’s important to note that with the exception of the HTTP protocols, all of "
"these require Git to be installed and working on the server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:17
msgid "### Local Protocol ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:19
msgid ""
"The most basic is the _Local protocol_, in which the remote repository is in "
"another directory on disk. This is often used if everyone on your team has "
"access to a shared filesystem such as an NFS mount, or in the less likely "
"case that everyone logs in to the same computer. The latter wouldn’t be "
"ideal, because all your code repository instances would reside on the same "
"computer, making a catastrophic loss much more likely."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:21
msgid ""
"If you have a shared mounted filesystem, then you can clone, push to, and "
"pull from a local file-based repository. To clone a repository like this or "
"to add one as a remote to an existing project, use the path to the "
"repository as the URL. For example, to clone a local repository, you can run "
"something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:23
msgid "\t$ git clone /opt/git/project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:25
msgid "Or you can do this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:27
msgid "\t$ git clone file:///opt/git/project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:29
msgid ""
"Git operates slightly differently if you explicitly specify `file://` at the "
"beginning of the URL. If you just specify the path, Git tries to use "
"hardlinks or directly copy the files it needs. If you specify `file://`, Git "
"fires up the processes that it normally uses to transfer data over a network "
"which is generally a lot less efficient method of transferring the data. The "
"main reason to specify the `file://` prefix is if you want a clean copy of "
"the repository with extraneous references or objects left out — generally "
"after an import from another version-control system or something similar "
"(see Chapter 9 for maintenance tasks). We’ll use the normal path here "
"because doing so is almost always faster."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:31
msgid ""
"To add a local repository to an existing Git project, you can run something "
"like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:33
msgid "\t$ git remote add local_proj /opt/git/project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:35
msgid ""
"Then, you can push to and pull from that remote as though you were doing so "
"over a network."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:37
msgctxt "en/04-git-server/01-chapter4.markdown:37"
msgid "#### The Pros ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:39
msgid ""
"The pros of file-based repositories are that they’re simple and they use "
"existing file permissions and network access. If you already have a shared "
"filesystem to which your whole team has access, setting up a repository is "
"very easy. You stick the bare repository copy somewhere everyone has shared "
"access to and set the read/write permissions as you would for any other "
"shared directory. We’ll discuss how to export a bare repository copy for "
"this purpose in the next section, “Getting Git on a Server.”"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:41
msgid ""
"This is also a nice option for quickly grabbing work from someone else’s "
"working repository. If you and a co-worker are working on the same project "
"and they want you to check something out, running a command like `git pull /"
"home/john/project` is often easier than them pushing to a remote server and "
"you pulling down."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:43
msgctxt "en/04-git-server/01-chapter4.markdown:43"
msgid "#### The Cons ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:45
msgid ""
"The cons of this method are that shared access is generally more difficult "
"to set up and reach from multiple locations than basic network access. If "
"you want to push from your laptop when you’re at home, you have to mount the "
"remote disk, which can be difficult and slow compared to network-based "
"access."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:47
msgid ""
"It’s also important to mention that this isn’t necessarily the fastest "
"option if you’re using a shared mount of some kind. A local repository is "
"fast only if you have fast access to the data. A repository on NFS is often "
"slower than the repository over SSH on the same server, allowing Git to run "
"off local disks on each system."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:49
msgid "### The SSH Protocol ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:51
msgid ""
"Probably the most common transport protocol for Git is SSH. This is because "
"SSH access to servers is already set up in most places — and if it isn’t, "
"it’s easy to do. SSH is also the only network-based protocol that you can "
"easily read from and write to. The other two network protocols (HTTP and "
"Git) are generally read-only, so even if you have them available for the "
"unwashed masses, you still need SSH for your own write commands. SSH is also "
"an authenticated network protocol; and because it’s ubiquitous, it’s "
"generally easy to set up and use."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:53
msgid ""
"To clone a Git repository over SSH, you can specify ssh:// URL like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:55
msgid "\t$ git clone ssh://user@server:project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:57
msgid ""
"Or you can not specify a protocol — Git assumes SSH if you aren’t explicit:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:59
msgid "\t$ git clone user@server:project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:61
msgid ""
"You can also not specify a user, and Git assumes the user you’re currently "
"logged in as."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:63
msgctxt "en/04-git-server/01-chapter4.markdown:63"
msgid "#### The Pros ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:65
msgid ""
"The pros of using SSH are many. First, you basically have to use it if you "
"want authenticated write access to your repository over a network. Second, "
"SSH is relatively easy to set up — SSH daemons are commonplace, many network "
"admins have experience with them, and many OS distributions are set up with "
"them or have tools to manage them. Next, access over SSH is secure — all "
"data transfer is encrypted and authenticated. Last, like the Git and Local "
"protocols, SSH is efficient, making the data as compact as possible before "
"transferring it."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:67
msgctxt "en/04-git-server/01-chapter4.markdown:67"
msgid "#### The Cons ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:69
msgid ""
"The negative aspect of SSH is that you can’t serve anonymous access of your "
"repository over it. People must have access to your machine over SSH to "
"access it, even in a read-only capacity, which doesn’t make SSH access "
"conducive to open source projects. If you’re using it only within your "
"corporate network, SSH may be the only protocol you need to deal with. If "
"you want to allow anonymous read-only access to your projects, you’ll have "
"to set up SSH for you to push over but something else for others to pull "
"over."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:71
msgid "### The Git Protocol ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:73
msgid ""
"Next is the Git protocol. This is a special daemon that comes packaged with "
"Git; it listens on a dedicated port (9418) that provides a service similar "
"to the SSH protocol, but with absolutely no authentication. In order for a "
"repository to be served over the Git protocol, you must create the `git-"
"export-daemon-ok` file — the daemon won’t serve a repository without that "
"file in it — but other than that there is no security. Either the Git "
"repository is available for everyone to clone or it isn’t. This means that "
"there is generally no pushing over this protocol. You can enable push "
"access; but given the lack of authentication, if you turn on push access, "
"anyone on the internet who finds your project’s URL could push to your "
"project. Suffice it to say that this is rare."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:75
msgctxt "en/04-git-server/01-chapter4.markdown:75"
msgid "#### The Pros ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:77
msgid ""
"The Git protocol is the fastest transfer protocol available. If you’re "
"serving a lot of traffic for a public project or serving a very large "
"project that doesn’t require user authentication for read access, it’s "
"likely that you’ll want to set up a Git daemon to serve your project. It "
"uses the same data-transfer mechanism as the SSH protocol but without the "
"encryption and authentication overhead."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:79
msgctxt "en/04-git-server/01-chapter4.markdown:79"
msgid "#### The Cons ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:81
msgid ""
"The downside of the Git protocol is the lack of authentication. It’s "
"generally undesirable for the Git protocol to be the only access to your "
"project. Generally, you’ll pair it with SSH access for the few developers "
"who have push (write) access and have everyone else use `git://` for read-"
"only access.\n"
"It’s also probably the most difficult protocol to set up. It must run its "
"own daemon, which is custom — we’ll look at setting one up in the “Gitosis” "
"section of this chapter — it requires `xinetd` configuration or the like, "
"which isn’t always a walk in the park. It also requires firewall access to "
"port 9418, which isn’t a standard port that corporate firewalls always "
"allow. Behind big corporate firewalls, this obscure port is commonly blocked."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:84
msgid "### The HTTP/S Protocol ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:86
msgid ""
"Last we have the HTTP protocol. The beauty of the HTTP or HTTPS protocol is "
"the simplicity of setting it up. Basically, all you have to do is put the "
"bare Git repository under your HTTP document root and set up a specific "
"`post-update` hook, and you’re done (See Chapter 7 for details on Git "
"hooks). At that point, anyone who can access the web server under which you "
"put the repository can also clone your repository. To allow read access to "
"your repository over HTTP, do something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:88
msgid ""
"\t$ cd /var/www/htdocs/\n"
"\t$ git clone --bare /path/to/git_project gitproject.git\n"
"\t$ cd gitproject.git\n"
"\t$ mv hooks/post-update.sample hooks/post-update\n"
"\t$ chmod a+x hooks/post-update"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:94
msgid ""
"That’s all. The `post-update` hook that comes with Git by default runs the "
"appropriate command (`git update-server-info`) to make HTTP fetching and "
"cloning work properly. This command is run when you push to this repository "
"over SSH; then, other people can clone via something like"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:96
msgid "\t$ git clone http://example.com/gitproject.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:98
msgid ""
"In this particular case, we’re using the `/var/www/htdocs` path that is "
"common for Apache setups, but you can use any static web server — just put "
"the bare repository in its path. The Git data is served as basic static "
"files (see Chapter 9 for details about exactly how it’s served)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:100
msgid ""
"It’s possible to make Git push over HTTP as well, although that technique "
"isn’t as widely used and requires you to set up complex WebDAV requirements. "
"Because it’s rarely used, we won’t cover it in this book. If you’re "
"interested in using the HTTP-push protocols, you can read about preparing a "
"repository for this purpose at `http://www.kernel.org/pub/software/scm/git/"
"docs/howto/setup-git-server-over-http.txt`. One nice thing about making Git "
"push over HTTP is that you can use any WebDAV server, without specific Git "
"features; so, you can use this functionality if your web-hosting provider "
"supports WebDAV for writing updates to your web site."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:102
msgctxt "en/04-git-server/01-chapter4.markdown:102"
msgid "#### The Pros ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:104
msgid ""
"The upside of using the HTTP protocol is that it’s easy to set up. Running "
"the handful of required commands gives you a simple way to give the world "
"read access to your Git repository. It takes only a few minutes to do. The "
"HTTP protocol also isn’t very resource intensive on your server. Because it "
"generally uses a static HTTP server to serve all the data, a normal Apache "
"server can serve thousands of files per second on average — it’s difficult "
"to overload even a small server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:106
msgid ""
"You can also serve your repositories read-only over HTTPS, which means you "
"can encrypt the content transfer; or you can go so far as to make the "
"clients use specific signed SSL certificates. Generally, if you’re going to "
"these lengths, it’s easier to use SSH public keys; but it may be a better "
"solution in your specific case to use signed SSL certificates or other HTTP-"
"based authentication methods for read-only access over HTTPS."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:108
msgid ""
"Another nice thing is that HTTP is such a commonly used protocol that "
"corporate firewalls are often set up to allow traffic through this port."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:110
msgctxt "en/04-git-server/01-chapter4.markdown:110"
msgid "#### The Cons ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:112
msgid ""
"The downside of serving your repository over HTTP is that it’s relatively "
"inefficient for the client. It generally takes a lot longer to clone or "
"fetch from the repository, and you often have a lot more network overhead "
"and transfer volume over HTTP than with any of the other network protocols. "
"Because it’s not as intelligent about transferring only the data you need — "
"there is no dynamic work on the part of the server in these transactions — "
"the HTTP protocol is often referred to as a _dumb_ protocol. For more "
"information about the differences in efficiency between the HTTP protocol "
"and the other protocols, see Chapter 9."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:114
msgid "## Getting Git on a Server ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:116
msgid ""
"In order to initially set up any Git server, you have to export an existing "
"repository into a new bare repository — a repository that doesn’t contain a "
"working directory. This is generally straightforward to do.\n"
"In order to clone your repository to create a new bare repository, you run "
"the clone command with the `--bare` option. By convention, bare repository "
"directories end in `.git`, like so:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:119
msgid ""
"\t$ git clone --bare my_project my_project.git\n"
"\tInitialized empty Git repository in /opt/projects/my_project.git/"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:122
msgid ""
"The output for this command is a little confusing. Since `clone` is "
"basically a `git init` then a `git fetch`, we see some output from the `git "
"init` part, which creates an empty directory. The actual object transfer "
"gives no output, but it does happen. You should now have a copy of the Git "
"directory data in your `my_project.git` directory."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:124
msgid "This is roughly equivalent to something like"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:126
msgid "\t$ cp -Rf my_project/.git my_project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:128
msgid ""
"There are a couple of minor differences in the configuration file; but for "
"your purpose, this is close to the same thing. It takes the Git repository "
"by itself, without a working directory, and creates a directory specifically "
"for it alone."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:130
msgid "### Putting the Bare Repository on a Server ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:132
msgid ""
"Now that you have a bare copy of your repository, all you need to do is put "
"it on a server and set up your protocols. Let’s say you’ve set up a server "
"called `git.example.com` that you have SSH access to, and you want to store "
"all your Git repositories under the `/opt/git` directory. You can set up "
"your new repository by copying your bare repository over:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:134
msgid "\t$ scp -r my_project.git user@git.example.com:/opt/git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:136
msgid ""
"At this point, other users who have SSH access to the same server which has "
"read-access to the `/opt/git` directory can clone your repository by running"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:138
msgid "\t$ git clone user@git.example.com:/opt/git/my_project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:140
msgid ""
"If a user SSHs into a server and has write access to the `/opt/git/"
"my_project.git` directory, they will also automatically have push access.  "
"Git will automatically add group write permissions to a repository properly "
"if you run the `git init` command with the `--shared` option."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:142
msgid ""
"\t$ ssh user@git.example.com\n"
"\t$ cd /opt/git/my_project.git\n"
"\t$ git init --bare --shared"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:146
msgid ""
"You see how easy it is to take a Git repository, create a bare version, and "
"place it on a server to which you and your collaborators have SSH access. "
"Now you’re ready to collaborate on the same project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:148
msgid ""
"It’s important to note that this is literally all you need to do to run a "
"useful Git server to which several people have access — just add SSH-able "
"accounts on a server, and stick a bare repository somewhere that all those "
"users have read and write access to. You’re ready to go — nothing else "
"needed."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:150
msgid ""
"In the next few sections, you’ll see how to expand to more sophisticated "
"setups. This discussion will include not having to create user accounts for "
"each user, adding public read access to repositories, setting up web UIs, "
"using the Gitosis tool, and more. However, keep in mind that to collaborate "
"with a couple of people on a private project, all you _need_ is an SSH "
"server and a bare repository."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:152
msgid "### Small Setups ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:154
msgid ""
"If you’re a small outfit or are just trying out Git in your organization and "
"have only a few developers, things can be simple for you. One of the most "
"complicated aspects of setting up a Git server is user management. If you "
"want some repositories to be read-only to certain users and read/write to "
"others, access and permissions can be a bit difficult to arrange."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:156
msgid "#### SSH Access ####"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:158
msgid ""
"If you already have a server to which all your developers have SSH access, "
"it’s generally easiest to set up your first repository there, because you "
"have to do almost no work (as we covered in the last section). If you want "
"more complex access control type permissions on your repositories, you can "
"handle them with the normal filesystem permissions of the operating system "
"your server runs."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:160
msgid ""
"If you want to place your repositories on a server that doesn’t have "
"accounts for everyone on your team whom you want to have write access, then "
"you must set up SSH access for them. We assume that if you have a server "
"with which to do this, you already have an SSH server installed, and that’s "
"how you’re accessing the server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:162
msgid ""
"There are a few ways you can give access to everyone on your team. The first "
"is to set up accounts for everybody, which is straightforward but can be "
"cumbersome. You may not want to run `adduser` and set temporary passwords "
"for every user."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:164
msgid ""
"A second method is to create a single 'git' user on the machine, ask every "
"user who is to have write access to send you an SSH public key, and add that "
"key to the `~/.ssh/authorized_keys` file of your new 'git' user. At that "
"point, everyone will be able to access that machine via the 'git' user. This "
"doesn’t affect the commit data in any way — the SSH user you connect as "
"doesn’t affect the commits you’ve recorded."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:166
msgid ""
"Another way to do it is to have your SSH server authenticate from an LDAP "
"server or some other centralized authentication source that you may already "
"have set up. As long as each user can get shell access on the machine, any "
"SSH authentication mechanism you can think of should work."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:168
msgid "## Generating Your SSH Public Key ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:170
msgid ""
"That being said, many Git servers authenticate using SSH public keys. In "
"order to provide a public key, each user in your system must generate one if "
"they don’t already have one. This process is similar across all operating "
"systems.\n"
"First, you should check to make sure you don’t already have a key. By "
"default, a user’s SSH keys are stored in that user’s `~/.ssh` directory. You "
"can easily check to see if you have a key already by going to that directory "
"and listing the contents:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:173
msgid ""
"\t$ cd ~/.ssh\n"
"\t$ ls\n"
"\tauthorized_keys2  id_dsa       known_hosts\n"
"\tconfig            id_dsa.pub"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:178
msgid ""
"You’re looking for a pair of files named something and something.pub, where "
"the something is usually `id_dsa` or `id_rsa`. The `.pub` file is your "
"public key, and the other file is your private key. If you don’t have these "
"files (or you don’t even have a `.ssh` directory), you can create them by "
"running a program called `ssh-keygen`, which is provided with the SSH "
"package on Linux/Mac systems and comes with the MSysGit package on Windows:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:180
msgid ""
"\t$ ssh-keygen\n"
"\tGenerating public/private rsa key pair.\n"
"\tEnter file in which to save the key (/Users/schacon/.ssh/id_rsa):\n"
"\tEnter passphrase (empty for no passphrase):\n"
"\tEnter same passphrase again:\n"
"\tYour identification has been saved in /Users/schacon/.ssh/id_rsa.\n"
"\tYour public key has been saved in /Users/schacon/.ssh/id_rsa.pub.\n"
"\tThe key fingerprint is:\n"
"\t43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:190
msgid ""
"First it confirms where you want to save the key (`.ssh/id_rsa`), and then "
"it asks twice for a passphrase, which you can leave empty if you don’t want "
"to type a password when you use the key."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:192
msgid ""
"Now, each user that does this has to send their public key to you or whoever "
"is administrating the Git server (assuming you’re using an SSH server setup "
"that requires public keys). All they have to do is copy the contents of the "
"`.pub` file and e-mail it. The public keys look something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:194
msgid ""
"\t$ cat ~/.ssh/id_rsa.pub\n"
"\tssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU\n"
"\tGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3\n"
"\tPbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA\n"
"\tt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En\n"
"\tmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx\n"
"\tNrRFi9wrf+M7Q== schacon@agadorlaptop.local"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:202
msgid ""
"For a more in-depth tutorial on creating an SSH key on multiple operating "
"systems, see the GitHub guide on SSH keys at `http://github.com/guides/"
"providing-your-ssh-key`."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:204
msgid "## Setting Up the Server ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:206
msgid ""
"Let’s walk through setting up SSH access on the server side. In this "
"example, you’ll use the `authorized_keys` method for authenticating your "
"users. We also assume you’re running a standard Linux distribution like "
"Ubuntu. First, you create a 'git' user and a `.ssh` directory for that user."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:208
msgid ""
"\t$ sudo adduser git\n"
"\t$ su git\n"
"\t$ cd\n"
"\t$ mkdir .ssh"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:213
msgid ""
"Next, you need to add some developer SSH public keys to the "
"`authorized_keys` file for that user. Let’s assume you’ve received a few "
"keys by e-mail and saved them to temporary files. Again, the public keys "
"look something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:215
msgid ""
"\t$ cat /tmp/id_rsa.john.pub\n"
"\tssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L\n"
"\tojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k\n"
"\tYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez\n"
"\tSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv\n"
"\tO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq\n"
"\tdAv8JggJICUvax2T9va5 gsg-keypair"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:223
msgid "You just append them to your `authorized_keys` file:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:225
msgid ""
"\t$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys\n"
"\t$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys\n"
"\t$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:229
msgid ""
"Now, you can set up an empty repository for them by running `git init` with "
"the `--bare` option, which initializes the repository without a working "
"directory:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:231
msgid ""
"\t$ cd /opt/git\n"
"\t$ mkdir project.git\n"
"\t$ cd project.git\n"
"\t$ git --bare init"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:236
msgid ""
"Then, John, Josie, or Jessica can push the first version of their project "
"into that repository by adding it as a remote and pushing up a branch. Note "
"that someone must shell onto the machine and create a bare repository every "
"time you want to add a project. Let’s use `gitserver` as the hostname of the "
"server on which you’ve set up your 'git' user and repository. If you’re "
"running it internally, and you set up DNS for `gitserver` to point to that "
"server, then you can use the commands pretty much as is:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:238
msgid ""
"\t# on Johns computer\n"
"\t$ cd myproject\n"
"\t$ git init\n"
"\t$ git add .\n"
"\t$ git commit -m 'initial commit'\n"
"\t$ git remote add origin git@gitserver:/opt/git/project.git\n"
"\t$ git push origin master"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:246
msgid ""
"At this point, the others can clone it down and push changes back up just as "
"easily:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:248
msgid ""
"\t$ git clone git@gitserver:/opt/git/project.git\n"
"\t$ cd project\n"
"\t$ vim README\n"
"\t$ git commit -am 'fix for the README file'\n"
"\t$ git push origin master"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:254
msgid ""
"With this method, you can quickly get a read/write Git server up and running "
"for a handful of developers."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:256
msgid ""
"As an extra precaution, you can easily restrict the 'git' user to only doing "
"Git activities with a limited shell tool called `git-shell` that comes with "
"Git. If you set this as your 'git' user’s login shell, then the 'git' user "
"can’t have normal shell access to your server. To use this, specify `git-"
"shell` instead of bash or csh for your user’s login shell. To do so, you’ll "
"likely have to edit your `/etc/passwd` file:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:258
msgid "\t$ sudo vim /etc/passwd"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:260
msgid "At the bottom, you should find a line that looks something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:262
msgctxt "en/04-git-server/01-chapter4.markdown:262"
msgid "\tgit:x:1000:1000::/home/git:/bin/sh"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:264
msgid ""
"Change `/bin/sh` to `/usr/bin/git-shell` (or run `which git-shell` to see "
"where it’s installed). The line should look something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:266
msgctxt "en/04-git-server/01-chapter4.markdown:266"
msgid "\tgit:x:1000:1000::/home/git:/usr/bin/git-shell"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:268
msgid ""
"Now, the 'git' user can only use the SSH connection to push and pull Git "
"repositories and can’t shell onto the machine. If you try, you’ll see a "
"login rejection like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:270
msgid ""
"\t$ ssh git@gitserver\n"
"\tfatal: What do you think I am? A shell?\n"
"\tConnection to gitserver closed."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:274
msgid "## Public Access ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:276
msgid ""
"What if you want anonymous read access to your project? Perhaps instead of "
"hosting an internal private project, you want to host an open source "
"project. Or maybe you have a bunch of automated build servers or continuous "
"integration servers that change a lot, and you don’t want to have to "
"generate SSH keys all the time — you just want to add simple anonymous read "
"access."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:278
msgid ""
"Probably the simplest way for smaller setups is to run a static web server "
"with its document root where your Git repositories are, and then enable that "
"`post-update` hook we mentioned in the first section of this chapter. Let’s "
"work from the previous example. Say you have your repositories in the `/opt/"
"git` directory, and an Apache server is running on your machine. Again, you "
"can use any web server for this; but as an example, we’ll demonstrate some "
"basic Apache configurations that should give you an idea of what you might "
"need."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:280
msgid "First you need to enable the hook:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:282
msgid ""
"\t$ cd project.git\n"
"\t$ mv hooks/post-update.sample hooks/post-update\n"
"\t$ chmod a+x hooks/post-update"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:286
msgid ""
"If you’re using a version of Git earlier than 1.6, the `mv` command isn’t "
"necessary — Git started naming the hooks examples with the .sample postfix "
"only recently."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:288
msgid "What does this `post-update` hook do? It looks basically like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:290
msgid ""
"\t$ cat .git/hooks/post-update\n"
"\t#!/bin/sh\n"
"\texec git-update-server-info"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:294
msgid ""
"This means that when you push to the server via SSH, Git will run this "
"command to update the files needed for HTTP fetching."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:296
msgid ""
"Next, you need to add a VirtualHost entry to your Apache configuration with "
"the document root as the root directory of your Git projects. Here, we’re "
"assuming that you have wildcard DNS set up to send `*.gitserver` to whatever "
"box you’re using to run all this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:298
msgid ""
"\t<VirtualHost *:80>\n"
"\t    ServerName git.gitserver\n"
"\t    DocumentRoot /opt/git\n"
"\t    <Directory /opt/git/>\n"
"\t        Order allow, deny\n"
"\t        allow from all\n"
"\t    </Directory>\n"
"\t</VirtualHost>"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:307
msgid ""
"You’ll also need to set the Unix user group of the `/opt/git` directories to "
"`www-data` so your web server can read-access the repositories, because the "
"Apache instance running the CGI script will (by default) be running as that "
"user:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:309
msgid "\t$ chgrp -R www-data /opt/git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:311
msgid ""
"When you restart Apache, you should be able to clone your repositories under "
"that directory by specifying the URL for your project:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:313
msgid "\t$ git clone http://git.gitserver/project.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:315
msgid ""
"This way, you can set up HTTP-based read access to any of your projects for "
"a fair number of users in a few minutes. Another simple option for public "
"unauthenticated access is to start a Git daemon, although that requires you "
"to daemonize the process - we’ll cover this option in the next section, if "
"you prefer that route."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:317
msgid "## GitWeb ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:319
msgid ""
"Now that you have basic read/write and read-only access to your project, you "
"may want to set up a simple web-based visualizer. Git comes with a CGI "
"script called GitWeb that is commonly used for this. You can see GitWeb in "
"use at sites like `http://git.kernel.org` (see Figure 4-1)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:321
msgid ""
"Insert 18333fig0401.png\n"
"Figure 4-1. The GitWeb web-based user interface."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:324
msgid ""
"If you want to check out what GitWeb would look like for your project, Git "
"comes with a command to fire up a temporary instance if you have a "
"lightweight server on your system like `lighttpd` or `webrick`. On Linux "
"machines, `lighttpd` is often installed, so you may be able to get it to run "
"by typing `git instaweb` in your project directory. If you’re running a Mac, "
"Leopard comes preinstalled with Ruby, so `webrick` may be your best bet. To "
"start `instaweb` with a non-lighttpd handler, you can run it with the `--"
"httpd` option."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:326
msgid ""
"\t$ git instaweb --httpd=webrick\n"
"\t[2009-02-21 10:02:21] INFO  WEBrick 1.3.1\n"
"\t[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:330
msgid ""
"That starts up an HTTPD server on port 1234 and then automatically starts a "
"web browser that opens on that page. It’s pretty easy on your part. When "
"you’re done and want to shut down the server, you can run the same command "
"with the `--stop` option:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:332
msgid "\t$ git instaweb --httpd=webrick --stop"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:334
msgid ""
"If you want to run the web interface on a server all the time for your team "
"or for an open source project you’re hosting, you’ll need to set up the CGI "
"script to be served by your normal web server. Some Linux distributions have "
"a `gitweb` package that you may be able to install via `apt` or `yum`, so "
"you may want to try that first. We’ll walk though installing GitWeb manually "
"very quickly. First, you need to get the Git source code, which GitWeb comes "
"with, and generate the custom CGI script:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:336
msgid ""
"\t$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t$ cd git/\n"
"\t$ make GITWEB_PROJECTROOT=\"/opt/git\" \\\n"
"\t        prefix=/usr gitweb\n"
"\t$ sudo cp -Rf gitweb /var/www/"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:342
msgid ""
"Notice that you have to tell the command where to find your Git repositories "
"with the `GITWEB_PROJECTROOT` variable. Now, you need to make Apache use CGI "
"for that script, for which you can add a VirtualHost:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:344
msgid ""
"\t<VirtualHost *:80>\n"
"\t    ServerName gitserver\n"
"\t    DocumentRoot /var/www/gitweb\n"
"\t    <Directory /var/www/gitweb>\n"
"\t        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch\n"
"\t        AllowOverride All\n"
"\t        order allow,deny\n"
"\t        Allow from all\n"
"\t        AddHandler cgi-script cgi\n"
"\t        DirectoryIndex gitweb.cgi\n"
"\t    </Directory>\n"
"\t</VirtualHost>"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:357
msgid ""
"Again, GitWeb can be served with any CGI capable web server; if you prefer "
"to use something else, it shouldn’t be difficult to set up. At this point, "
"you should be able to visit `http://gitserver/` to view your repositories "
"online, and you can use `http://git.gitserver` to clone and fetch your "
"repositories over HTTP."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:359
#, fuzzy
msgid "## Gitosis ##"
msgstr "## Git 기초 ##"

#: en/04-git-server/01-chapter4.markdown:361
msgid ""
"Keeping all users’ public keys in the `authorized_keys` file for access "
"works well only for a while. When you have hundreds of users, it’s much more "
"of a pain to manage that process. You have to shell onto the server each "
"time, and there is no access control — everyone in the file has read and "
"write access to every project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:363
msgid ""
"At this point, you may want to turn to a widely used software project called "
"Gitosis. Gitosis is basically a set of scripts that help you manage the "
"`authorized_keys` file as well as implement some simple access controls. The "
"really interesting part is that the UI for this tool for adding people and "
"determining access isn’t a web interface but a special Git repository. You "
"set up the information in that project; and when you push it, Gitosis "
"reconfigures the server based on that, which is cool."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:365
msgid ""
"Installing Gitosis isn’t the simplest task ever, but it’s not too difficult. "
"It’s easiest to use a Linux server for it — these examples use a stock "
"Ubuntu 8.10 server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:367
msgid ""
"Gitosis requires some Python tools, so first you have to install the Python "
"setuptools package, which Ubuntu provides as python-setuptools:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:369
msgid "\t$ apt-get install python-setuptools"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:371
msgid "Next, you clone and install Gitosis from the project’s main site:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:373
msgid ""
"\t$ git clone git://eagain.net/gitosis.git\n"
"\t$ cd gitosis\n"
"\t$ sudo python setup.py install"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:377
msgid ""
"That installs a couple of executables that Gitosis will use. Next, Gitosis "
"wants to put its repositories under `/home/git`, which is fine. But you have "
"already set up your repositories in `/opt/git`, so instead of reconfiguring "
"everything, you create a symlink:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:379
msgid "\t$ ln -s /opt/git /home/git/repositories"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:381
msgid ""
"Gitosis is going to manage your keys for you, so you need to remove the "
"current file, re-add the keys later, and let Gitosis control the "
"`authorized_keys` file automatically. For now, move the `authorized_keys` "
"file out of the way:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:383
msgid "\t$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:385
msgid ""
"Next you need to turn your shell back on for the 'git' user, if you changed "
"it to the `git-shell` command. People still won’t be able to log in, but "
"Gitosis will control that for you. So, let’s change this line in your `/etc/"
"passwd` file"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:387
msgctxt "en/04-git-server/01-chapter4.markdown:387"
msgid "\tgit:x:1000:1000::/home/git:/usr/bin/git-shell"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:389
msgid "back to this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:391
msgctxt "en/04-git-server/01-chapter4.markdown:391"
msgid "\tgit:x:1000:1000::/home/git:/bin/sh"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:393
msgid ""
"Now it’s time to initialize Gitosis. You do this by running the `gitosis-"
"init` command with your personal public key. If your public key isn’t on the "
"server, you’ll have to copy it there:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:395
msgid ""
"\t$ sudo -H -u git gitosis-init < /tmp/id_dsa.pub\n"
"\tInitialized empty Git repository in /opt/git/gitosis-admin.git/\n"
"\tReinitialized existing Git repository in /opt/git/gitosis-admin.git/"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:399
msgid ""
"This lets the user with that key modify the main Git repository that "
"controls the Gitosis setup. Next, you have to manually set the execute bit "
"on the `post-update` script for your new control repository."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:401
msgid "\t$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:403
msgid ""
"You’re ready to roll. If you’re set up correctly, you can try to SSH into "
"your server as the user for which you added the public key to initialize "
"Gitosis. You should see something like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:405
msgid ""
"\t$ ssh git@gitserver\n"
"\tPTY allocation request failed on channel 0\n"
"\tfatal: unrecognized command 'gitosis-serve schacon@quaternion'\n"
"\t  Connection to gitserver closed."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:410
msgid ""
"That means Gitosis recognized you but shut you out because you’re not trying "
"to do any Git commands. So, let’s do an actual Git command — you’ll clone "
"the Gitosis control repository:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:412
msgid ""
"\t# on your local computer\n"
"\t$ git clone git@gitserver:gitosis-admin.git"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:415
msgid ""
"Now you have a directory named `gitosis-admin`, which has two major parts:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:417
msgid ""
"\t$ cd gitosis-admin\n"
"\t$ find .\n"
"\t./gitosis.conf\n"
"\t./keydir\n"
"\t./keydir/scott.pub"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:423
msgid ""
"The `gitosis.conf` file is the control file you use to specify users, "
"repositories, and permissions. The `keydir` directory is where you store the "
"public keys of all the users who have any sort of access to your "
"repositories — one file per user. The name of the file in `keydir` (in the "
"previous example, `scott.pub`) will be different for you — Gitosis takes "
"that name from the description at the end of the public key that was "
"imported with the `gitosis-init` script."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:425
msgid ""
"If you look at the `gitosis.conf` file, it should only specify information "
"about the `gitosis-admin` project that you just cloned:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:427
msgid ""
"\t$ cat gitosis.conf\n"
"\t[gitosis]"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:430
msgid ""
"\t[group gitosis-admin]\n"
"\twritable = gitosis-admin\n"
"\tmembers = scott"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:434
msgid ""
"It shows you that the 'scott' user — the user with whose public key you "
"initialized Gitosis — is the only one who has access to the `gitosis-admin` "
"project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:436
msgid ""
"Now, let’s add a new project for you. You’ll add a new section called "
"`mobile` where you’ll list the developers on your mobile team and projects "
"that those developers need access to. Because 'scott' is the only user in "
"the system right now, you’ll add him as the only member, and you’ll create a "
"new project called `iphone_project` to start on:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:438
msgid ""
"\t[group mobile]\n"
"\twritable = iphone_project\n"
"\tmembers = scott"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:442
msgid ""
"Whenever you make changes to the `gitosis-admin` project, you have to commit "
"the changes and push them back up to the server in order for them to take "
"effect:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:444
msgid ""
"\t$ git commit -am 'add iphone_project and mobile group'\n"
"\t[master]: created 8962da8: \"changed name\"\n"
"\t 1 files changed, 4 insertions(+), 0 deletions(-)\n"
"\t$ git push\n"
"\tCounting objects: 5, done.\n"
"\tCompressing objects: 100% (2/2), done.\n"
"\tWriting objects: 100% (3/3), 272 bytes, done.\n"
"\tTotal 3 (delta 1), reused 0 (delta 0)\n"
"\tTo git@gitserver:/opt/git/gitosis-admin.git\n"
"\t   fb27aec..8962da8  master -> master"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:455
msgid ""
"You can make your first push to the new `iphone_project` project by adding "
"your server as a remote to your local version of the project and pushing. "
"You no longer have to manually create a bare repository for new projects on "
"the server — Gitosis creates them automatically when it sees the first push:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:457
msgid ""
"\t$ git remote add origin git@gitserver:iphone_project.git\n"
"\t$ git push origin master\n"
"\tInitialized empty Git repository in /opt/git/iphone_project.git/\n"
"\tCounting objects: 3, done.\n"
"\tWriting objects: 100% (3/3), 230 bytes, done.\n"
"\tTotal 3 (delta 0), reused 0 (delta 0)\n"
"\tTo git@gitserver:iphone_project.git\n"
"\t * [new branch]      master -> master"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:466
msgid ""
"Notice that you don’t need to specify the path (in fact, doing so won’t "
"work), just a colon and then the name of the project — Gitosis finds it for "
"you."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:468
msgid ""
"You want to work on this project with your friends, so you’ll have to re-add "
"their public keys. But instead of appending them manually to the `~/.ssh/"
"authorized_keys` file on your server, you’ll add them, one key per file, "
"into the `keydir` directory. How you name the keys determines how you refer "
"to the users in the `gitosis.conf` file. Let’s re-add the public keys for "
"John, Josie, and Jessica:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:470
msgid ""
"\t$ cp /tmp/id_rsa.john.pub keydir/john.pub\n"
"\t$ cp /tmp/id_rsa.josie.pub keydir/josie.pub\n"
"\t$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:474
msgid ""
"Now you can add them all to your 'mobile' team so they have read and write "
"access to `iphone_project`:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:476
msgid ""
"\t[group mobile]\n"
"\twritable = iphone_project\n"
"\tmembers = scott john josie jessica"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:480
msgid ""
"After you commit and push that change, all four users will be able to read "
"from and write to that project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:482
msgid ""
"Gitosis has simple access controls as well. If you want John to have only "
"read access to this project, you can do this instead:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:484
msgid ""
"\t[group mobile]\n"
"\twritable = iphone_project\n"
"\tmembers = scott josie jessica"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:488
msgid ""
"\t[group mobile_ro]\n"
"\treadonly = iphone_project\n"
"\tmembers = john"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:492
msgid ""
"Now John can clone the project and get updates, but Gitosis won’t allow him "
"to push back up to the project. You can create as many of these groups as "
"you want, each containing different users and projects. You can also specify "
"another group as one of the members (using `@` as prefix), to inherit all of "
"its members automatically:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:494
msgid ""
"\t[group mobile_committers]\n"
"\tmembers = scott josie jessica"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:497
msgid ""
"\t[group mobile]\n"
"\twritable  = iphone_project\n"
"\tmembers   = @mobile_committers"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:501
msgid ""
"\t[group mobile_2]\n"
"\twritable  = another_iphone_project\n"
"\tmembers   = @mobile_committers john"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:505
msgid ""
"If you have any issues, it may be useful to add `loglevel=DEBUG` under the `"
"[gitosis]` section. If you’ve lost push access by pushing a messed-up "
"configuration, you can manually fix the file on the server under `/home/git/."
"gitosis.conf` — the file from which Gitosis reads its info. A push to the "
"project takes the `gitosis.conf` file you just pushed up and sticks it "
"there. If you edit that file manually, it remains like that until the next "
"successful push to the `gitosis-admin` project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:507
#, fuzzy
msgid "## Gitolite ##"
msgstr "## Git 기초 ##"

#: en/04-git-server/01-chapter4.markdown:509
msgid ""
"This section serves as a quick introduction to gitolite, and provides basic "
"installation and setup instructions.  It cannot, however, replace the "
"enormous amount of [documentation][gltoc] that gitolite comes with.  There "
"may also be occasional changes to this section itself, so you may also want "
"to look at the latest version [here][gldpg]."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:511
msgid ""
"[gldpg]: http://sitaramc.github.com/gitolite/progit.html\n"
"[gltoc]: http://sitaramc.github.com/gitolite/master-toc.html"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:514
msgid ""
"Gitolite is an authorisation layer on top of git, relying on sshd or httpd "
"for authentication.  (Recap: authentication is identifying who the user is, "
"authorisation is deciding if he is allowed to do what he is attempting to)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:516
msgid ""
"Gitolite allows you to specify permissions not just by repository, but also "
"by branch or tag names within each repository.  That is, you can specify "
"that certain people (or groups of people) can only push certain \"refs"
"\" (branches or tags) but not others."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:518
#, fuzzy
msgid "### Installing ###"
msgstr "## Git 설치 ##"

#: en/04-git-server/01-chapter4.markdown:520
msgid ""
"Installing Gitolite is very easy, even if you don’t read the extensive "
"documentation that comes with it.  You need an account on a Unix server of "
"some kind.  You do not need root access, assuming git, perl, and an openssh "
"compatible ssh server are already installed.  In the examples below, we will "
"use the `git` account on a host called `gitserver`."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:522
msgid ""
"Gitolite is somewhat unusual as far as \"server\" software goes -- access is "
"via ssh, and so every userid on the server is a potential \"gitolite host"
"\".  We will describe the simplest install method in this article; for the "
"other methods please see the documentation."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:524
msgid ""
"To begin, create a user called `git` on your server and login to this user.  "
"Copy your ssh pubkey (a file called `~/.ssh/id_rsa.pub` if you did a plain "
"`ssh-keygen` with all the defaults) from your workstation, renaming it to "
"`YourName.pub`.  Then run these commands:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:526
msgid ""
"    git clone git://github.com/sitaramc/gitolite\n"
"    gitolite/install -ln\n"
"        # assumes $HOME/bin exists and is in your $PATH\n"
"    gitolite setup -pk $HOME/YourName.pub\n"
"        # for example, I would run 'gitolite setup -pk $HOME/sitaram.pub'"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:532
msgid ""
"Finally, back on your workstation, run `git clone git@server:gitolite-admin`."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:534
msgid ""
"And you’re done!  Gitolite has now been installed on the server, and you now "
"have a brand new repository called `gitolite-admin` in your workstation.  "
"You administer your gitolite setup by making changes to this repository and "
"pushing."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:536
msgid "### Customising the Install ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:538
msgid ""
"While the default, quick, install works for most people, there are some ways "
"to customise the install if you need to.  Some changes can be made simply by "
"editing the rc file, but if that is not sufficient, there’s documentation on "
"customising Gitolite."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:540
msgid "### Config File and Access Control Rules ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:542
msgid ""
"Once the install is done, you switch to the `gitolite-admin` clone you just "
"made on your workstation, and poke around to see what you got:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:544
msgid ""
"\t$ cd ~/gitolite-admin/\n"
"\t$ ls\n"
"\tconf/  keydir/\n"
"\t$ find conf keydir -type f\n"
"\tconf/gitolite.conf\n"
"\tkeydir/sitaram.pub\n"
"\t$ cat conf/gitolite.conf"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:552
msgid ""
"\trepo gitolite-admin\n"
"\t    RW+                 = sitaram"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:555
msgid ""
"\trepo testing\n"
"\t    RW+                 = @all"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:558
msgid ""
"Notice that \"sitaram\" (the name of the pubkey in the gl-setup command you "
"used earlier) has read-write permissions on the `gitolite-admin` repository "
"as well as a public key file of the same name."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:560
msgid ""
"Adding users is easy.  To add a user called \"alice\", obtain her public "
"key, name it \"alice.pub\", and put it in the \"keydir\" directory of the "
"clone of the gitolite-admin repo you just made on your workstation.  Add, "
"commit, and push the change, and the user has been added."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:562
msgid ""
"The config file syntax for gitolite is well documented, so we’ll only "
"mention some highlights here."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:564
msgid ""
"You can group users or repos for convenience.  The group names are just like "
"macros; when defining them, it doesn’t even matter whether they are projects "
"or users; that distinction is only made when you *use* the \"macro\"."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:566
msgid ""
"\t@oss_repos      = linux perl rakudo git gitolite\n"
"\t@secret_repos   = fenestra pear"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:569
msgid ""
"\t@admins         = scott     # Adams, not Chacon, sorry :)\n"
"\t@interns        = ashok     # get the spelling right, Scott!\n"
"\t@engineers      = sitaram dilbert wally alice\n"
"\t@staff          = @admins @engineers @interns"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:574
msgid ""
"You can control permissions at the \"ref\" level.  In the following example, "
"interns can only push the \"int\" branch.  Engineers can push any branch "
"whose name starts with \"eng-\", and tags that start with \"rc\" followed by "
"a digit.  And the admins can do anything (including rewind) to any ref."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:576
msgid ""
"\trepo @oss_repos\n"
"\t    RW  int$                = @interns\n"
"\t    RW  eng-                = @engineers\n"
"\t    RW  refs/tags/rc[0-9]   = @engineers\n"
"\t    RW+                     = @admins"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:582
msgid ""
"The expression after the `RW` or `RW+` is a regular expression (regex) that "
"the refname (ref) being pushed is matched against.  So we call it a \"refex"
"\"!  Of course, a refex can be far more powerful than shown here, so don’t "
"overdo it if you’re not comfortable with Perl regexes."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:584
msgid ""
"Also, as you probably guessed, Gitolite prefixes `refs/heads/` as a "
"syntactic convenience if the refex does not begin with `refs/`."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:586
msgid ""
"An important feature of the config file’s syntax is that all the rules for a "
"repository need not be in one place.  You can keep all the common stuff "
"together, like the rules for all `oss_repos` shown above, then add specific "
"rules for specific cases later on, like so:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:588
msgid ""
"\trepo gitolite\n"
"\t    RW+                     = sitaram"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:591
msgid ""
"That rule will just get added to the ruleset for the `gitolite` repository."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:593
msgid ""
"At this point you might be wondering how the access control rules are "
"actually applied, so let’s go over that briefly."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:595
msgid ""
"There are two levels of access control in Gitolite.  The first is at the "
"repository level; if you have read (or write) access to *any* ref in the "
"repository, then you have read (or write) access to the repository.  This is "
"the only access control that Gitosis had."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:597
msgid ""
"The second level, applicable only to \"write\" access, is by branch or tag "
"within a repository.  The username, the access being attempted (`W` or `+`), "
"and the refname being updated are known.  The access rules are checked in "
"order of appearance in the config file, looking for a match for this "
"combination (but remember that the refname is regex-matched, not merely "
"string-matched).  If a match is found, the push succeeds.  A fallthrough "
"results in access being denied."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:599
msgid "### Advanced Access Control with \"deny\" rules ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:601
msgid ""
"So far, we’ve only seen permissions to be one of `R`, `RW`, or `RW+`.  "
"However, Gitolite allows another permission: `-`, standing for \"deny\".  "
"This gives you a lot more power, at the expense of some complexity, because "
"now fallthrough is not the *only* way for access to be denied, so the *order "
"of the rules now matters*!"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:603
msgid ""
"Let us say, in the situation above, we want engineers to be able to rewind "
"any branch *except* master and integ.  Here’s how to do that:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:605
msgid ""
"\t    RW  master integ    = @engineers\n"
"\t    -   master integ    = @engineers\n"
"\t    RW+                 = @engineers"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:609
msgid ""
"Again, you simply follow the rules top down until you hit a match for your "
"access mode, or a deny.  Non-rewind push to master or integ is allowed by "
"the first rule.  A rewind push to those refs does not match the first rule, "
"drops down to the second, and is therefore denied.  Any push (rewind or non-"
"rewind) to refs other than master or integ won’t match the first two rules "
"anyway, and the third rule allows it."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:611
msgid "### Restricting pushes by files changed ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:613
msgid ""
"In addition to restricting what branches a user can push changes to, you can "
"also restrict what files they are allowed to touch.  For example, perhaps "
"the Makefile (or some other program) is really not supposed to be changed by "
"just anyone, because a lot of things depend on it or would break if the "
"changes are not done *just right*.  You can tell gitolite:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:615
msgid ""
"    repo foo\n"
"        RW                      =   @junior_devs @senior_devs"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:618
msgid "        -   VREF/NAME/Makefile  =   @junior_devs"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:620
msgid ""
"User who are migrating from the older gitolite should note that there is a "
"significant change in behaviour with regard to this feature; please see the "
"migration guide for details."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:622
msgid "### Personal Branches ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:624
msgid ""
"Gitolite also has a feature called \"personal branches\" (or rather, "
"\"personal branch namespace\") that can be very useful in a corporate "
"environment."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:626
msgid ""
"A lot of code exchange in the git world happens by \"please pull\" "
"requests.  In a corporate environment, however, unauthenticated access is a "
"no-no, and a developer workstation cannot do authentication, so you have to "
"push to the central server and ask someone to pull from there."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:628
msgid ""
"This would normally cause the same branch name clutter as in a centralised "
"VCS, plus setting up permissions for this becomes a chore for the admin."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:630
msgid ""
"Gitolite lets you define a \"personal\" or \"scratch\" namespace prefix for "
"each developer (for example, `refs/personal/<devname>/*`); please see the "
"documentation for details."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:632
msgid "### \"Wildcard\" repositories ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:634
msgid ""
"Gitolite allows you to specify repositories with wildcards (actually perl "
"regexes), like, for example `assignments/s[0-9][0-9]/a[0-9][0-9]`, to pick a "
"random example.  It also allows you to assign a new permission mode (\"C\") "
"which enables users to create repositories based on such wild cards, "
"automatically assigns ownership to the specific user who created it, allows "
"him/her to hand out R and RW permissions to other users to collaborate, "
"etc.  Again, please see the documentation for details."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:636
msgid "### Other Features ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:638
msgid ""
"We’ll round off this discussion with a sampling of other features, all of "
"which, and many more, are described in great detail in the documentation."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:640
msgid ""
"**Logging**: Gitolite logs all successful accesses.  If you were somewhat "
"relaxed about giving people rewind permissions (`RW+`) and some kid blew "
"away \"master\", the log file is a life saver, in terms of easily and "
"quickly finding the SHA that got hosed."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:642
msgid ""
"**Access rights reporting**: Another convenient feature is what happens when "
"you try and just ssh to the server.  Gitolite shows you what repos you have "
"access to, and what that access may be.  Here’s an example:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:644
msgid ""
"        hello sitaram, this is git@git running gitolite3 v3.01-18-g9609868 "
"on git 1.7.4.4"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:646
msgid ""
"             R     anu-wsd\n"
"             R     entrans\n"
"             R  W  git-notes\n"
"             R  W  gitolite\n"
"             R  W  gitolite-admin\n"
"             R     indic_web_input\n"
"             R     shreelipi_converter"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:654
msgid ""
"**Delegation**: For really large installations, you can delegate "
"responsibility for groups of repositories to various people and have them "
"manage those pieces independently.  This reduces the load on the main admin, "
"and makes him less of a bottleneck."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:656
msgid ""
"**Mirroring**: Gitolite can help you maintain multiple mirrors, and switch "
"between them easily if the primary server goes down."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:658
msgid "## Git Daemon ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:660
msgid ""
"For public, unauthenticated read access to your projects, you’ll want to "
"move past the HTTP protocol and start using the Git protocol. The main "
"reason is speed. The Git protocol is far more efficient and thus faster than "
"the HTTP protocol, so using it will save your users time."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:662
msgid ""
"Again, this is for unauthenticated read-only access. If you’re running this "
"on a server outside your firewall, it should only be used for projects that "
"are publicly visible to the world. If the server you’re running it on is "
"inside your firewall, you might use it for projects that a large number of "
"people or computers (continuous integration or build servers) have read-only "
"access to, when you don’t want to have to add an SSH key for each."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:664
msgid ""
"In any case, the Git protocol is relatively easy to set up. Basically, you "
"need to run this command in a daemonized manner:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:666
msgid "\tgit daemon --reuseaddr --base-path=/opt/git/ /opt/git/"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:668
msgid ""
"`--reuseaddr` allows the server to restart without waiting for old "
"connections to time out, the `--base-path` option allows people to clone "
"projects without specifying the entire path, and the path at the end tells "
"the Git daemon where to look for repositories to export. If you’re running a "
"firewall, you’ll also need to punch a hole in it at port 9418 on the box "
"you’re setting this up on."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:670
msgid ""
"You can daemonize this process a number of ways, depending on the operating "
"system you’re running. On an Ubuntu machine, you use an Upstart script. So, "
"in the following file"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:672
msgid "\t/etc/event.d/local-git-daemon"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:674
msgid "you put this script:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:676
msgid ""
"\tstart on startup\n"
"\tstop on shutdown\n"
"\texec /usr/bin/git daemon \\\n"
"\t    --user=git --group=git \\\n"
"\t    --reuseaddr \\\n"
"\t    --base-path=/opt/git/ \\\n"
"\t    /opt/git/\n"
"\trespawn"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:685
msgid ""
"For security reasons, it is strongly encouraged to have this daemon run as a "
"user with read-only permissions to the repositories — you can easily do this "
"by creating a new user 'git-ro' and running the daemon as them.  For the "
"sake of simplicity we’ll simply run it as the same 'git' user that Gitosis "
"is running as."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:687
msgid ""
"When you restart your machine, your Git daemon will start automatically and "
"respawn if it goes down. To get it running without having to reboot, you can "
"run this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:689
msgid "\tinitctl start local-git-daemon"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:691
msgid ""
"On other systems, you may want to use `xinetd`, a script in your `sysvinit` "
"system, or something else — as long as you get that command daemonized and "
"watched somehow."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:693
msgid ""
"Next, you have to tell your Gitosis server which repositories to allow "
"unauthenticated Git server-based access to. If you add a section for each "
"repository, you can specify the ones from which you want your Git daemon to "
"allow reading. If you want to allow Git protocol access for the "
"`iphone_project`, you add this to the end of the `gitosis.conf` file:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:695
msgid ""
"\t[repo iphone_project]\n"
"\tdaemon = yes"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:698
msgid ""
"When that is committed and pushed up, your running daemon should start "
"serving requests for the project to anyone who has access to port 9418 on "
"your server."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:700
msgid ""
"If you decide not to use Gitosis, but you want to set up a Git daemon, "
"you’ll have to run this on each project you want the Git daemon to serve:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:702
msgid ""
"\t$ cd /path/to/project.git\n"
"\t$ touch git-daemon-export-ok"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:705
msgid ""
"The presence of that file tells Git that it’s OK to serve this project "
"without authentication."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:707
msgid ""
"Gitosis can also control which projects GitWeb shows. First, you need to add "
"something like the following to the `/etc/gitweb.conf` file:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:709
msgid ""
"\t$projects_list = \"/home/git/gitosis/projects.list\";\n"
"\t$projectroot = \"/home/git/repositories\";\n"
"\t$export_ok = \"git-daemon-export-ok\";\n"
"\t@git_base_url_list = ('git://gitserver');"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:714
msgid ""
"You can control which projects GitWeb lets users browse by adding or "
"removing a `gitweb` setting in the Gitosis configuration file. For instance, "
"if you want the `iphone_project` to show up on GitWeb, you make the `repo` "
"setting look like this:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:716
msgid ""
"\t[repo iphone_project]\n"
"\tdaemon = yes\n"
"\tgitweb = yes"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:720
msgid ""
"Now, if you commit and push the project, GitWeb will automatically start "
"showing the `iphone_project`."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:722
msgid "## Hosted Git ##"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:724
msgid ""
"If you don’t want to go through all of the work involved in setting up your "
"own Git server, you have several options for hosting your Git projects on an "
"external dedicated hosting site. Doing so offers a number of advantages: a "
"hosting site is generally quick to set up and easy to start projects on, and "
"no server maintenance or monitoring is involved. Even if you set up and run "
"your own server internally, you may still want to use a public hosting site "
"for your open source code — it’s generally easier for the open source "
"community to find and help you with."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:726
msgid ""
"These days, you have a huge number of hosting options to choose from, each "
"with different advantages and disadvantages. To see an up-to-date list, "
"check out the following page:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:728
msgid "\thttp://en.wikipedia.org/wiki/Git_(software)#Source_code_hosting"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:730
msgid ""
"Because we can’t cover all of them, and because I happen to work at one of "
"them, we’ll use this section to walk through setting up an account and "
"creating a new project at GitHub. This will give you an idea of what is "
"involved."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:732
msgid ""
"GitHub is by far the largest open source Git hosting site and it’s also one "
"of the very few that offers both public and private hosting options so you "
"can keep your open source and private commercial code in the same place. In "
"fact, we used GitHub to privately collaborate on this book."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:734
msgid "### GitHub ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:736
msgid ""
"GitHub is slightly different than most code-hosting sites in the way that it "
"namespaces projects. Instead of being primarily based on the project, GitHub "
"is user centric. That means when I host my `grit` project on GitHub, you "
"won’t find it at `github.com/grit` but instead at `github.com/schacon/grit`. "
"There is no canonical version of any project, which allows a project to move "
"from one user to another seamlessly if the first author abandons the project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:738
msgid ""
"GitHub is also a commercial company that charges for accounts that maintain "
"private repositories, but anyone can quickly get a free account to host as "
"many open source projects as they want. We’ll quickly go over how that is "
"done."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:740
msgid "### Setting Up a User Account ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:742
msgid ""
"The first thing you need to do is set up a free user account. If you visit "
"the Pricing and Signup page at `http://github.com/plans` and click the "
"\"Sign Up\" button on the Free account (see Figure 4-2), you’re taken to the "
"signup page."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:744
msgid ""
"Insert 18333fig0402.png\n"
"Figure 4-2. The GitHub plan page."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:747
msgid ""
"Here you must choose a username that isn’t yet taken in the system and enter "
"an e-mail address that will be associated with the account and a password "
"(see Figure 4-3)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:749
msgid ""
"Insert 18333fig0403.png\n"
"Figure 4-3. The GitHub user signup form."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:752
msgid ""
"If you have it available, this is a good time to add your public SSH key as "
"well. We covered how to generate a new key earlier, in the \"Simple Setups\" "
"section. Take the contents of the public key of that pair, and paste it into "
"the SSH Public Key text box. Clicking the \"explain ssh keys\" link takes "
"you to detailed instructions on how to do so on all major operating "
"systems.\n"
"Clicking the \"I agree, sign me up\" button takes you to your new user "
"dashboard (see Figure 4-4)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:755
msgid ""
"Insert 18333fig0404.png\n"
"Figure 4-4. The GitHub user dashboard."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:758
msgid "Next you can create a new repository."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:760
msgid "### Creating a New Repository ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:762
msgid ""
"Start by clicking the \"create a new one\" link next to Your Repositories on "
"the user dashboard. You’re taken to the Create a New Repository form (see "
"Figure 4-5)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:764
msgid ""
"Insert 18333fig0405.png\n"
"Figure 4-5. Creating a new repository on GitHub."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:767
msgid ""
"All you really have to do is provide a project name, but you can also add a "
"description. When that is done, click the \"Create Repository\" button. Now "
"you have a new repository on GitHub (see Figure 4-6)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:769
msgid ""
"Insert 18333fig0406.png\n"
"Figure 4-6. GitHub project header information."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:772
msgid ""
"Since you have no code there yet, GitHub will show you instructions for how "
"create a brand-new project, push an existing Git project up, or import a "
"project from a public Subversion repository (see Figure 4-7)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:774
msgid ""
"Insert 18333fig0407.png\n"
"Figure 4-7. Instructions for a new repository."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:777
msgid ""
"These instructions are similar to what we’ve already gone over. To "
"initialize a project if it isn’t already a Git project, you use"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:779
msgid ""
"\t$ git init\n"
"\t$ git add .\n"
"\t$ git commit -m 'initial commit'"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:783
msgid ""
"When you have a Git repository locally, add GitHub as a remote and push up "
"your master branch:"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:785
msgid ""
"\t$ git remote add origin git@github.com:testinguser/iphone_project.git\n"
"\t$ git push origin master"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:788
msgid ""
"Now your project is hosted on GitHub, and you can give the URL to anyone you "
"want to share your project with. In this case, it’s `http://github.com/"
"testinguser/iphone_project`. You can also see from the header on each of "
"your project’s pages that you have two Git URLs (see Figure 4-8)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:790
msgid ""
"Insert 18333fig0408.png\n"
"Figure 4-8. Project header with a public URL and a private URL."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:793
msgid ""
"The Public Clone URL is a public, read-only Git URL over which anyone can "
"clone the project. Feel free to give out that URL and post it on your web "
"site or what have you."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:795
msgid ""
"The Your Clone URL is a read/write SSH-based URL that you can read or write "
"over only if you connect with the SSH private key associated with the public "
"key you uploaded for your user. When other users visit this project page, "
"they won’t see that URL—only the public one."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:797
msgid "### Importing from Subversion ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:799
msgid ""
"If you have an existing public Subversion project that you want to import "
"into Git, GitHub can often do that for you. At the bottom of the "
"instructions page is a link to a Subversion import. If you click it, you see "
"a form with information about the import process and a text box where you "
"can paste in the URL of your public Subversion project (see Figure 4-9)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:801
msgid ""
"Insert 18333fig0409.png\n"
"Figure 4-9. Subversion importing interface."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:804
msgid ""
"If your project is very large, nonstandard, or private, this process "
"probably won’t work for you. In Chapter 7, you’ll learn how to do more "
"complicated manual project imports."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:806
msgid "### Adding Collaborators ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:808
msgid ""
"Let’s add the rest of the team. If John, Josie, and Jessica all sign up for "
"accounts on GitHub, and you want to give them push access to your "
"repository, you can add them to your project as collaborators. Doing so will "
"allow pushes from their public keys to work."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:810
msgid ""
"Click the \"edit\" button in the project header or the Admin tab at the top "
"of the project to reach the Admin page of your GitHub project (see Figure "
"4-10)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:812
msgid ""
"Insert 18333fig0410.png\n"
"Figure 4-10. GitHub administration page."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:815
msgid ""
"To give another user write access to your project, click the “Add another "
"collaborator” link. A new text box appears, into which you can type a "
"username. As you type, a helper pops up, showing you possible username "
"matches. When you find the correct user, click the Add button to add that "
"user as a collaborator on your project (see Figure 4-11)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:817
msgid ""
"Insert 18333fig0411.png\n"
"Figure 4-11. Adding a collaborator to your project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:820
msgid ""
"When you’re finished adding collaborators, you should see a list of them in "
"the Repository Collaborators box (see Figure 4-12)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:822
msgid ""
"Insert 18333fig0412.png\n"
"Figure 4-12. A list of collaborators on your project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:825
msgid ""
"If you need to revoke access to individuals, you can click the \"revoke\" "
"link, and their push access will be removed. For future projects, you can "
"also copy collaborator groups by copying the permissions of an existing "
"project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:827
msgid "### Your Project ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:829
msgid ""
"After you push your project up or have it imported from Subversion, you have "
"a main project page that looks something like Figure 4-13."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:831
msgid ""
"Insert 18333fig0413.png\n"
"Figure 4-13. A GitHub main project page."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:834
msgid ""
"When people visit your project, they see this page. It contains tabs to "
"different aspects of your projects. The Commits tab shows a list of commits "
"in reverse chronological order, similar to the output of the `git log` "
"command. The Network tab shows all the people who have forked your project "
"and contributed back. The Downloads tab allows you to upload project "
"binaries and link to tarballs and zipped versions of any tagged points in "
"your project. The Wiki tab provides a wiki where you can write documentation "
"or other information about your project. The Graphs tab has some "
"contribution visualizations and statistics about your project. The main "
"Source tab that you land on shows your project’s main directory listing and "
"automatically renders the README file below it if you have one. This tab "
"also shows a box with the latest commit information."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:836
msgid "### Forking Projects ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:838
msgid ""
"If you want to contribute to an existing project to which you don’t have "
"push access, GitHub encourages forking the project. When you land on a "
"project page that looks interesting and you want to hack on it a bit, you "
"can click the \"fork\" button in the project header to have GitHub copy that "
"project to your user so you can push to it."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:840
msgid ""
"This way, projects don’t have to worry about adding users as collaborators "
"to give them push access. People can fork a project and push to it, and the "
"main project maintainer can pull in those changes by adding them as remotes "
"and merging in their work."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:842
msgid ""
"To fork a project, visit the project page (in this case, mojombo/chronic) "
"and click the \"fork\" button in the header (see Figure 4-14)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:844
msgid ""
"Insert 18333fig0414.png\n"
"Figure 4-14. Get a writable copy of any repository by clicking the \"fork\" "
"button."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:847
msgid ""
"After a few seconds, you’re taken to your new project page, which indicates "
"that this project is a fork of another one (see Figure 4-15)."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:849
msgid ""
"Insert 18333fig0415.png\n"
"Figure 4-15. Your fork of a project."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:852
msgid "### GitHub Summary ###"
msgstr ""

#: en/04-git-server/01-chapter4.markdown:854
msgid ""
"That’s all we’ll cover about GitHub, but it’s important to note how quickly "
"you can do all this. You can create an account, add a new project, and push "
"to it in a matter of minutes. If your project is open source, you also get a "
"huge community of developers who now have visibility into your project and "
"may well fork it and help contribute to it. At the very least, this may be a "
"way to get up and running with Git and try it out quickly."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:858
msgid ""
"You have several options to get a remote Git repository up and running so "
"that you can collaborate with others or share your work."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:860
msgid ""
"Running your own server gives you a lot of control and allows you to run the "
"server within your own firewall, but such a server generally requires a fair "
"amount of your time to set up and maintain. If you place your data on a "
"hosted server, it’s easy to set up and maintain; however, you have to be "
"able to keep your code on someone else’s servers, and some organizations "
"don’t allow that."
msgstr ""

#: en/04-git-server/01-chapter4.markdown:862
msgid ""
"It should be fairly straightforward to determine which solution or "
"combination of solutions is appropriate for you and your organization."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:1
msgid "# Distributed Git #"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:3
msgid ""
"Now that you have a remote Git repository set up as a point for all the "
"developers to share their code, and you’re familiar with basic Git commands "
"in a local workflow, you’ll look at how to utilize some of the distributed "
"workflows that Git affords you."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:5
msgid ""
"In this chapter, you’ll see how to work with Git in a distributed "
"environment as a contributor and an integrator. That is, you’ll learn how to "
"contribute code successfully to a project and make it as easy on you and the "
"project maintainer as possible, and also how to maintain a project "
"successfully with a number of developers contributing."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:7
msgid "## Distributed Workflows ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:9
msgid ""
"Unlike Centralized Version Control Systems (CVCSs), the distributed nature "
"of Git allows you to be far more flexible in how developers collaborate on "
"projects. In centralized systems, every developer is a node working more or "
"less equally on a central hub. In Git, however, every developer is "
"potentially both a node and a hub — that is, every developer can both "
"contribute code to other repositories and maintain a public repository on "
"which others can base their work and which they can contribute to. This "
"opens a vast range of workflow possibilities for your project and/or your "
"team, so I’ll cover a few common paradigms that take advantage of this "
"flexibility. I’ll go over the strengths and possible weaknesses of each "
"design; you can choose a single one to use, or you can mix and match "
"features from each."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:11
msgid "### Centralized Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:13
msgid ""
"In centralized systems, there is generally a single collaboration model—the "
"centralized workflow. One central hub, or repository, can accept code, and "
"everyone synchronizes their work to it. A number of developers are nodes — "
"consumers of that hub — and synchronize to that one place (see Figure 5-1)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:15
msgid ""
"Insert 18333fig0501.png\n"
"Figure 5-1. Centralized workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:18
msgid ""
"This means that if two developers clone from the hub and both make changes, "
"the first developer to push their changes back up can do so with no "
"problems. The second developer must merge in the first one’s work before "
"pushing changes up, so as not to overwrite the first developer’s changes. "
"This concept is true in Git as it is in Subversion (or any CVCS), and this "
"model works perfectly in Git."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:20
msgid ""
"If you have a small team or are already comfortable with a centralized "
"workflow in your company or team, you can easily continue using that "
"workflow with Git. Simply set up a single repository, and give everyone on "
"your team push access; Git won’t let users overwrite each other. If one "
"developer clones, makes changes, and then tries to push their changes while "
"another developer has pushed in the meantime, the server will reject that "
"developer’s changes. They will be told that they’re trying to push non-fast-"
"forward changes and that they won’t be able to do so until they fetch and "
"merge.\n"
"This workflow is attractive to a lot of people because it’s a paradigm that "
"many are familiar and comfortable with."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:23
msgid "### Integration-Manager Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:25
msgid ""
"Because Git allows you to have multiple remote repositories, it’s possible "
"to have a workflow where each developer has write access to their own public "
"repository and read access to everyone else’s. This scenario often includes "
"a canonical repository that represents the \"official\" project. To "
"contribute to that project, you create your own public clone of the project "
"and push your changes to it. Then, you can send a request to the maintainer "
"of the main project to pull in your changes. They can add your repository as "
"a remote, test your changes locally, merge them into their branch, and push "
"back to their repository. The process works as follow (see Figure 5-2):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:27
msgid ""
"1. The project maintainer pushes to their public repository.\n"
"2. A contributor clones that repository and makes changes.\n"
"3. The contributor pushes to their own public copy.\n"
"4. The contributor sends the maintainer an e-mail asking them to pull "
"changes.\n"
"5. The maintainer adds the contributor’s repo as a remote and merges "
"locally.\n"
"6. The maintainer pushes merged changes to the main repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:34
msgid ""
"Insert 18333fig0502.png\n"
"Figure 5-2. Integration-manager workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:37
msgid ""
"This is a very common workflow with sites like GitHub, where it’s easy to "
"fork a project and push your changes into your fork for everyone to see. One "
"of the main advantages of this approach is that you can continue to work, "
"and the maintainer of the main repository can pull in your changes at any "
"time. Contributors don’t have to wait for the project to incorporate their "
"changes — each party can work at their own pace."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:39
msgid "### Dictator and Lieutenants Workflow ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:41
msgid ""
"This is a variant of a multiple-repository workflow. It’s generally used by "
"huge projects with hundreds of collaborators; one famous example is the "
"Linux kernel. Various integration managers are in charge of certain parts of "
"the repository; they’re called lieutenants. All the lieutenants have one "
"integration manager known as the benevolent dictator. The benevolent "
"dictator’s repository serves as the reference repository from which all the "
"collaborators need to pull. The process works like this (see Figure 5-3):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:43
msgid ""
"1. Regular developers work on their topic branch and rebase their work on "
"top of master. The master branch is that of the dictator.\n"
"2. Lieutenants merge the developers’ topic branches into their master "
"branch.\n"
"3. The dictator merges the lieutenants’ master branches into the dictator’s "
"master branch.\n"
"4. The dictator pushes their master to the reference repository so the other "
"developers can rebase on it."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:48
msgid ""
"Insert 18333fig0503.png\n"
"Figure 5-3. Benevolent dictator workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:51
msgid ""
"This kind of workflow isn’t common but can be useful in very big projects or "
"in highly hierarchical environments, as it allows the project leader (the "
"dictator) to delegate much of the work and collect large subsets of code at "
"multiple points before integrating them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:53
msgid ""
"These are some commonly used workflows that are possible with a distributed "
"system like Git, but you can see that many variations are possible to suit "
"your particular real-world workflow. Now that you can (I hope) determine "
"which workflow combination may work for you, I’ll cover some more specific "
"examples of how to accomplish the main roles that make up the different "
"flows."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:55
msgid "## Contributing to a Project ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:57
msgid ""
"You know what the different workflows are, and you should have a pretty good "
"grasp of fundamental Git usage. In this section, you’ll learn about a few "
"common patterns for contributing to a project."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:59
msgid ""
"The main difficulty with describing this process is that there are a huge "
"number of variations on how it’s done. Because Git is very flexible, people "
"can and do work together many ways, and it’s problematic to describe how you "
"should contribute to a project — every project is a bit different. Some of "
"the variables involved are active contributor size, chosen workflow, your "
"commit access, and possibly the external contribution method."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:61
msgid ""
"The first variable is active contributor size. How many users are actively "
"contributing code to this project, and how often? In many instances, you’ll "
"have two or three developers with a few commits a day, or possibly less for "
"somewhat dormant projects. For really large companies or projects, the "
"number of developers could be in the thousands, with dozens or even hundreds "
"of patches coming in each day. This is important because with more and more "
"developers, you run into more issues with making sure your code applies "
"cleanly or can be easily merged. Changes you submit may be rendered obsolete "
"or severely broken by work that is merged in while you were working or while "
"your changes were waiting to be approved or applied. How can you keep your "
"code consistently up to date and your patches valid?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:63
msgid ""
"The next variable is the workflow in use for the project. Is it centralized, "
"with each developer having equal write access to the main codeline? Does the "
"project have a maintainer or integration manager who checks all the patches? "
"Are all the patches peer-reviewed and approved? Are you involved in that "
"process? Is a lieutenant system in place, and do you have to submit your "
"work to them first?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:65
msgid ""
"The next issue is your commit access. The workflow required in order to "
"contribute to a project is much different if you have write access to the "
"project than if you don’t. If you don’t have write access, how does the "
"project prefer to accept contributed work? Does it even have a policy? How "
"much work are you contributing at a time? How often do you contribute?"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:67
msgid ""
"All these questions can affect how you contribute effectively to a project "
"and what workflows are preferred or available to you. I’ll cover aspects of "
"each of these in a series of use cases, moving from simple to more complex; "
"you should be able to construct the specific workflows you need in practice "
"from these examples."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:69
msgid "### Commit Guidelines ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:71
msgid ""
"Before you start looking at the specific use cases, here’s a quick note "
"about commit messages. Having a good guideline for creating commits and "
"sticking to it makes working with Git and collaborating with others a lot "
"easier. The Git project provides a document that lays out a number of good "
"tips for creating commits from which to submit patches — you can read it in "
"the Git source code in the `Documentation/SubmittingPatches` file."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:73
msgid ""
"First, you don’t want to submit any whitespace errors. Git provides an easy "
"way to check for this — before you commit, run `git diff --check`, which "
"identifies possible whitespace errors and lists them for you. Here is an "
"example, where I’ve replaced a red terminal color with `X`s:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:75
msgid ""
"\t$ git diff --check\n"
"\tlib/simplegit.rb:5: trailing whitespace.\n"
"\t+    @git_dir = File.expand_path(git_dir)XX\n"
"\tlib/simplegit.rb:7: trailing whitespace.\n"
"\t+ XXXXXXXXXXX\n"
"\tlib/simplegit.rb:26: trailing whitespace.\n"
"\t+    def command(git_cmd)XXXX"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:83
msgid ""
"If you run that command before committing, you can tell if you’re about to "
"commit whitespace issues that may annoy other developers."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:85
msgid ""
"Next, try to make each commit a logically separate changeset. If you can, "
"try to make your changes digestible — don’t code for a whole weekend on five "
"different issues and then submit them all as one massive commit on Monday. "
"Even if you don’t commit during the weekend, use the staging area on Monday "
"to split your work into at least one commit per issue, with a useful message "
"per commit. If some of the changes modify the same file, try to use `git add "
"--patch` to partially stage files (covered in detail in Chapter 6). The "
"project snapshot at the tip of the branch is identical whether you do one "
"commit or five, as long as all the changes are added at some point, so try "
"to make things easier on your fellow developers when they have to review "
"your changes. This approach also makes it easier to pull out or revert one "
"of the changesets if you need to later. Chapter 6 describes a number of "
"useful Git tricks for rewriting history and interactively staging files — "
"use these tools to help craft a clean and understandable history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:87
msgid ""
"The last thing to keep in mind is the commit message. Getting in the habit "
"of creating quality commit messages makes using and collaborating with Git a "
"lot easier. As a general rule, your messages should start with a single line "
"that’s no more than about 50 characters and that describes the changeset "
"concisely, followed by a blank line, followed by a more detailed "
"explanation. The Git project requires that the more detailed explanation "
"include your motivation for the change and contrast its implementation with "
"previous behavior — this is a good guideline to follow. It’s also a good "
"idea to use the imperative present tense in these messages. In other words, "
"use commands. Instead of \"I added tests for\" or \"Adding tests for,\" use "
"\"Add tests for.\"\n"
"Here is a template originally written by Tim Pope at tpope.net:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:90
msgid "\tShort (50 chars or less) summary of changes"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:92
msgid ""
"\tMore detailed explanatory text, if necessary.  Wrap it to about 72\n"
"\tcharacters or so.  In some contexts, the first line is treated as the\n"
"\tsubject of an email and the rest of the text as the body.  The blank\n"
"\tline separating the summary from the body is critical (unless you omit\n"
"\tthe body entirely); tools like rebase can get confused if you run the\n"
"\ttwo together."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:99
msgid "\tFurther paragraphs come after blank lines."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:101
msgid "\t - Bullet points are okay, too"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:103
msgid ""
"\t - Typically a hyphen or asterisk is used for the bullet, preceded by a\n"
"\t   single space, with blank lines in between, but conventions vary here"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:106
msgid ""
"If all your commit messages look like this, things will be a lot easier for "
"you and the developers you work with. The Git project has well-formatted "
"commit messages — I encourage you to run `git log --no-merges` there to see "
"what a nicely formatted project-commit history looks like."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:108
msgid ""
"In the following examples, and throughout most of this book, for the sake of "
"brevity I don’t format messages nicely like this; instead, I use the `-m` "
"option to `git commit`. Do as I say, not as I do."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:110
msgid "### Private Small Team ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:112
msgid ""
"The simplest setup you’re likely to encounter is a private project with one "
"or two other developers. By private, I mean closed source — not read-"
"accessible to the outside world. You and the other developers all have push "
"access to the repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:114
msgid ""
"In this environment, you can follow a workflow similar to what you might do "
"when using Subversion or another centralized system. You still get the "
"advantages of things like offline committing and vastly simpler branching "
"and merging, but the workflow can be very similar; the main difference is "
"that merges happen client-side rather than on the server at commit time.\n"
"Let’s see what it might look like when two developers start to work together "
"with a shared repository. The first developer, John, clones the repository, "
"makes a change, and commits locally. (I’m replacing the protocol messages "
"with `...` in these examples to shorten them somewhat.)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:117
msgid ""
"\t# John's Machine\n"
"\t$ git clone john@githost:simplegit.git\n"
"\tInitialized empty Git repository in /home/john/simplegit/.git/\n"
"\t...\n"
"\t$ cd simplegit/\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'removed invalid default value'\n"
"\t[master 738ee87] removed invalid default value\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:127
msgid ""
"The second developer, Jessica, does the same thing — clones the repository "
"and commits a change:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:129
msgid ""
"\t# Jessica's Machine\n"
"\t$ git clone jessica@githost:simplegit.git\n"
"\tInitialized empty Git repository in /home/jessica/simplegit/.git/\n"
"\t...\n"
"\t$ cd simplegit/\n"
"\t$ vim TODO\n"
"\t$ git commit -am 'add reset task'\n"
"\t[master fbff5bc] add reset task\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:139
msgid "Now, Jessica pushes her work up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:141
msgid ""
"\t# Jessica's Machine\n"
"\t$ git push origin master\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   1edee6b..fbff5bc  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:147
msgid "John tries to push his change up, too:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:149
msgid ""
"\t# John's Machine\n"
"\t$ git push origin master\n"
"\tTo john@githost:simplegit.git\n"
"\t ! [rejected]        master -> master (non-fast forward)\n"
"\terror: failed to push some refs to 'john@githost:simplegit.git'"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:155
msgid ""
"John isn’t allowed to push because Jessica has pushed in the meantime. This "
"is especially important to understand if you’re used to Subversion, because "
"you’ll notice that the two developers didn’t edit the same file. Although "
"Subversion automatically does such a merge on the server if different files "
"are edited, in Git you must merge the commits locally. John has to fetch "
"Jessica’s changes and merge them in before he will be allowed to push:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:157
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom john@githost:simplegit\n"
"\t + 049d078...fbff5bc master     -> origin/master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:162
msgid "At this point, John’s local repository looks something like Figure 5-4."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:164
msgid ""
"Insert 18333fig0504.png\n"
"Figure 5-4. John’s initial repository."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:167
msgid ""
"John has a reference to the changes Jessica pushed up, but he has to merge "
"them into his own work before he is allowed to push:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:169
msgid ""
"\t$ git merge origin/master\n"
"\tMerge made by recursive.\n"
"\t TODO |    1 +\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:174
msgid ""
"The merge goes smoothly — John’s commit history now looks like Figure 5-5."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:176
msgid ""
"Insert 18333fig0505.png\n"
"Figure 5-5. John’s repository after merging origin/master."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:179
msgid ""
"Now, John can test his code to make sure it still works properly, and then "
"he can push his new merged work up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:181
msgid ""
"\t$ git push origin master\n"
"\t...\n"
"\tTo john@githost:simplegit.git\n"
"\t   fbff5bc..72bbc59  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:186
msgid "Finally, John’s commit history looks like Figure 5-6."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:188
msgid ""
"Insert 18333fig0506.png\n"
"Figure 5-6. John’s history after pushing to the origin server."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:191
msgid ""
"In the meantime, Jessica has been working on a topic branch. She’s created a "
"topic branch called `issue54` and done three commits on that branch. She "
"hasn’t fetched John’s changes yet, so her commit history looks like Figure "
"5-7."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:193
msgid ""
"Insert 18333fig0507.png\n"
"Figure 5-7. Jessica’s initial commit history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:196
msgid "Jessica wants to sync up with John, so she fetches:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:198
msgid ""
"\t# Jessica's Machine\n"
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t   fbff5bc..72bbc59  master     -> origin/master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:204
msgid ""
"That pulls down the work John has pushed up in the meantime. Jessica’s "
"history now looks like Figure 5-8."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:206
msgid ""
"Insert 18333fig0508.png\n"
"Figure 5-8. Jessica’s history after fetching John’s changes."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:209
msgid ""
"Jessica thinks her topic branch is ready, but she wants to know what she has "
"to merge her work into so that she can push. She runs `git log` to find out:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:211
msgid ""
"\t$ git log --no-merges origin/master ^issue54\n"
"\tcommit 738ee872852dfaa9d6634e0dea7a324040193016\n"
"\tAuthor: John Smith <jsmith@example.com>\n"
"\tDate:   Fri May 29 16:01:27 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:216
msgid "\t    removed invalid default value"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:218
msgid ""
"Now, Jessica can merge her topic work into her master branch, merge John’s "
"work (`origin/master`) into her `master` branch, and then push back to the "
"server again. First, she switches back to her master branch to integrate all "
"this work:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:220
msgid ""
"\t$ git checkout master\n"
"\tSwitched to branch \"master\"\n"
"\tYour branch is behind 'origin/master' by 2 commits, and can be fast-"
"forwarded."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:224
msgid ""
"She can merge either `origin/master` or `issue54` first — they’re both "
"upstream, so the order doesn’t matter. The end snapshot should be identical "
"no matter which order she chooses; only the history will be slightly "
"different. She chooses to merge in `issue54` first:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:226
msgid ""
"\t$ git merge issue54\n"
"\tUpdating fbff5bc..4af4298\n"
"\tFast forward\n"
"\t README           |    1 +\n"
"\t lib/simplegit.rb |    6 +++++-\n"
"\t 2 files changed, 6 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:233
msgid ""
"No problems occur; as you can see, it was a simple fast-forward. Now Jessica "
"merges in John’s work (`origin/master`):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:235
msgid ""
"\t$ git merge origin/master\n"
"\tAuto-merging lib/simplegit.rb\n"
"\tMerge made by recursive.\n"
"\t lib/simplegit.rb |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:241
msgid "Everything merges cleanly, and Jessica’s history looks like Figure 5-9."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:243
msgid ""
"Insert 18333fig0509.png\n"
"Figure 5-9. Jessica’s history after merging John’s changes."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:246
msgid ""
"Now `origin/master` is reachable from Jessica’s `master` branch, so she "
"should be able to successfully push (assuming John hasn’t pushed again in "
"the meantime):"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:248
msgid ""
"\t$ git push origin master\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   72bbc59..8059c15  master -> master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:253
msgid ""
"Each developer has committed a few times and merged each other’s work "
"successfully; see Figure 5-10."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:255
msgid ""
"Insert 18333fig0510.png\n"
"Figure 5-10. Jessica’s history after pushing all changes back to the server."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:258
msgid ""
"That is one of the simplest workflows. You work for a while, generally in a "
"topic branch, and merge into your master branch when it’s ready to be "
"integrated. When you want to share that work, you merge it into your own "
"master branch, then fetch and merge `origin/master` if it has changed, and "
"finally push to the `master` branch on the server. The general sequence is "
"something like that shown in Figure 5-11."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:260
msgid ""
"Insert 18333fig0511.png\n"
"Figure 5-11. General sequence of events for a simple multiple-developer Git "
"workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:263
msgid "### Private Managed Team ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:265
msgid ""
"In this next scenario, you’ll look at contributor roles in a larger private "
"group. You’ll learn how to work in an environment where small groups "
"collaborate on features and then those team-based contributions are "
"integrated by another party."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:267
msgid ""
"Let’s say that John and Jessica are working together on one feature, while "
"Jessica and Josie are working on a second. In this case, the company is "
"using a type of integration-manager workflow where the work of the "
"individual groups is integrated only by certain engineers, and the `master` "
"branch of the main repo can be updated only by those engineers. In this "
"scenario, all work is done in team-based branches and pulled together by the "
"integrators later."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:269
msgid ""
"Let’s follow Jessica’s workflow as she works on her two features, "
"collaborating in parallel with two different developers in this environment. "
"Assuming she already has her repository cloned, she decides to work on "
"`featureA` first. She creates a new branch for the feature and does some "
"work on it there:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:271
msgid ""
"\t# Jessica's Machine\n"
"\t$ git checkout -b featureA\n"
"\tSwitched to a new branch \"featureA\"\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'add limit to log function'\n"
"\t[featureA 3300904] add limit to log function\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:279
msgid ""
"At this point, she needs to share her work with John, so she pushes her "
"`featureA` branch commits up to the server. Jessica doesn’t have push access "
"to the `master` branch — only the integrators do — so she has to push to "
"another branch in order to collaborate with John:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:281
msgid ""
"\t$ git push origin featureA\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t * [new branch]      featureA -> featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:286
msgid ""
"Jessica e-mails John to tell him that she’s pushed some work into a branch "
"named `featureA` and he can look at it now. While she waits for feedback "
"from John, Jessica decides to start working on `featureB` with Josie. To "
"begin, she starts a new feature branch, basing it off the server’s `master` "
"branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:288
msgid ""
"\t# Jessica's Machine\n"
"\t$ git fetch origin\n"
"\t$ git checkout -b featureB origin/master\n"
"\tSwitched to a new branch \"featureB\""
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:293
msgid "Now, Jessica makes a couple of commits on the `featureB` branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:295
msgid ""
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'made the ls-tree function recursive'\n"
"\t[featureB e5b0fdc] made the ls-tree function recursive\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)\n"
"\t$ vim lib/simplegit.rb\n"
"\t$ git commit -am 'add ls-files'\n"
"\t[featureB 8512791] add ls-files\n"
"\t 1 files changed, 5 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:304
msgid "Jessica’s repository looks like Figure 5-12."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:306
msgid ""
"Insert 18333fig0512.png\n"
"Figure 5-12. Jessica’s initial commit history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:309
msgid ""
"She’s ready to push up her work, but gets an e-mail from Josie that a branch "
"with some initial work on it was already pushed to the server as "
"`featureBee`. Jessica first needs to merge those changes in with her own "
"before she can push to the server. She can then fetch Josie’s changes down "
"with `git fetch`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:311
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t * [new branch]      featureBee -> origin/featureBee"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:316
msgid "Jessica can now merge this into the work she did with `git merge`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:318
msgid ""
"\t$ git merge origin/featureBee\n"
"\tAuto-merging lib/simplegit.rb\n"
"\tMerge made by recursive.\n"
"\t lib/simplegit.rb |    4 ++++\n"
"\t 1 files changed, 4 insertions(+), 0 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:324
msgid ""
"There is a bit of a problem — she needs to push the merged work in her "
"`featureB` branch to the `featureBee` branch on the server. She can do so by "
"specifying the local branch followed by a colon (:) followed by the remote "
"branch to the `git push` command:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:326
msgid ""
"\t$ git push origin featureB:featureBee\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   fba9af8..cd685d1  featureB -> featureBee"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:331
msgid ""
"This is called a _refspec_. See Chapter 9 for a more detailed discussion of "
"Git refspecs and different things you can do with them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:333
msgid ""
"Next, John e-mails Jessica to say he’s pushed some changes to the `featureA` "
"branch and ask her to verify them. She runs a `git fetch` to pull down those "
"changes:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:335
msgid ""
"\t$ git fetch origin\n"
"\t...\n"
"\tFrom jessica@githost:simplegit\n"
"\t   3300904..aad881d  featureA   -> origin/featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:340
msgid "Then, she can see what has been changed with `git log`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:342
msgid ""
"\t$ git log origin/featureA ^featureA\n"
"\tcommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6\n"
"\tAuthor: John Smith <jsmith@example.com>\n"
"\tDate:   Fri May 29 19:57:33 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:347
msgid "\t    changed log output to 30 from 25"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:349
msgid "Finally, she merges John’s work into her own `featureA` branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:351
msgid ""
"\t$ git checkout featureA\n"
"\tSwitched to branch \"featureA\"\n"
"\t$ git merge origin/featureA\n"
"\tUpdating 3300904..aad881d\n"
"\tFast forward\n"
"\t lib/simplegit.rb |   10 +++++++++-\n"
"\t1 files changed, 9 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:359
msgid ""
"Jessica wants to tweak something, so she commits again and then pushes this "
"back up to the server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:361
msgid ""
"\t$ git commit -am 'small tweak'\n"
"\t[featureA 774b3ed] small tweak\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)\n"
"\t$ git push origin featureA\n"
"\t...\n"
"\tTo jessica@githost:simplegit.git\n"
"\t   3300904..774b3ed  featureA -> featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:369
msgid "Jessica’s commit history now looks something like Figure 5-13."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:371
msgid ""
"Insert 18333fig0513.png\n"
"Figure 5-13. Jessica’s history after committing on a feature branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:374
msgid ""
"Jessica, Josie, and John inform the integrators that the `featureA` and "
"`featureBee` branches on the server are ready for integration into the "
"mainline. After they integrate these branches into the mainline, a fetch "
"will bring down the new merge commits, making the commit history look like "
"Figure 5-14."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:376
msgid ""
"Insert 18333fig0514.png\n"
"Figure 5-14. Jessica’s history after merging both her topic branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:379
msgid ""
"Many groups switch to Git because of this ability to have multiple teams "
"working in parallel, merging the different lines of work late in the "
"process. The ability of smaller subgroups of a team to collaborate via "
"remote branches without necessarily having to involve or impede the entire "
"team is a huge benefit of Git. The sequence for the workflow you saw here is "
"something like Figure 5-15."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:381
msgid ""
"Insert 18333fig0515.png\n"
"Figure 5-15. Basic sequence of this managed-team workflow."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:384
msgid "### Public Small Project ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:386
msgid ""
"Contributing to public projects is a bit different. Because you don’t have "
"the permissions to directly update branches on the project, you have to get "
"the work to the maintainers some other way. This first example describes "
"contributing via forking on Git hosts that support easy forking. The repo.or."
"cz and GitHub hosting sites both support this, and many project maintainers "
"expect this style of contribution. The next section deals with projects that "
"prefer to accept contributed patches via e-mail."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:388
msgid ""
"First, you’ll probably want to clone the main repository, create a topic "
"branch for the patch or patch series you’re planning to contribute, and do "
"your work there. The sequence looks basically like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:390
msgid ""
"\t$ git clone (url)\n"
"\t$ cd project\n"
"\t$ git checkout -b featureA\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ (work)\n"
"\t$ git commit"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:398
msgid ""
"You may want to use `rebase -i` to squash your work down to a single commit, "
"or rearrange the work in the commits to make the patch easier for the "
"maintainer to review — see Chapter 6 for more information about interactive "
"rebasing."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:400
msgid ""
"When your branch work is finished and you’re ready to contribute it back to "
"the maintainers, go to the original project page and click the \"Fork\" "
"button, creating your own writable fork of the project. You then need to add "
"in this new repository URL as a second remote, in this case named `myfork`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:402
msgid "\t$ git remote add myfork (url)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:404
msgid ""
"You need to push your work up to it. It’s easiest to push the remote branch "
"you’re working on up to your repository, rather than merging into your "
"master branch and pushing that up. The reason is that if the work isn’t "
"accepted or is cherry picked, you don’t have to rewind your master branch. "
"If the maintainers merge, rebase, or cherry-pick your work, you’ll "
"eventually get it back via pulling from their repository anyhow:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:406
msgid "\t$ git push myfork featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:408
msgid ""
"When your work has been pushed up to your fork, you need to notify the "
"maintainer. This is often called a pull request, and you can either generate "
"it via the website — GitHub has a \"pull request\" button that automatically "
"messages the maintainer — or run the `git request-pull` command and e-mail "
"the output to the project maintainer manually."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:410
msgid ""
"The `request-pull` command takes the base branch into which you want your "
"topic branch pulled and the Git repository URL you want them to pull from, "
"and outputs a summary of all the changes you’re asking to be pulled in. For "
"instance, if Jessica wants to send John a pull request, and she’s done two "
"commits on the topic branch she just pushed up, she can run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:412
msgid ""
"\t$ git request-pull origin/master myfork\n"
"\tThe following changes since commit "
"1edee6b1d61823a2de3b09c160d7080b8d1b3a40:\n"
"\t  John Smith (1):\n"
"\t        added a new function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:417
msgid "\tare available in the git repository at:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:419
msgid "\t  git://githost/simplegit.git featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:421
msgid ""
"\tJessica Smith (2):\n"
"\t      add limit to log function\n"
"\t      change log output to 30 from 25"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:425
msgid ""
"\t lib/simplegit.rb |   10 +++++++++-\n"
"\t 1 files changed, 9 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:428
msgid ""
"The output can be sent to the maintainer—it tells them where the work was "
"branched from, summarizes the commits, and tells where to pull this work "
"from."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:430
msgid ""
"On a project for which you’re not the maintainer, it’s generally easier to "
"have a branch like `master` always track `origin/master` and to do your work "
"in topic branches that you can easily discard if they’re rejected.  Having "
"work themes isolated into topic branches also makes it easier for you to "
"rebase your work if the tip of the main repository has moved in the meantime "
"and your commits no longer apply cleanly. For example, if you want to submit "
"a second topic of work to the project, don’t continue working on the topic "
"branch you just pushed up — start over from the main repository’s `master` "
"branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:432
msgid ""
"\t$ git checkout -b featureB origin/master\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ git push myfork featureB\n"
"\t$ (email maintainer)\n"
"\t$ git fetch origin"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:439
msgid ""
"Now, each of your topics is contained within a silo — similar to a patch "
"queue — that you can rewrite, rebase, and modify without the topics "
"interfering or interdepending on each other as in Figure 5-16."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:441
msgid ""
"Insert 18333fig0516.png\n"
"Figure 5-16. Initial commit history with featureB work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:444
msgid ""
"Let’s say the project maintainer has pulled in a bunch of other patches and "
"tried your first branch, but it no longer cleanly merges. In this case, you "
"can try to rebase that branch on top of `origin/master`, resolve the "
"conflicts for the maintainer, and then resubmit your changes:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:446
msgid ""
"\t$ git checkout featureA\n"
"\t$ git rebase origin/master\n"
"\t$ git push -f myfork featureA"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:450
msgid "This rewrites your history to now look like Figure 5-17."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:452
msgid ""
"Insert 18333fig0517.png\n"
"Figure 5-17. Commit history after featureA work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:455
msgid ""
"Because you rebased the branch, you have to specify the `-f` to your push "
"command in order to be able to replace the `featureA` branch on the server "
"with a commit that isn’t a descendant of it. An alternative would be to push "
"this new work to a different branch on the server (perhaps called "
"`featureAv2`)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:457
msgid ""
"Let’s look at one more possible scenario: the maintainer has looked at work "
"in your second branch and likes the concept but would like you to change an "
"implementation detail. You’ll also take this opportunity to move the work to "
"be based off the project’s current `master` branch. You start a new branch "
"based off the current `origin/master` branch, squash the `featureB` changes "
"there, resolve any conflicts, make the implementation change, and then push "
"that up as a new branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:459
msgid ""
"\t$ git checkout -b featureBv2 origin/master\n"
"\t$ git merge --no-commit --squash featureB\n"
"\t$ (change implementation)\n"
"\t$ git commit\n"
"\t$ git push myfork featureBv2"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:465
msgid ""
"The `--squash` option takes all the work on the merged branch and squashes "
"it into one non-merge commit on top of the branch you’re on. The `--no-"
"commit` option tells Git not to automatically record a commit. This allows "
"you to introduce all the changes from another branch and then make more "
"changes before recording the new commit."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:467
msgid ""
"Now you can send the maintainer a message that you’ve made the requested "
"changes and they can find those changes in your `featureBv2` branch (see "
"Figure 5-18)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:469
msgid ""
"Insert 18333fig0518.png\n"
"Figure 5-18. Commit history after featureBv2 work."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:472
msgid "### Public Large Project ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:474
msgid ""
"Many larger projects have established procedures for accepting patches — "
"you’ll need to check the specific rules for each project, because they will "
"differ. However, many larger public projects accept patches via a developer "
"mailing list, so I’ll go over an example of that now."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:476
msgid ""
"The workflow is similar to the previous use case — you create topic branches "
"for each patch series you work on. The difference is how you submit them to "
"the project. Instead of forking the project and pushing to your own writable "
"version, you generate e-mail versions of each commit series and e-mail them "
"to the developer mailing list:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:478
msgid ""
"\t$ git checkout -b topicA\n"
"\t$ (work)\n"
"\t$ git commit\n"
"\t$ (work)\n"
"\t$ git commit"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:484
msgid ""
"Now you have two commits that you want to send to the mailing list. You use "
"`git format-patch` to generate the mbox-formatted files that you can e-mail "
"to the list — it turns each commit into an e-mail message with the first "
"line of the commit message as the subject and the rest of the message plus "
"the patch that the commit introduces as the body. The nice thing about this "
"is that applying a patch from an e-mail generated with `format-patch` "
"preserves all the commit information properly, as you’ll see more of in the "
"next section when you apply these patches:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:486
msgid ""
"\t$ git format-patch -M origin/master\n"
"\t0001-add-limit-to-log-function.patch\n"
"\t0002-changed-log-output-to-30-from-25.patch"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:490
msgid ""
"The `format-patch` command prints out the names of the patch files it "
"creates. The `-M` switch tells Git to look for renames. The files end up "
"looking like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:492
msgid ""
"\t$ cat 0001-add-limit-to-log-function.patch\n"
"\tFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tDate: Sun, 6 Apr 2008 10:17:23 -0700\n"
"\tSubject: [PATCH 1/2] add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:498
msgctxt "en/05-distributed-git/01-chapter5.markdown:498"
msgid "\tLimit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:500
msgid ""
"\t---\n"
"\t lib/simplegit.rb |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:504
msgid ""
"\tdiff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"\tindex 76f47bc..f9815f1 100644\n"
"\t--- a/lib/simplegit.rb\n"
"\t+++ b/lib/simplegit.rb\n"
"\t@@ -14,7 +14,7 @@ class SimpleGit\n"
"\t   end"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:511
msgid ""
"\t   def log(treeish = 'master')\n"
"\t-    command(\"git log #{treeish}\")\n"
"\t+    command(\"git log -n 20 #{treeish}\")\n"
"\t   end"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:516
msgid ""
"\t   def ls_tree(treeish = 'master')\n"
"\t--\n"
"\t1.6.2.rc1.20.g8c5b.dirty"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:520
msgid ""
"You can also edit these patch files to add more information for the e-mail "
"list that you don’t want to show up in the commit message. If you add text "
"between the `--` line and the beginning of the patch (the `lib/simplegit.rb` "
"line), then developers can read it; but applying the patch excludes it."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:522
msgid ""
"To e-mail this to a mailing list, you can either paste the file into your e-"
"mail program or send it via a command-line program. Pasting the text often "
"causes formatting issues, especially with \"smarter\" clients that don’t "
"preserve newlines and other whitespace appropriately. Luckily, Git provides "
"a tool to help you send properly formatted patches via IMAP, which may be "
"easier for you. I’ll demonstrate how to send a patch via Gmail, which "
"happens to be the e-mail agent I use; you can read detailed instructions for "
"a number of mail programs at the end of the aforementioned `Documentation/"
"SubmittingPatches` file in the Git source code."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:524
msgid ""
"First, you need to set up the imap section in your `~/.gitconfig` file. You "
"can set each value separately with a series of `git config` commands, or you "
"can add them manually; but in the end, your config file should look "
"something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:526
msgid ""
"\t[imap]\n"
"\t  folder = \"[Gmail]/Drafts\"\n"
"\t  host = imaps://imap.gmail.com\n"
"\t  user = user@gmail.com\n"
"\t  pass = p4ssw0rd\n"
"\t  port = 993\n"
"\t  sslverify = false"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:534
msgid ""
"If your IMAP server doesn’t use SSL, the last two lines probably aren’t "
"necessary, and the host value will be `imap://` instead of `imaps://`.\n"
"When that is set up, you can use `git send-email` to place the patch series "
"in the Drafts folder of the specified IMAP server:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:537
msgid ""
"\t$ git send-email *.patch\n"
"\t0001-added-limit-to-log-function.patch\n"
"\t0002-changed-log-output-to-30-from-25.patch\n"
"\tWho should the emails appear to be from? [Jessica Smith <jessica@example."
"com>]\n"
"\tEmails will be sent from: Jessica Smith <jessica@example.com>\n"
"\tWho should the emails be sent to? jessica@example.com\n"
"\tMessage-ID to be used as In-Reply-To for the first email? y"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:545
msgid ""
"Then, Git spits out a bunch of log information looking something like this "
"for each patch you’re sending:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:547
msgid ""
"\t(mbox) Adding cc: Jessica Smith <jessica@example.com> from\n"
"\t  \\line 'From: Jessica Smith <jessica@example.com>'\n"
"\tOK. Log says:\n"
"\tSendmail: /usr/sbin/sendmail -i jessica@example.com\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tTo: jessica@example.com\n"
"\tSubject: [PATCH 1/2] added limit to log function\n"
"\tDate: Sat, 30 May 2009 13:29:15 -0700\n"
"\tMessage-Id: <1243715356-61726-1-git-send-email-jessica@example.com>\n"
"\tX-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty\n"
"\tIn-Reply-To: <y>\n"
"\tReferences: <y>"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:560
msgid "\tResult: OK"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:562
msgid ""
"At this point, you should be able to go to your Drafts folder, change the To "
"field to the mailing list you’re sending the patch to, possibly CC the "
"maintainer or person responsible for that section, and send it off."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:564
#, fuzzy
msgid "### Summary ###"
msgstr "## 요약 ##"

#: en/05-distributed-git/01-chapter5.markdown:566
msgid ""
"This section has covered a number of common workflows for dealing with "
"several very different types of Git projects you’re likely to encounter and "
"introduced a couple of new tools to help you manage this process. Next, "
"you’ll see how to work the other side of the coin: maintaining a Git "
"project. You’ll learn how to be a benevolent dictator or integration manager."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:568
msgid "## Maintaining a Project ##"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:570
msgid ""
"In addition to knowing how to effectively contribute to a project, you’ll "
"likely need to know how to maintain one. This can consist of accepting and "
"applying patches generated via `format-patch` and e-mailed to you, or "
"integrating changes in remote branches for repositories you’ve added as "
"remotes to your project. Whether you maintain a canonical repository or want "
"to help by verifying or approving patches, you need to know how to accept "
"work in a way that is clearest for other contributors and sustainable by you "
"over the long run."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:572
msgid "### Working in Topic Branches ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:574
msgid ""
"When you’re thinking of integrating new work, it’s generally a good idea to "
"try it out in a topic branch — a temporary branch specifically made to try "
"out that new work. This way, it’s easy to tweak a patch individually and "
"leave it if it’s not working until you have time to come back to it. If you "
"create a simple branch name based on the theme of the work you’re going to "
"try, such as `ruby_client` or something similarly descriptive, you can "
"easily remember it if you have to abandon it for a while and come back "
"later. The maintainer of the Git project tends to namespace these branches "
"as well — such as `sc/ruby_client`, where `sc` is short for the person who "
"contributed the work.\n"
"As you’ll remember, you can create the branch based off your master branch "
"like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:577
msgid "\t$ git branch sc/ruby_client master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:579
msgid ""
"Or, if you want to also switch to it immediately, you can use the `checkout -"
"b` command:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:581
msgid "\t$ git checkout -b sc/ruby_client master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:583
msgid ""
"Now you’re ready to add your contributed work into this topic branch and "
"determine if you want to merge it into your longer-term branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:585
msgid "### Applying Patches from E-mail ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:587
msgid ""
"If you receive a patch over e-mail that you need to integrate into your "
"project, you need to apply the patch in your topic branch to evaluate it. "
"There are two ways to apply an e-mailed patch: with `git apply` or with `git "
"am`."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:589
msgid "#### Applying a Patch with apply ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:591
msgid ""
"If you received the patch from someone who generated it with the `git diff` "
"or a Unix `diff` command, you can apply it with the `git apply` command. "
"Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can "
"apply the patch like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:593
msgid "\t$ git apply /tmp/patch-ruby-client.patch"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:595
msgid ""
"This modifies the files in your working directory. It’s almost identical to "
"running a `patch -p1` command to apply the patch, although it’s more "
"paranoid and accepts fewer fuzzy matches than patch. It also handles file "
"adds, deletes, and renames if they’re described in the `git diff` format, "
"which `patch` won’t do. Finally, `git apply` is an \"apply all or abort all"
"\" model where either everything is applied or nothing is, whereas `patch` "
"can partially apply patchfiles, leaving your working directory in a weird "
"state. `git apply` is overall much more paranoid than `patch`. It won’t "
"create a commit for you — after running it, you must stage and commit the "
"changes introduced manually."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:597
msgid ""
"You can also use git apply to see if a patch applies cleanly before you try "
"actually applying it — you can run `git apply --check` with the patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:599
msgid ""
"\t$ git apply --check 0001-seeing-if-this-helps-the-gem.patch\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:603
msgid ""
"If there is no output, then the patch should apply cleanly. This command "
"also exits with a non-zero status if the check fails, so you can use it in "
"scripts if you want."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:605
msgid "#### Applying a Patch with am ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:607
msgid ""
"If the contributor is a Git user and was good enough to use the `format-"
"patch` command to generate their patch, then your job is easier because the "
"patch contains author information and a commit message for you. If you can, "
"encourage your contributors to use `format-patch` instead of `diff` to "
"generate patches for you. You should only have to use `git apply` for legacy "
"patches and things like that."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:609
msgid ""
"To apply a patch generated by `format-patch`, you use `git am`. Technically, "
"`git am` is built to read an mbox file, which is a simple, plain-text format "
"for storing one or more e-mail messages in one text file. It looks something "
"like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:611
msgid ""
"\tFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\n"
"\tFrom: Jessica Smith <jessica@example.com>\n"
"\tDate: Sun, 6 Apr 2008 10:17:23 -0700\n"
"\tSubject: [PATCH 1/2] add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:616
msgctxt "en/05-distributed-git/01-chapter5.markdown:616"
msgid "\tLimit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:618
msgid ""
"This is the beginning of the output of the format-patch command that you saw "
"in the previous section. This is also a valid mbox e-mail format. If someone "
"has e-mailed you the patch properly using git send-email, and you download "
"that into an mbox format, then you can point git am to that mbox file, and "
"it will start applying all the patches it sees. If you run a mail client "
"that can save several e-mails out in mbox format, you can save entire patch "
"series into a file and then use git am to apply them one at a time."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:620
msgid ""
"However, if someone uploaded a patch file generated via `format-patch` to a "
"ticketing system or something similar, you can save the file locally and "
"then pass that file saved on your disk to `git am` to apply it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:622
msgid ""
"\t$ git am 0001-limit-log-function.patch\n"
"\tApplying: add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:625
msgid ""
"You can see that it applied cleanly and automatically created the new commit "
"for you. The author information is taken from the e-mail’s `From` and `Date` "
"headers, and the message of the commit is taken from the `Subject` and body "
"(before the patch) of the e-mail. For example, if this patch was applied "
"from the mbox example I just showed, the commit generated would look "
"something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:627
msgid ""
"\t$ git log --pretty=fuller -1\n"
"\tcommit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\n"
"\tAuthor:     Jessica Smith <jessica@example.com>\n"
"\tAuthorDate: Sun Apr 6 10:17:23 2008 -0700\n"
"\tCommit:     Scott Chacon <schacon@gmail.com>\n"
"\tCommitDate: Thu Apr 9 09:19:06 2009 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:634
msgid "\t   add limit to log function"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:636
msgid "\t   Limit log functionality to the first 20"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:638
msgid ""
"The `Commit` information indicates the person who applied the patch and the "
"time it was applied. The `Author` information is the individual who "
"originally created the patch and when it was originally created."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:640
msgid ""
"But it’s possible that the patch won’t apply cleanly. Perhaps your main "
"branch has diverged too far from the branch the patch was built from, or the "
"patch depends on another patch you haven’t applied yet. In that case, the "
"`git am` process will fail and ask you what you want to do:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:642
msgid ""
"\t$ git am 0001-seeing-if-this-helps-the-gem.patch\n"
"\tApplying: seeing if this helps the gem\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply\n"
"\tPatch failed at 0001.\n"
"\tWhen you have resolved this problem run \"git am --resolved\".\n"
"\tIf you would prefer to skip this patch, instead run \"git am --skip\".\n"
"\tTo restore the original branch and stop patching run \"git am --abort\"."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:651
msgid ""
"This command puts conflict markers in any files it has issues with, much "
"like a conflicted merge or rebase operation. You solve this issue much the "
"same way — edit the file to resolve the conflict, stage the new file, and "
"then run `git am --resolved` to continue to the next patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:653
msgid ""
"\t$ (fix the file)\n"
"\t$ git add ticgit.gemspec\n"
"\t$ git am --resolved\n"
"\tApplying: seeing if this helps the gem"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:658
msgid ""
"If you want Git to try a bit more intelligently to resolve the conflict, you "
"can pass a `-3` option to it, which makes Git attempt a three-way merge. "
"This option isn’t on by default because it doesn’t work if the commit the "
"patch says it was based on isn’t in your repository. If you do have that "
"commit — if the patch was based on a public commit — then the `-3` option is "
"generally much smarter about applying a conflicting patch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:660
msgid ""
"\t$ git am -3 0001-seeing-if-this-helps-the-gem.patch\n"
"\tApplying: seeing if this helps the gem\n"
"\terror: patch failed: ticgit.gemspec:1\n"
"\terror: ticgit.gemspec: patch does not apply\n"
"\tUsing index info to reconstruct a base tree...\n"
"\tFalling back to patching base and 3-way merge...\n"
"\tNo changes -- Patch already applied."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:668
msgid ""
"In this case, I was trying to apply a patch I had already applied. Without "
"the `-3` option, it looks like a conflict."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:670
msgid ""
"If you’re applying a number of patches from an mbox, you can also run the "
"`am` command in interactive mode, which stops at each patch it finds and "
"asks if you want to apply it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:672
msgid ""
"\t$ git am -3 -i mbox\n"
"\tCommit Body is:\n"
"\t--------------------------\n"
"\tseeing if this helps the gem\n"
"\t--------------------------\n"
"\tApply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:679
msgid ""
"This is nice if you have a number of patches saved, because you can view the "
"patch first if you don’t remember what it is, or not apply the patch if "
"you’ve already done so."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:681
msgid ""
"When all the patches for your topic are applied and committed into your "
"branch, you can choose whether and how to integrate them into a longer-"
"running branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:683
msgid "### Checking Out Remote Branches ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:685
msgid ""
"If your contribution came from a Git user who set up their own repository, "
"pushed a number of changes into it, and then sent you the URL to the "
"repository and the name of the remote branch the changes are in, you can add "
"them as a remote and do merges locally."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:687
msgid ""
"For instance, if Jessica sends you an e-mail saying that she has a great new "
"feature in the `ruby-client` branch of her repository, you can test it by "
"adding the remote and checking out that branch locally:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:689
msgid ""
"\t$ git remote add jessica git://github.com/jessica/myproject.git\n"
"\t$ git fetch jessica\n"
"\t$ git checkout -b rubyclient jessica/ruby-client"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:693
msgid ""
"If she e-mails you again later with another branch containing another great "
"feature, you can fetch and check out because you already have the remote "
"setup."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:695
msgid ""
"This is most useful if you’re working with a person consistently. If someone "
"only has a single patch to contribute once in a while, then accepting it "
"over e-mail may be less time consuming than requiring everyone to run their "
"own server and having to continually add and remove remotes to get a few "
"patches. You’re also unlikely to want to have hundreds of remotes, each for "
"someone who contributes only a patch or two. However, scripts and hosted "
"services may make this easier — it depends largely on how you develop and "
"how your contributors develop."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:697
msgid ""
"The other advantage of this approach is that you get the history of the "
"commits as well. Although you may have legitimate merge issues, you know "
"where in your history their work is based; a proper three-way merge is the "
"default rather than having to supply a `-3` and hope the patch was generated "
"off a public commit to which you have access."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:699
msgid ""
"If you aren’t working with a person consistently but still want to pull from "
"them in this way, you can provide the URL of the remote repository to the "
"`git pull` command. This does a one-time pull and doesn’t save the URL as a "
"remote reference:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:701
msgid ""
"\t$ git pull git://github.com/onetimeguy/project.git\n"
"\tFrom git://github.com/onetimeguy/project\n"
"\t * branch            HEAD       -> FETCH_HEAD\n"
"\tMerge made by recursive."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:706
msgid "### Determining What Is Introduced ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:708
msgid ""
"Now you have a topic branch that contains contributed work. At this point, "
"you can determine what you’d like to do with it. This section revisits a "
"couple of commands so you can see how you can use them to review exactly "
"what you’ll be introducing if you merge this into your main branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:710
msgid ""
"It’s often helpful to get a review of all the commits that are in this "
"branch but that aren’t in your master branch. You can exclude commits in the "
"master branch by adding the `--not` option before the branch name. For "
"example, if your contributor sends you two patches and you create a branch "
"called `contrib` and applied those patches there, you can run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:712
msgid ""
"\t$ git log contrib --not master\n"
"\tcommit 5b6235bd297351589efc4d73316f0a68d484f118\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri Oct 24 09:53:59 2008 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:717
msgid "\t    seeing if this helps the gem"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:719
msgid ""
"\tcommit 7482e0d16d04bea79d0dba8988cc78df655f16a0\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Mon Oct 22 19:38:36 2008 -0700"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:723
msgid "\t    updated the gemspec to hopefully work better"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:725
msgid ""
"To see what changes each commit introduces, remember that you can pass the `-"
"p` option to `git log` and it will append the diff introduced to each commit."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:727
msgid ""
"To see a full diff of what would happen if you were to merge this topic "
"branch with another branch, you may have to use a weird trick to get the "
"correct results. You may think to run this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:729
msgid "\t$ git diff master"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:731
msgid ""
"This command gives you a diff, but it may be misleading. If your `master` "
"branch has moved forward since you created the topic branch from it, then "
"you’ll get seemingly strange results. This happens because Git directly "
"compares the snapshots of the last commit of the topic branch you’re on and "
"the snapshot of the last commit on the `master` branch. For example, if "
"you’ve added a line in a file on the `master` branch, a direct comparison of "
"the snapshots will look like the topic branch is going to remove that line."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:733
msgid ""
"If `master` is a direct ancestor of your topic branch, this isn’t a problem; "
"but if the two histories have diverged, the diff will look like you’re "
"adding all the new stuff in your topic branch and removing everything unique "
"to the `master` branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:735
msgid ""
"What you really want to see are the changes added to the topic branch — the "
"work you’ll introduce if you merge this branch with master. You do that by "
"having Git compare the last commit on your topic branch with the first "
"common ancestor it has with the master branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:737
msgid ""
"Technically, you can do that by explicitly figuring out the common ancestor "
"and then running your diff on it:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:739
msgid ""
"\t$ git merge-base contrib master\n"
"\t36c7dba2c95e6bbb78dfa822519ecfec6e1ca649\n"
"\t$ git diff 36c7db"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:743
msgid ""
"However, that isn’t convenient, so Git provides another shorthand for doing "
"the same thing: the triple-dot syntax. In the context of the `diff` command, "
"you can put three periods after another branch to do a `diff` between the "
"last commit of the branch you’re on and its common ancestor with another "
"branch:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:745
msgid "\t$ git diff master...contrib"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:747
msgid ""
"This command shows you only the work your current topic branch has "
"introduced since its common ancestor with master. That is a very useful "
"syntax to remember."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:749
msgid "### Integrating Contributed Work ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:751
msgid ""
"When all the work in your topic branch is ready to be integrated into a more "
"mainline branch, the question is how to do it. Furthermore, what overall "
"workflow do you want to use to maintain your project? You have a number of "
"choices, so I’ll cover a few of them."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:753
msgid "#### Merging Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:755
msgid ""
"One simple workflow merges your work into your `master` branch. In this "
"scenario, you have a `master` branch that contains basically stable code. "
"When you have work in a topic branch that you’ve done or that someone has "
"contributed and you’ve verified, you merge it into your master branch, "
"delete the topic branch, and then continue the process.  If we have a "
"repository with work in two branches named `ruby_client` and `php_client` "
"that looks like Figure 5-19 and merge `ruby_client` first and then "
"`php_client` next, then your history will end up looking like Figure 5-20."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:757
msgid ""
"Insert 18333fig0519.png\n"
"Figure 5-19. History with several topic branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:760
msgid ""
"Insert 18333fig0520.png\n"
"Figure 5-20. After a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:763
msgid ""
"That is probably the simplest workflow, but it’s problematic if you’re "
"dealing with larger repositories or projects."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:765
msgid ""
"If you have more developers or a larger project, you’ll probably want to use "
"at least a two-phase merge cycle. In this scenario, you have two long-"
"running branches, `master` and `develop`, in which you determine that "
"`master` is updated only when a very stable release is cut and all new code "
"is integrated into the `develop` branch. You regularly push both of these "
"branches to the public repository. Each time you have a new topic branch to "
"merge in (Figure 5-21), you merge it into `develop` (Figure 5-22); then, "
"when you tag a release, you fast-forward `master` to wherever the now-stable "
"`develop` branch is (Figure 5-23)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:767
msgid ""
"Insert 18333fig0521.png\n"
"Figure 5-21. Before a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:770
msgid ""
"Insert 18333fig0522.png\n"
"Figure 5-22. After a topic branch merge."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:773
msgid ""
"Insert 18333fig0523.png\n"
"Figure 5-23. After a topic branch release."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:776
msgid ""
"This way, when people clone your project’s repository, they can either check "
"out master to build the latest stable version and keep up to date on that "
"easily, or they can check out develop, which is the more cutting-edge "
"stuff.\n"
"You can also continue this concept, having an integrate branch where all the "
"work is merged together. Then, when the codebase on that branch is stable "
"and passes tests, you merge it into a develop branch; and when that has "
"proven itself stable for a while, you fast-forward your master branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:779
msgid "#### Large-Merging Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:781
msgid ""
"The Git project has four long-running branches: `master`, `next`, and `pu` "
"(proposed updates) for new work, and `maint` for maintenance backports. When "
"new work is introduced by contributors, it’s collected into topic branches "
"in the maintainer’s repository in a manner similar to what I’ve described "
"(see Figure 5-24). At this point, the topics are evaluated to determine "
"whether they’re safe and ready for consumption or whether they need more "
"work. If they’re safe, they’re merged into `next`, and that branch is pushed "
"up so everyone can try the topics integrated together."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:783
msgid ""
"Insert 18333fig0524.png\n"
"Figure 5-24. Managing a complex series of parallel contributed topic "
"branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:786
msgid ""
"If the topics still need work, they’re merged into `pu` instead. When it’s "
"determined that they’re totally stable, the topics are re-merged into "
"`master` and are then rebuilt from the topics that were in `next` but didn’t "
"yet graduate to `master`. This means `master` almost always moves forward, "
"`next` is rebased occasionally, and `pu` is rebased even more often (see "
"Figure 5-25)."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:788
msgid ""
"Insert 18333fig0525.png\n"
"Figure 5-25. Merging contributed topic branches into long-term integration "
"branches."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:791
msgid ""
"When a topic branch has finally been merged into `master`, it’s removed from "
"the repository. The Git project also has a `maint` branch that is forked off "
"from the last release to provide backported patches in case a maintenance "
"release is required. Thus, when you clone the Git repository, you have four "
"branches that you can check out to evaluate the project in different stages "
"of development, depending on how cutting edge you want to be or how you want "
"to contribute; and the maintainer has a structured workflow to help them vet "
"new contributions."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:793
msgid "#### Rebasing and Cherry Picking Workflows ####"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:795
msgid ""
"Other maintainers prefer to rebase or cherry-pick contributed work on top of "
"their master branch, rather than merging it in, to keep a mostly linear "
"history. When you have work in a topic branch and have determined that you "
"want to integrate it, you move to that branch and run the rebase command to "
"rebuild the changes on top of your current master (or `develop`, and so on) "
"branch. If that works well, you can fast-forward your `master` branch, and "
"you’ll end up with a linear project history."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:797
msgid ""
"The other way to move introduced work from one branch to another is to "
"cherry-pick it. A cherry-pick in Git is like a rebase for a single commit. "
"It takes the patch that was introduced in a commit and tries to reapply it "
"on the branch you’re currently on. This is useful if you have a number of "
"commits on a topic branch and you want to integrate only one of them, or if "
"you only have one commit on a topic branch and you’d prefer to cherry-pick "
"it rather than run rebase. For example, suppose you have a project that "
"looks like Figure 5-26."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:799
msgid ""
"Insert 18333fig0526.png\n"
"Figure 5-26. Example history before a cherry pick."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:802
msgid "If you want to pull commit `e43a6` into your master branch, you can run"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:804
msgid ""
"\t$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf\n"
"\tFinished one cherry-pick.\n"
"\t[master]: created a0a41a9: \"More friendly message when locking the index "
"fails.\"\n"
"\t 3 files changed, 17 insertions(+), 3 deletions(-)"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:809
msgid ""
"This pulls the same change introduced in `e43a6`, but you get a new commit "
"SHA-1 value, because the date applied is different. Now your history looks "
"like Figure 5-27."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:811
msgid ""
"Insert 18333fig0527.png\n"
"Figure 5-27. History after cherry-picking a commit on a topic branch."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:814
msgid ""
"Now you can remove your topic branch and drop the commits you didn’t want to "
"pull in."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:816
msgid "### Tagging Your Releases ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:818
msgid ""
"When you’ve decided to cut a release, you’ll probably want to drop a tag so "
"you can re-create that release at any point going forward. You can create a "
"new tag as I discussed in Chapter 2. If you decide to sign the tag as the "
"maintainer, the tagging may look something like this:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:820
msgid ""
"\t$ git tag -s v1.5 -m 'my signed 1.5 tag'\n"
"\tYou need a passphrase to unlock the secret key for\n"
"\tuser: \"Scott Chacon <schacon@gmail.com>\"\n"
"\t1024-bit DSA key, ID F721C45A, created 2009-02-09"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:825
msgid ""
"If you do sign your tags, you may have the problem of distributing the "
"public PGP key used to sign your tags. The maintainer of the Git project has "
"solved this issue by including their public key as a blob in the repository "
"and then adding a tag that points directly to that content. To do this, you "
"can figure out which key you want by running `gpg --list-keys`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:827
msgid ""
"\t$ gpg --list-keys\n"
"\t/Users/schacon/.gnupg/pubring.gpg\n"
"\t---------------------------------\n"
"\tpub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]\n"
"\tuid                  Scott Chacon <schacon@gmail.com>\n"
"\tsub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:834
msgid ""
"Then, you can directly import the key into the Git database by exporting it "
"and piping that through `git hash-object`, which writes a new blob with "
"those contents into Git and gives you back the SHA-1 of the blob:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:836
msgid ""
"\t$ gpg -a --export F721C45A | git hash-object -w --stdin\n"
"\t659ef797d181633c87ec71ac3f9ba29fe5775b92"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:839
msgid ""
"Now that you have the contents of your key in Git, you can create a tag that "
"points directly to it by specifying the new SHA-1 value that the `hash-"
"object` command gave you:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:841
msgid ""
"\t$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:843
msgid ""
"If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared "
"with everyone. If anyone wants to verify a tag, they can directly import "
"your PGP key by pulling the blob directly out of the database and importing "
"it into GPG:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:845
msgid "\t$ git show maintainer-pgp-pub | gpg --import"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:847
msgid ""
"They can use that key to verify all your signed tags. Also, if you include "
"instructions in the tag message, running `git show <tag>` will let you give "
"the end user more specific instructions about tag verification."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:849
msgid "### Generating a Build Number ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:851
msgid ""
"Because Git doesn’t have monotonically increasing numbers like 'v123' or the "
"equivalent to go with each commit, if you want to have a human-readable name "
"to go with a commit, you can run `git describe` on that commit. Git gives "
"you the name of the nearest tag with the number of commits on top of that "
"tag and a partial SHA-1 value of the commit you’re describing:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:853
msgid ""
"\t$ git describe master\n"
"\tv1.6.2-rc1-20-g8c5b85c"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:856
msgid ""
"This way, you can export a snapshot or build and name it something "
"understandable to people. In fact, if you build Git from source code cloned "
"from the Git repository, `git --version` gives you something that looks like "
"this. If you’re describing a commit that you have directly tagged, it gives "
"you the tag name."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:858
msgid ""
"The `git describe` command favors annotated tags (tags created with the `-a` "
"or `-s` flag), so release tags should be created this way if you’re using "
"`git describe`, to ensure the commit is named properly when described. You "
"can also use this string as the target of a checkout or show command, "
"although it relies on the abbreviated SHA-1 value at the end, so it may not "
"be valid forever. For instance, the Linux kernel recently jumped from 8 to "
"10 characters to ensure SHA-1 object uniqueness, so older `git describe` "
"output names were invalidated."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:860
msgid "### Preparing a Release ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:862
msgid ""
"Now you want to release a build. One of the things you’ll want to do is "
"create an archive of the latest snapshot of your code for those poor souls "
"who don’t use Git. The command to do this is `git archive`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:864
msgid ""
"\t$ git archive master --prefix='project/' | gzip > `git describe master`."
"tar.gz\n"
"\t$ ls *.tar.gz\n"
"\tv1.6.2-rc1-20-g8c5b85c.tar.gz"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:868
msgid ""
"If someone opens that tarball, they get the latest snapshot of your project "
"under a project directory. You can also create a zip archive in much the "
"same way, but by passing the `--format=zip` option to `git archive`:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:870
msgid ""
"\t$ git archive master --prefix='project/' --format=zip > `git describe "
"master`.zip"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:872
msgid ""
"You now have a nice tarball and a zip archive of your project release that "
"you can upload to your website or e-mail to people."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:874
msgid "### The Shortlog ###"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:876
msgid ""
"It’s time to e-mail your mailing list of people who want to know what’s "
"happening in your project. A nice way of quickly getting a sort of changelog "
"of what has been added to your project since your last release or e-mail is "
"to use the `git shortlog` command. It summarizes all the commits in the "
"range you give it; for example, the following gives you a summary of all the "
"commits since your last release, if your last release was named v1.0.1:"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:878
msgid ""
"\t$ git shortlog --no-merges master --not v1.0.1\n"
"\tChris Wanstrath (8):\n"
"\t      Add support for annotated tags to Grit::Tag\n"
"\t      Add packed-refs annotated tag support.\n"
"\t      Add Grit::Commit#to_patch\n"
"\t      Update version and History.txt\n"
"\t      Remove stray `puts`\n"
"\t      Make ls_tree ignore nils"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:887
msgid ""
"\tTom Preston-Werner (4):\n"
"\t      fix dates in history\n"
"\t      dynamic version method\n"
"\t      Version bump to 1.0.2\n"
"\t      Regenerated gemspec for version 1.0.2"
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:893
msgid ""
"You get a clean summary of all the commits since v1.0.1, grouped by author, "
"that you can e-mail to your list."
msgstr ""

#: en/05-distributed-git/01-chapter5.markdown:897
msgid ""
"You should feel fairly comfortable contributing to a project in Git as well "
"as maintaining your own project or integrating other users’ contributions. "
"Congratulations on being an effective Git developer! In the next chapter, "
"you’ll learn more powerful tools and tips for dealing with complex "
"situations, which will truly make you a Git master."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1
msgid "# Git Tools #"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:3
msgid ""
"By now, you’ve learned most of the day-to-day commands and workflows that "
"you need to manage or maintain a Git repository for your source code "
"control. You’ve accomplished the basic tasks of tracking and committing "
"files, and you’ve harnessed the power of the staging area and lightweight "
"topic branching and merging."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:5
msgid ""
"Now you’ll explore a number of very powerful things that Git can do that you "
"may not necessarily use on a day-to-day basis but that you may need at some "
"point."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:7
msgid "## Revision Selection ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:9
msgid ""
"Git allows you to specify specific commits or a range of commits in several "
"ways. They aren’t necessarily obvious but are helpful to know."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:11
msgid "### Single Revisions ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:13
msgid ""
"You can obviously refer to a commit by the SHA-1 hash that it’s given, but "
"there are more human-friendly ways to refer to commits as well. This section "
"outlines the various ways you can refer to a single commit."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:15
msgid "### Short SHA ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:17
msgid ""
"Git is smart enough to figure out what commit you meant to type if you "
"provide the first few characters, as long as your partial SHA-1 is at least "
"four characters long and unambiguous — that is, only one object in the "
"current repository begins with that partial SHA-1."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:19
msgid ""
"For example, to see a specific commit, suppose you run a `git log` command "
"and identify the commit where you added certain functionality:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:21
msgid ""
"\t$ git log\n"
"\tcommit 734713bc047d87bf7eac9674765ae793478c50d3\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri Jan 2 18:32:33 2009 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:26
msgctxt "en/06-git-tools/01-chapter6.markdown:26"
msgid "\t    fixed refs handling, added gc auto, updated tests"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:28
msgid ""
"\tcommit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"\tMerge: 1c002dd... 35cfb2b...\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Dec 11 15:08:43 2008 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:33
msgctxt "en/06-git-tools/01-chapter6.markdown:33"
msgid "\t    Merge commit 'phedders/rdocs'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:35
msgid ""
"\tcommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Dec 11 14:58:32 2008 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:39
msgctxt "en/06-git-tools/01-chapter6.markdown:39"
msgid "\t    added some blame and merge stuff"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:41
msgid ""
"In this case, choose `1c002dd....` If you `git show` that commit, the "
"following commands are equivalent (assuming the shorter versions are "
"unambiguous):"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:43
msgid ""
"\t$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"\t$ git show 1c002dd4b536e7479f\n"
"\t$ git show 1c002d"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:47
msgid ""
"Git can figure out a short, unique abbreviation for your SHA-1 values. If "
"you pass `--abbrev-commit` to the `git log` command, the output will use "
"shorter values but keep them unique; it defaults to using seven characters "
"but makes them longer if necessary to keep the SHA-1 unambiguous:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:49
msgid ""
"\t$ git log --abbrev-commit --pretty=oneline\n"
"\tca82a6d changed the version number\n"
"\t085bb3b removed unnecessary test code\n"
"\ta11bef0 first commit"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:54
msgid ""
"Generally, eight to ten characters are more than enough to be unique within "
"a project. One of the largest Git projects, the Linux kernel, is beginning "
"to need 12 characters out of the possible 40 to stay unique."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:56
msgid "### A SHORT NOTE ABOUT SHA-1 ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:58
msgid ""
"A lot of people become concerned at some point that they will, by random "
"happenstance, have two objects in their repository that hash to the same "
"SHA-1 value. What then?"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:60
msgid ""
"If you do happen to commit an object that hashes to the same SHA-1 value as "
"a previous object in your repository, Git will see the previous object "
"already in your Git database and assume it was already written. If you try "
"to check out that object again at some point, you’ll always get the data of "
"the first object."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:62
msgid ""
"However, you should be aware of how ridiculously unlikely this scenario is. "
"The SHA-1 digest is 20 bytes or 160 bits. The number of randomly hashed "
"objects needed to ensure a 50% probability of a single collision is about "
"2^80 (the formula for determining collision probability is `p = (n(n-1)/2) * "
"(1/2^160))`. 2^80 is 1.2 x 10^24 or 1 million billion billion. That’s 1,200 "
"times the number of grains of sand on the earth."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:64
msgid ""
"Here’s an example to give you an idea of what it would take to get a SHA-1 "
"collision. If all 6.5 billion humans on Earth were programming, and every "
"second, each one was producing code that was the equivalent of the entire "
"Linux kernel history (1 million Git objects) and pushing it into one "
"enormous Git repository, it would take 5 years until that repository "
"contained enough objects to have a 50% probability of a single SHA-1 object "
"collision. A higher probability exists that every member of your programming "
"team will be attacked and killed by wolves in unrelated incidents on the "
"same night."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:66
msgid "### Branch References ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:68
msgid ""
"The most straightforward way to specify a commit requires that it have a "
"branch reference pointed at it. Then, you can use a branch name in any Git "
"command that expects a commit object or SHA-1 value. For instance, if you "
"want to show the last commit object on a branch, the following commands are "
"equivalent, assuming that the `topic1` branch points to `ca82a6d`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:70
msgid ""
"\t$ git show ca82a6dff817ec66f44342007202690a93763949\n"
"\t$ git show topic1"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:73
msgid ""
"If you want to see which specific SHA a branch points to, or if you want to "
"see what any of these examples boils down to in terms of SHAs, you can use a "
"Git plumbing tool called `rev-parse`. You can see Chapter 9 for more "
"information about plumbing tools; basically, `rev-parse` exists for lower-"
"level operations and isn’t designed to be used in day-to-day operations. "
"However, it can be helpful sometimes when you need to see what’s really "
"going on. Here you can run `rev-parse` on your branch."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:75
msgid ""
"\t$ git rev-parse topic1\n"
"\tca82a6dff817ec66f44342007202690a93763949"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:78
msgid "### RefLog Shortnames ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:80
msgid ""
"One of the things Git does in the background while you’re working away is "
"keep a reflog — a log of where your HEAD and branch references have been for "
"the last few months."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:82
msgid "You can see your reflog by using `git reflog`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:84
msgid ""
"\t$ git reflog\n"
"\t734713b... HEAD@{0}: commit: fixed refs handling, added gc auto, updated\n"
"\td921970... HEAD@{1}: merge phedders/rdocs: Merge made by recursive.\n"
"\t1c002dd... HEAD@{2}: commit: added some blame and merge stuff\n"
"\t1c36188... HEAD@{3}: rebase -i (squash): updating HEAD\n"
"\t95df984... HEAD@{4}: commit: # This is a combination of two commits.\n"
"\t1c36188... HEAD@{5}: rebase -i (squash): updating HEAD\n"
"\t7e05da5... HEAD@{6}: rebase -i (pick): updating HEAD"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:93
msgid ""
"Every time your branch tip is updated for any reason, Git stores that "
"information for you in this temporary history. And you can specify older "
"commits with this data, as well. If you want to see the fifth prior value of "
"the HEAD of your repository, you can use the `@{n}` reference that you see "
"in the reflog output:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:95
msgid "\t$ git show HEAD@{5}"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:97
msgid ""
"You can also use this syntax to see where a branch was some specific amount "
"of time ago. For instance, to see where your `master` branch was yesterday, "
"you can type"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:99
msgid "\t$ git show master@{yesterday}"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:101
msgid ""
"That shows you where the branch tip was yesterday. This technique only works "
"for data that’s still in your reflog, so you can’t use it to look for "
"commits older than a few months."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:103
msgid ""
"To see reflog information formatted like the `git log` output, you can run "
"`git log -g`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:105
msgid ""
"\t$ git log -g master\n"
"\tcommit 734713bc047d87bf7eac9674765ae793478c50d3\n"
"\tReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\n"
"\tReflog message: commit: fixed refs handling, added gc auto, updated\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri Jan 2 18:32:33 2009 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:112
msgctxt "en/06-git-tools/01-chapter6.markdown:112"
msgid "\t    fixed refs handling, added gc auto, updated tests"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:114
msgid ""
"\tcommit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"\tReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\n"
"\tReflog message: merge phedders/rdocs: Merge made by recursive.\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Dec 11 15:08:43 2008 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:120
msgctxt "en/06-git-tools/01-chapter6.markdown:120"
msgid "\t    Merge commit 'phedders/rdocs'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:122
msgid ""
"It’s important to note that the reflog information is strictly local — it’s "
"a log of what you’ve done in your repository. The references won’t be the "
"same on someone else’s copy of the repository; and right after you initially "
"clone a repository, you’ll have an empty reflog, as no activity has occurred "
"yet in your repository. Running `git show HEAD@{2.months.ago}` will work "
"only if you cloned the project at least two months ago — if you cloned it "
"five minutes ago, you’ll get no results."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:124
msgid "### Ancestry References ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:126
msgid ""
"The other main way to specify a commit is via its ancestry. If you place a "
"`^` at the end of a reference, Git resolves it to mean the parent of that "
"commit.\n"
"Suppose you look at the history of your project:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:129
msgid ""
"\t$ git log --pretty=format:'%h %s' --graph\n"
"\t* 734713b fixed refs handling, added gc auto, updated tests\n"
"\t*   d921970 Merge commit 'phedders/rdocs'\n"
"\t|\\\n"
"\t| * 35cfb2b Some rdoc changes\n"
"\t* | 1c002dd added some blame and merge stuff\n"
"\t|/\n"
"\t* 1c36188 ignore *.gem\n"
"\t* 9b29157 add open3_detach to gemspec file list"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:139
msgid ""
"Then, you can see the previous commit by specifying `HEAD^`, which means "
"\"the parent of HEAD\":"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:141
msgid ""
"\t$ git show HEAD^\n"
"\tcommit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"\tMerge: 1c002dd... 35cfb2b...\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Dec 11 15:08:43 2008 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:147
msgctxt "en/06-git-tools/01-chapter6.markdown:147"
msgid "\t    Merge commit 'phedders/rdocs'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:149
msgid ""
"You can also specify a number after the `^` — for example, `d921970^2` means "
"\"the second parent of d921970.\" This syntax is only useful for merge "
"commits, which have more than one parent. The first parent is the branch you "
"were on when you merged, and the second is the commit on the branch that you "
"merged in:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:151
msgid ""
"\t$ git show d921970^\n"
"\tcommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Dec 11 14:58:32 2008 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:156
msgctxt "en/06-git-tools/01-chapter6.markdown:156"
msgid "\t    added some blame and merge stuff"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:158
msgid ""
"\t$ git show d921970^2\n"
"\tcommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\n"
"\tAuthor: Paul Hedderly <paul+git@mjr.org>\n"
"\tDate:   Wed Dec 10 22:22:03 2008 +0000"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:163
msgid "\t    Some rdoc changes"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:165
msgid ""
"The other main ancestry specification is the `~`. This also refers to the "
"first parent, so `HEAD~` and `HEAD^` are equivalent. The difference becomes "
"apparent when you specify a number. `HEAD~2` means \"the first parent of the "
"first parent,\" or \"the grandparent\" — it traverses the first parents the "
"number of times you specify. For example, in the history listed earlier, "
"`HEAD~3` would be"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:167
msgid ""
"\t$ git show HEAD~3\n"
"\tcommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\n"
"\tAuthor: Tom Preston-Werner <tom@mojombo.com>\n"
"\tDate:   Fri Nov 7 13:47:59 2008 -0500"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:172
msgctxt "en/06-git-tools/01-chapter6.markdown:172"
msgid "\t    ignore *.gem"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:174
msgid ""
"This can also be written `HEAD^^^`, which again is the first parent of the "
"first parent of the first parent:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:176
msgid ""
"\t$ git show HEAD^^^\n"
"\tcommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\n"
"\tAuthor: Tom Preston-Werner <tom@mojombo.com>\n"
"\tDate:   Fri Nov 7 13:47:59 2008 -0500"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:181
msgctxt "en/06-git-tools/01-chapter6.markdown:181"
msgid "\t    ignore *.gem"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:183
msgid ""
"You can also combine these syntaxes — you can get the second parent of the "
"previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and "
"so on."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:185
msgid "### Commit Ranges ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:187
msgid ""
"Now that you can specify individual commits, let’s see how to specify ranges "
"of commits. This is particularly useful for managing your branches — if you "
"have a lot of branches, you can use range specifications to answer questions "
"such as, \"What work is on this branch that I haven’t yet merged into my "
"main branch?\""
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:189
msgid "#### Double Dot ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:191
msgid ""
"The most common range specification is the double-dot syntax. This basically "
"asks Git to resolve a range of commits that are reachable from one commit "
"but aren’t reachable from another. For example, say you have a commit "
"history that looks like Figure 6-1."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:193
msgid ""
"Insert 18333fig0601.png\n"
"Figure 6-1. Example history for range selection."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:196
msgid ""
"You want to see what is in your experiment branch that hasn’t yet been "
"merged into your master branch. You can ask Git to show you a log of just "
"those commits with `master..experiment` — that means \"all commits reachable "
"by experiment that aren’t reachable by master.\" For the sake of brevity and "
"clarity in these examples, I’ll use the letters of the commit objects from "
"the diagram in place of the actual log output in the order that they would "
"display:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:198
msgid ""
"\t$ git log master..experiment\n"
"\tD\n"
"\tC"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:202
msgid ""
"If, on the other hand, you want to see the opposite — all commits in "
"`master` that aren’t in `experiment` — you can reverse the branch names. "
"`experiment..master` shows you everything in `master` not reachable from "
"`experiment`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:204
msgid ""
"\t$ git log experiment..master\n"
"\tF\n"
"\tE"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:208
msgid ""
"This is useful if you want to keep the `experiment` branch up to date and "
"preview what you’re about to merge in. Another very frequent use of this "
"syntax is to see what you’re about to push to a remote:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:210
msgid "\t$ git log origin/master..HEAD"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:212
msgid ""
"This command shows you any commits in your current branch that aren’t in the "
"`master` branch on your `origin` remote. If you run a `git push` and your "
"current branch is tracking `origin/master`, the commits listed by `git log "
"origin/master..HEAD` are the commits that will be transferred to the "
"server.\n"
"You can also leave off one side of the syntax to have Git assume HEAD. For "
"example, you can get the same results as in the previous example by typing "
"`git log origin/master..` — Git substitutes HEAD if one side is missing."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:215
msgid "#### Multiple Points ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:217
msgid ""
"The double-dot syntax is useful as a shorthand; but perhaps you want to "
"specify more than two branches to indicate your revision, such as seeing "
"what commits are in any of several branches that aren’t in the branch you’re "
"currently on. Git allows you to do this by using either the `^` character or "
"`--not` before any reference from which you don’t want to see reachable "
"commits. Thus these three commands are equivalent:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:219
msgid ""
"\t$ git log refA..refB\n"
"\t$ git log ^refA refB\n"
"\t$ git log refB --not refA"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:223
msgid ""
"This is nice because with this syntax you can specify more than two "
"references in your query, which you cannot do with the double-dot syntax. "
"For instance, if you want to see all commits that are reachable from `refA` "
"or `refB` but not from `refC`, you can type one of these:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:225
msgid ""
"\t$ git log refA refB ^refC\n"
"\t$ git log refA refB --not refC"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:228
msgid ""
"This makes for a very powerful revision query system that should help you "
"figure out what is in your branches."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:230
msgid "#### Triple Dot ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:232
msgid ""
"The last major range-selection syntax is the triple-dot syntax, which "
"specifies all the commits that are reachable by either of two references but "
"not by both of them. Look back at the example commit history in Figure 6-1.\n"
"If you want to see what is in `master` or `experiment` but not any common "
"references, you can run"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:235
msgid ""
"\t$ git log master...experiment\n"
"\tF\n"
"\tE\n"
"\tD\n"
"\tC"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:241
msgid ""
"Again, this gives you normal `log` output but shows you only the commit "
"information for those four commits, appearing in the traditional commit date "
"ordering."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:243
msgid ""
"A common switch to use with the `log` command in this case is `--left-"
"right`, which shows you which side of the range each commit is in. This "
"helps make the data more useful:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:245
msgid ""
"\t$ git log --left-right master...experiment\n"
"\t< F\n"
"\t< E\n"
"\t> D\n"
"\t> C"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:251
msgid ""
"With these tools, you can much more easily let Git know what commit or "
"commits you want to inspect."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:253
msgid "## Interactive Staging ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:255
msgid ""
"Git comes with a couple of scripts that make some command-line tasks easier. "
"Here, you’ll look at a few interactive commands that can help you easily "
"craft your commits to include only certain combinations and parts of files. "
"These tools are very helpful if you modify a bunch of files and then decide "
"that you want those changes to be in several focused commits rather than one "
"big messy commit. This way, you can make sure your commits are logically "
"separate changesets and can be easily reviewed by the developers working "
"with you.\n"
"If you run `git add` with the `-i` or `--interactive` option, Git goes into "
"an interactive shell mode, displaying something like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:258
msgid ""
"\t$ git add -i\n"
"\t           staged     unstaged path\n"
"\t  1:    unchanged        +0/-1 TODO\n"
"\t  2:    unchanged        +1/-1 index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:264
msgid ""
"\t*** Commands ***\n"
"\t  1: status     2: update      3: revert     4: add untracked\n"
"\t  5: patch      6: diff        7: quit       8: help\n"
"\tWhat now>"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:269
msgid ""
"You can see that this command shows you a much different view of your "
"staging area — basically the same information you get with `git status` but "
"a bit more succinct and informative. It lists the changes you’ve staged on "
"the left and unstaged changes on the right."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:271
msgid ""
"After this comes a Commands section. Here you can do a number of things, "
"including staging files, unstaging files, staging parts of files, adding "
"untracked files, and seeing diffs of what has been staged."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:273
msgid "### Staging and Unstaging Files ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:275
msgid ""
"If you type `2` or `u` at the `What now>` prompt, the script prompts you for "
"which files you want to stage:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:277
msgid ""
"\tWhat now> 2\n"
"\t           staged     unstaged path\n"
"\t  1:    unchanged        +0/-1 TODO\n"
"\t  2:    unchanged        +1/-1 index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"\tUpdate>>"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:284
msgid "To stage the TODO and index.html files, you can type the numbers:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:286
msgid ""
"\tUpdate>> 1,2\n"
"\t           staged     unstaged path\n"
"\t* 1:    unchanged        +0/-1 TODO\n"
"\t* 2:    unchanged        +1/-1 index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"\tUpdate>>"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:293
msgid ""
"The `*` next to each file means the file is selected to be staged. If you "
"press Enter after typing nothing at the `Update>>` prompt, Git takes "
"anything selected and stages it for you:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:295
msgid ""
"\tUpdate>>\n"
"\tupdated 2 paths"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:298
msgid ""
"\t*** Commands ***\n"
"\t  1: status     2: update      3: revert     4: add untracked\n"
"\t  5: patch      6: diff        7: quit       8: help\n"
"\tWhat now> 1\n"
"\t           staged     unstaged path\n"
"\t  1:        +0/-1      nothing TODO\n"
"\t  2:        +1/-1      nothing index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:307
msgid ""
"Now you can see that the TODO and index.html files are staged and the "
"simplegit.rb file is still unstaged. If you want to unstage the TODO file at "
"this point, you use the `3` or `r` (for revert) option:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:309
msgid ""
"\t*** Commands ***\n"
"\t  1: status     2: update      3: revert     4: add untracked\n"
"\t  5: patch      6: diff        7: quit       8: help\n"
"\tWhat now> 3\n"
"\t           staged     unstaged path\n"
"\t  1:        +0/-1      nothing TODO\n"
"\t  2:        +1/-1      nothing index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"\tRevert>> 1\n"
"\t           staged     unstaged path\n"
"\t* 1:        +0/-1      nothing TODO\n"
"\t  2:        +1/-1      nothing index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"\tRevert>> [enter]\n"
"\treverted one path"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:325
msgid ""
"Looking at your Git status again, you can see that you’ve unstaged the TODO "
"file:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:327
msgid ""
"\t*** Commands ***\n"
"\t  1: status     2: update      3: revert     4: add untracked\n"
"\t  5: patch      6: diff        7: quit       8: help\n"
"\tWhat now> 1\n"
"\t           staged     unstaged path\n"
"\t  1:    unchanged        +0/-1 TODO\n"
"\t  2:        +1/-1      nothing index.html\n"
"\t  3:    unchanged        +5/-1 lib/simplegit.rb"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:336
msgid ""
"To see the diff of what you’ve staged, you can use the `6` or `d` (for diff) "
"command. It shows you a list of your staged files, and you can select the "
"ones for which you would like to see the staged diff. This is much like "
"specifying `git diff --cached` on the command line:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:338
msgid ""
"\t*** Commands ***\n"
"\t  1: status     2: update      3: revert     4: add untracked\n"
"\t  5: patch      6: diff        7: quit       8: help\n"
"\tWhat now> 6\n"
"\t           staged     unstaged path\n"
"\t  1:        +1/-1      nothing index.html\n"
"\tReview diff>> 1\n"
"\tdiff --git a/index.html b/index.html\n"
"\tindex 4d07108..4335f49 100644\n"
"\t--- a/index.html\n"
"\t+++ b/index.html\n"
"\t@@ -16,7 +16,7 @@ Date Finder"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:351
msgid "\t <p id=\"out\">...</p>"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:353
msgid ""
"\t-<div id=\"footer\">contact : support@github.com</div>\n"
"\t+<div id=\"footer\">contact : email.support@github.com</div>"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:356
msgid "\t <script type=\"text/javascript\">"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:358
msgid ""
"With these basic commands, you can use the interactive add mode to deal with "
"your staging area a little more easily."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:360
msgid "### Staging Patches ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:362
msgid ""
"It’s also possible for Git to stage certain parts of files and not the rest. "
"For example, if you make two changes to your simplegit.rb file and want to "
"stage one of them and not the other, doing so is very easy in Git. From the "
"interactive prompt, type `5` or `p` (for patch). Git will ask you which "
"files you would like to partially stage; then, for each section of the "
"selected files, it will display hunks of the file diff and ask if you would "
"like to stage them, one by one:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:364
msgid ""
"\tdiff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"\tindex dd5ecc4..57399e0 100644\n"
"\t--- a/lib/simplegit.rb\n"
"\t+++ b/lib/simplegit.rb\n"
"\t@@ -22,7 +22,7 @@ class SimpleGit\n"
"\t   end"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:371
msgid ""
"\t   def log(treeish = 'master')\n"
"\t-    command(\"git log -n 25 #{treeish}\")\n"
"\t+    command(\"git log -n 30 #{treeish}\")\n"
"\t   end"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:376
msgid ""
"\t   def blame(path)\n"
"\tStage this hunk [y,n,a,d,/,j,J,g,e,?]?"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:379
msgid ""
"You have a lot of options at this point. Typing `?` shows a list of what you "
"can do:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:381
msgid ""
"\tStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\n"
"\ty - stage this hunk\n"
"\tn - do not stage this hunk\n"
"\ta - stage this and all the remaining hunks in the file\n"
"\td - do not stage this hunk nor any of the remaining hunks in the file\n"
"\tg - select a hunk to go to\n"
"\t/ - search for a hunk matching the given regex\n"
"\tj - leave this hunk undecided, see next undecided hunk\n"
"\tJ - leave this hunk undecided, see next hunk\n"
"\tk - leave this hunk undecided, see previous undecided hunk\n"
"\tK - leave this hunk undecided, see previous hunk\n"
"\ts - split the current hunk into smaller hunks\n"
"\te - manually edit the current hunk\n"
"\t? - print help"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:396
msgid ""
"Generally, you’ll type `y` or `n` if you want to stage each hunk, but "
"staging all of them in certain files or skipping a hunk decision until later "
"can be helpful too. If you stage one part of the file and leave another part "
"unstaged, your status output will look like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:398
msgid ""
"\tWhat now> 1\n"
"\t           staged     unstaged path\n"
"\t  1:    unchanged        +0/-1 TODO\n"
"\t  2:        +1/-1      nothing index.html\n"
"\t  3:        +1/-1        +4/-0 lib/simplegit.rb"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:404
msgid ""
"The status of the simplegit.rb file is interesting. It shows you that a "
"couple of lines are staged and a couple are unstaged. You’ve partially "
"staged this file. At this point, you can exit the interactive adding script "
"and run `git commit` to commit the partially staged files."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:406
msgid ""
"Finally, you don’t need to be in interactive add mode to do the partial-file "
"staging — you can start the same script by using `git add -p` or `git add --"
"patch` on the command line."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:408
msgid "## Stashing ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:410
msgid ""
"Often, when you’ve been working on part of your project, things are in a "
"messy state and you want to switch branches for a bit to work on something "
"else. The problem is, you don’t want to do a commit of half-done work just "
"so you can get back to this point later. The answer to this issue is the "
"`git stash` command."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:412
msgid ""
"Stashing takes the dirty state of your working directory — that is, your "
"modified tracked files and staged changes — and saves it on a stack of "
"unfinished changes that you can reapply at any time."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:414
msgid "### Stashing Your Work ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:416
msgid ""
"To demonstrate, you’ll go into your project and start working on a couple of "
"files and possibly stage one of the changes. If you run `git status`, you "
"can see your dirty state:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:418
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#      modified:   index.html\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#      modified:   lib/simplegit.rb\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:431
msgid ""
"Now you want to switch branches, but you don’t want to commit what you’ve "
"been working on yet; so you’ll stash the changes. To push a new stash onto "
"your stack, run `git stash`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:433
msgid ""
"\t$ git stash\n"
"\tSaved working directory and index state \\\n"
"\t  \"WIP on master: 049d078 added the index file\"\n"
"\tHEAD is now at 049d078 added the index file\n"
"\t(To restore them type \"git stash apply\")"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:439
msgid "Your working directory is clean:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:445
msgid ""
"At this point, you can easily switch branches and do work elsewhere; your "
"changes are stored on your stack. To see which stashes you’ve stored, you "
"can use `git stash list`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:447
msgid ""
"\t$ git stash list\n"
"\tstash@{0}: WIP on master: 049d078 added the index file\n"
"\tstash@{1}: WIP on master: c264051... Revert \"added file_size\"\n"
"\tstash@{2}: WIP on master: 21d80a5... added number to log"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:452
msgid ""
"In this case, two stashes were done previously, so you have access to three "
"different stashed works. You can reapply the one you just stashed by using "
"the command shown in the help output of the original stash command: `git "
"stash apply`. If you want to apply one of the older stashes, you can specify "
"it by naming it, like this: `git stash apply stash@{2}`. If you don’t "
"specify a stash, Git assumes the most recent stash and tries to apply it:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:454
msgid ""
"\t$ git stash apply\n"
"\t# On branch master\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#      modified:   index.html\n"
"\t#      modified:   lib/simplegit.rb\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:463
msgid ""
"You can see that Git re-modifies the files you uncommitted when you saved "
"the stash. In this case, you had a clean working directory when you tried to "
"apply the stash, and you tried to apply it on the same branch you saved it "
"from; but having a clean working directory and applying it on the same "
"branch aren’t necessary to successfully apply a stash. You can save a stash "
"on one branch, switch to another branch later, and try to reapply the "
"changes. You can also have modified and uncommitted files in your working "
"directory when you apply a stash — Git gives you merge conflicts if anything "
"no longer applies cleanly."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:465
msgid ""
"The changes to your files were reapplied, but the file you staged before "
"wasn’t restaged. To do that, you must run the `git stash apply` command with "
"a `--index` option to tell the command to try to reapply the staged changes. "
"If you had run that instead, you’d have gotten back to your original "
"position:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:467
msgid ""
"\t$ git stash apply --index\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#      modified:   index.html\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#      modified:   lib/simplegit.rb\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:480
msgid ""
"The apply option only tries to apply the stashed work — you continue to have "
"it on your stack. To remove it, you can run `git stash drop` with the name "
"of the stash to remove:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:482
msgid ""
"\t$ git stash list\n"
"\tstash@{0}: WIP on master: 049d078 added the index file\n"
"\tstash@{1}: WIP on master: c264051... Revert \"added file_size\"\n"
"\tstash@{2}: WIP on master: 21d80a5... added number to log\n"
"\t$ git stash drop stash@{0}\n"
"\tDropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:489
msgid ""
"You can also run `git stash pop` to apply the stash and then immediately "
"drop it from your stack."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:491
msgid "### Un-applying a Stash ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:493
msgid ""
"In some use case scenarios you might want to apply stashed changes, do some "
"work, but then un-apply those changes that originally came from the stash. "
"Git does not provide such a `stash unapply` command, but it is possible to "
"achieve the effect by simply retrieving the patch associated with a stash "
"and applying it in reverse:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:495
msgid "    $ git stash show -p stash@{0} | git apply -R"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:497
msgid "Again, if you don’t specify a stash, Git assumes the most recent stash:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:499
msgid "    $ git stash show -p | git apply -R"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:501
msgid ""
"You may want to create an alias and effectively add a `stash-unapply` "
"command to your git. For example:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:503
msgid ""
"    $ git config --global alias.stash-unapply '!git stash show -p | git "
"apply -R'\n"
"    $ git stash\n"
"    $ #... work work work\n"
"    $ git stash-unapply"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:508
msgid "### Creating a Branch from a Stash ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:510
msgid ""
"If you stash some work, leave it there for a while, and continue on the "
"branch from which you stashed the work, you may have a problem reapplying "
"the work. If the apply tries to modify a file that you’ve since modified, "
"you’ll get a merge conflict and will have to try to resolve it. If you want "
"an easier way to test the stashed changes again, you can run `git stash "
"branch`, which creates a new branch for you, checks out the commit you were "
"on when you stashed your work, reapplies your work there, and then drops the "
"stash if it applies successfully:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:512
msgid ""
"\t$ git stash branch testchanges\n"
"\tSwitched to a new branch \"testchanges\"\n"
"\t# On branch testchanges\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#      modified:   index.html\n"
"\t#\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#\n"
"\t#      modified:   lib/simplegit.rb\n"
"\t#\n"
"\tDropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:527
msgid ""
"This is a nice shortcut to recover stashed work easily and work on it in a "
"new branch."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:529
msgid "## Rewriting History ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:531
msgid ""
"Many times, when working with Git, you may want to revise your commit "
"history for some reason. One of the great things about Git is that it allows "
"you to make decisions at the last possible moment. You can decide what files "
"go into which commits right before you commit with the staging area, you can "
"decide that you didn’t mean to be working on something yet with the stash "
"command, and you can rewrite commits that already happened so they look like "
"they happened in a different way. This can involve changing the order of the "
"commits, changing messages or modifying files in a commit, squashing "
"together or splitting apart commits, or removing commits entirely — all "
"before you share your work with others."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:533
msgid ""
"In this section, you’ll cover how to accomplish these very useful tasks so "
"that you can make your commit history look the way you want before you share "
"it with others."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:535
msgid "### Changing the Last Commit ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:537
msgid ""
"Changing your last commit is probably the most common rewriting of history "
"that you’ll do. You’ll often want to do two basic things to your last "
"commit: change the commit message, or change the snapshot you just recorded "
"by adding, changing and removing files."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:539
msgid "If you only want to modify your last commit message, it’s very simple:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:541
msgctxt "en/06-git-tools/01-chapter6.markdown:541"
msgid "\t$ git commit --amend"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:543
msgid ""
"That drops you into your text editor, which has your last commit message in "
"it, ready for you to modify the message. When you save and close the editor, "
"the editor writes a new commit containing that message and makes it your new "
"last commit."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:545
msgid ""
"If you’ve committed and then you want to change the snapshot you committed "
"by adding or changing files, possibly because you forgot to add a newly "
"created file when you originally committed, the process works basically the "
"same way. You stage the changes you want by editing a file and running `git "
"add` on it or `git rm` to a tracked file, and the subsequent `git commit --"
"amend` takes your current staging area and makes it the snapshot for the new "
"commit."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:547
msgid ""
"You need to be careful with this technique because amending changes the "
"SHA-1 of the commit. It’s like a very small rebase — don’t amend your last "
"commit if you’ve already pushed it."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:549
msgid "### Changing Multiple Commit Messages ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:551
msgid ""
"To modify a commit that is farther back in your history, you must move to "
"more complex tools. Git doesn’t have a modify-history tool, but you can use "
"the rebase tool to rebase a series of commits onto the HEAD they were "
"originally based on instead of moving them to another one. With the "
"interactive rebase tool, you can then stop after each commit you want to "
"modify and change the message, add files, or do whatever you wish. You can "
"run rebase interactively by adding the `-i` option to `git rebase`. You must "
"indicate how far back you want to rewrite commits by telling the command "
"which commit to rebase onto."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:553
msgid ""
"For example, if you want to change the last three commit messages, or any of "
"the commit messages in that group, you supply as an argument to `git rebase -"
"i` the parent of the last commit you want to edit, which is `HEAD~2^` or "
"`HEAD~3`. It may be easier to remember the `~3` because you’re trying to "
"edit the last three commits; but keep in mind that you’re actually "
"designating four commits ago, the parent of the last commit you want to edit:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:555
msgid "\t$ git rebase -i HEAD~3"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:557
msgid ""
"Remember again that this is a rebasing command — every commit included in "
"the range `HEAD~3..HEAD` will be rewritten, whether you change the message "
"or not. Don’t include any commit you’ve already pushed to a central server — "
"doing so will confuse other developers by providing an alternate version of "
"the same change."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:559
msgid ""
"Running this command gives you a list of commits in your text editor that "
"looks something like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:561
msgctxt "en/06-git-tools/01-chapter6.markdown:561"
msgid ""
"\tpick f7f3f6d changed my name a bit\n"
"\tpick 310154e updated README formatting and added blame\n"
"\tpick a5f4a0d added cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:565
msgid ""
"\t# Rebase 710f0f8..a5f4a0d onto 710f0f8\n"
"\t#\n"
"\t# Commands:\n"
"\t#  p, pick = use commit\n"
"\t#  e, edit = use commit, but stop for amending\n"
"\t#  s, squash = use commit, but meld into previous commit\n"
"\t#\n"
"\t# If you remove a line here THAT COMMIT WILL BE LOST.\n"
"\t# However, if you remove everything, the rebase will be aborted.\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:576
msgid ""
"It’s important to note that these commits are listed in the opposite order "
"than you normally see them using the `log` command. If you run a `log`, you "
"see something like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:578
msgid ""
"\t$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\n"
"\ta5f4a0d added cat-file\n"
"\t310154e updated README formatting and added blame\n"
"\tf7f3f6d changed my name a bit"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:583
msgid ""
"Notice the reverse order. The interactive rebase gives you a script that "
"it’s going to run. It will start at the commit you specify on the command "
"line (`HEAD~3`) and replay the changes introduced in each of these commits "
"from top to bottom. It lists the oldest at the top, rather than the newest, "
"because that’s the first one it will replay."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:585
msgid ""
"You need to edit the script so that it stops at the commit you want to edit. "
"To do so, change the word pick to the word edit for each of the commits you "
"want the script to stop after. For example, to modify only the third commit "
"message, you change the file to look like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:587
msgid ""
"\tedit f7f3f6d changed my name a bit\n"
"\tpick 310154e updated README formatting and added blame\n"
"\tpick a5f4a0d added cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:591
msgid ""
"When you save and exit the editor, Git rewinds you back to the last commit "
"in that list and drops you on the command line with the following message:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:593
msgid ""
"\t$ git rebase -i HEAD~3\n"
"\tStopped at 7482e0d... updated the gemspec to hopefully work better\n"
"\tYou can amend the commit now, with"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:597
msgid "\t       git commit --amend"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:599
msgid "\tOnce you’re satisfied with your changes, run"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:601
msgid "\t       git rebase --continue"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:603
msgid "These instructions tell you exactly what to do. Type"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:605
msgctxt "en/06-git-tools/01-chapter6.markdown:605"
msgid "\t$ git commit --amend"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:607
msgid "Change the commit message, and exit the editor. Then, run"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:609
msgid "\t$ git rebase --continue"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:611
msgid ""
"This command will apply the other two commits automatically, and then you’re "
"done. If you change pick to edit on more lines, you can repeat these steps "
"for each commit you change to edit. Each time, Git will stop, let you amend "
"the commit, and continue when you’re finished."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:613
msgid "### Reordering Commits ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:615
msgid ""
"You can also use interactive rebases to reorder or remove commits entirely. "
"If you want to remove the \"added cat-file\" commit and change the order in "
"which the other two commits are introduced, you can change the rebase script "
"from this"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:617
msgctxt "en/06-git-tools/01-chapter6.markdown:617"
msgid ""
"\tpick f7f3f6d changed my name a bit\n"
"\tpick 310154e updated README formatting and added blame\n"
"\tpick a5f4a0d added cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:621
#: en/07-customizing-git/01-chapter7.markdown:885
msgid "to this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:623
msgid ""
"\tpick 310154e updated README formatting and added blame\n"
"\tpick f7f3f6d changed my name a bit"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:626
msgid ""
"When you save and exit the editor, Git rewinds your branch to the parent of "
"these commits, applies `310154e` and then `f7f3f6d`, and then stops. You "
"effectively change the order of those commits and remove the \"added cat-file"
"\" commit completely."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:628
msgid "### Squashing Commits ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:630
msgid ""
"It’s also possible to take a series of commits and squash them down into a "
"single commit with the interactive rebasing tool. The script puts helpful "
"instructions in the rebase message:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:632
msgid ""
"\t#\n"
"\t# Commands:\n"
"\t#  p, pick = use commit\n"
"\t#  e, edit = use commit, but stop for amending\n"
"\t#  s, squash = use commit, but meld into previous commit\n"
"\t#\n"
"\t# If you remove a line here THAT COMMIT WILL BE LOST.\n"
"\t# However, if you remove everything, the rebase will be aborted.\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:642
msgid ""
"If, instead of \"pick\" or \"edit\", you specify \"squash\", Git applies "
"both that change and the change directly before it and makes you merge the "
"commit messages together. So, if you want to make a single commit from these "
"three commits, you make the script look like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:644
msgid ""
"\tpick f7f3f6d changed my name a bit\n"
"\tsquash 310154e updated README formatting and added blame\n"
"\tsquash a5f4a0d added cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:648
msgid ""
"When you save and exit the editor, Git applies all three changes and then "
"puts you back into the editor to merge the three commit messages:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:650
msgid ""
"\t# This is a combination of 3 commits.\n"
"\t# The first commit's message is:\n"
"\tchanged my name a bit"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:654
msgid "\t# This is the 2nd commit message:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:656
msgid "\tupdated README formatting and added blame"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:658
msgid "\t# This is the 3rd commit message:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:660
msgid "\tadded cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:662
msgid ""
"When you save that, you have a single commit that introduces the changes of "
"all three previous commits."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:664
msgid "### Splitting a Commit ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:666
msgid ""
"Splitting a commit undoes a commit and then partially stages and commits as "
"many times as commits you want to end up with. For example, suppose you want "
"to split the middle commit of your three commits. Instead of \"updated "
"README formatting and added blame\", you want to split it into two commits: "
"\"updated README formatting\" for the first, and \"added blame\" for the "
"second. You can do that in the `rebase -i` script by changing the "
"instruction on the commit you want to split to \"edit\":"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:668
msgid ""
"\tpick f7f3f6d changed my name a bit\n"
"\tedit 310154e updated README formatting and added blame\n"
"\tpick a5f4a0d added cat-file"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:672
msgid ""
"Then, when the script drops you to the command line, you reset that commit, "
"take the changes that have been reset, and create multiple commits out of "
"them. When you save and exit the editor, Git rewinds to the parent of the "
"first commit in your list, applies the first commit (`f7f3f6d`), applies the "
"second (`310154e`), and drops you to the console. There, you can do a mixed "
"reset of that commit with `git reset HEAD^`, which effectively undoes that "
"commit and leaves the modified files unstaged. Now you can stage and commit "
"files until you have several commits, and run `git rebase --continue` when "
"you’re done:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:674
msgid ""
"\t$ git reset HEAD^\n"
"\t$ git add README\n"
"\t$ git commit -m 'updated README formatting'\n"
"\t$ git add lib/simplegit.rb\n"
"\t$ git commit -m 'added blame'\n"
"\t$ git rebase --continue"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:681
msgid ""
"Git applies the last commit (`a5f4a0d`) in the script, and your history "
"looks like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:683
msgid ""
"\t$ git log -4 --pretty=format:\"%h %s\"\n"
"\t1c002dd added cat-file\n"
"\t9b29157 added blame\n"
"\t35cfb2b updated README formatting\n"
"\tf3cc40e changed my name a bit"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:689
msgid ""
"Once again, this changes the SHAs of all the commits in your list, so make "
"sure no commit shows up in that list that you’ve already pushed to a shared "
"repository."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:691
msgid "### The Nuclear Option: filter-branch ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:693
msgid ""
"There is another history-rewriting option that you can use if you need to "
"rewrite a larger number of commits in some scriptable way — for instance, "
"changing your e-mail address globally or removing a file from every commit. "
"The command is `filter-branch`, and it can rewrite huge swaths of your "
"history, so you probably shouldn’t use it unless your project isn’t yet "
"public and other people haven’t based work off the commits you’re about to "
"rewrite. However, it can be very useful. You’ll learn a few of the common "
"uses so you can get an idea of some of the things it’s capable of."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:695
msgid "#### Removing a File from Every Commit ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:697
msgid ""
"This occurs fairly commonly. Someone accidentally commits a huge binary file "
"with a thoughtless `git add .`, and you want to remove it everywhere. "
"Perhaps you accidentally committed a file that contained a password, and you "
"want to make your project open source. `filter-branch` is the tool you "
"probably want to use to scrub your entire history. To remove a file named "
"passwords.txt from your entire history, you can use the `--tree-filter` "
"option to `filter-branch`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:699
msgid ""
"\t$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\n"
"\tRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\n"
"\tRef 'refs/heads/master' was rewritten"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:703
msgid ""
"The `--tree-filter` option runs the specified command after each checkout of "
"the project and then recommits the results. In this case, you remove a file "
"called passwords.txt from every snapshot, whether it exists or not. If you "
"want to remove all accidentally committed editor backup files, you can run "
"something like `git filter-branch --tree-filter \"rm -f *~\" HEAD`."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:705
msgid ""
"You’ll be able to watch Git rewriting trees and commits and then move the "
"branch pointer at the end. It’s generally a good idea to do this in a "
"testing branch and then hard-reset your master branch after you’ve "
"determined the outcome is what you really want. To run `filter-branch` on "
"all your branches, you can pass `--all` to the command."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:707
msgid "#### Making a Subdirectory the New Root ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:709
msgid ""
"Suppose you’ve done an import from another source control system and have "
"subdirectories that make no sense (trunk, tags, and so on). If you want to "
"make the `trunk` subdirectory be the new project root for every commit, "
"`filter-branch` can help you do that, too:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:711
msgid ""
"\t$ git filter-branch --subdirectory-filter trunk HEAD\n"
"\tRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\n"
"\tRef 'refs/heads/master' was rewritten"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:715
msgid ""
"Now your new project root is what was in the `trunk` subdirectory each time. "
"Git will also automatically remove commits that did not affect the "
"subdirectory."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:717
msgid "#### Changing E-Mail Addresses Globally ####"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:719
msgid ""
"Another common case is that you forgot to run `git config` to set your name "
"and e-mail address before you started working, or perhaps you want to open-"
"source a project at work and change all your work e-mail addresses to your "
"personal address. In any case, you can change e-mail addresses in multiple "
"commits in a batch with `filter-branch` as well. You need to be careful to "
"change only the e-mail addresses that are yours, so you use `--commit-"
"filter`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:721
msgid ""
"\t$ git filter-branch --commit-filter '\n"
"\t        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n"
"\t        then\n"
"\t                GIT_AUTHOR_NAME=\"Scott Chacon\";\n"
"\t                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n"
"\t                git commit-tree \"$@\";\n"
"\t        else\n"
"\t                git commit-tree \"$@\";\n"
"\t        fi' HEAD"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:731
msgid ""
"This goes through and rewrites every commit to have your new address. "
"Because commits contain the SHA-1 values of their parents, this command "
"changes every commit SHA in your history, not just those that have the "
"matching e-mail address."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:733
msgid "## Debugging with Git ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:735
msgid ""
"Git also provides a couple of tools to help you debug issues in your "
"projects. Because Git is designed to work with nearly any type of project, "
"these tools are pretty generic, but they can often help you hunt for a bug "
"or culprit when things go wrong."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:737
msgid "### File Annotation ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:739
msgid ""
"If you track down a bug in your code and want to know when it was introduced "
"and why, file annotation is often your best tool. It shows you what commit "
"was the last to modify each line of any file. So, if you see that a method "
"in your code is buggy, you can annotate the file with `git blame` to see "
"when each line of the method was last edited and by whom. This example uses "
"the `-L` option to limit the output to lines 12 through 22:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:741
msgid ""
"\t$ git blame -L 12,22 simplegit.rb\n"
"\t^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = "
"'master')\n"
"\t^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(\"git show "
"#{tree}\")\n"
"\t^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end\n"
"\t^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)\n"
"\t9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = "
"'master')\n"
"\t79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(\"git log #"
"{tree}\")\n"
"\t9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end\n"
"\t9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)\n"
"\t42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)\n"
"\t42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(\"git "
"blame #{path}\")\n"
"\t42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:754
msgid ""
"Notice that the first field is the partial SHA-1 of the commit that last "
"modified that line. The next two fields are values extracted from that commit"
"—the author name and the authored date of that commit — so you can easily "
"see who modified that line and when. After that come the line number and the "
"content of the file. Also note the `^4832fe2` commit lines, which designate "
"that those lines were in this file’s original commit. That commit is when "
"this file was first added to this project, and those lines have been "
"unchanged since. This is a tad confusing, because now you’ve seen at least "
"three different ways that Git uses the `^` to modify a commit SHA, but that "
"is what it means here."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:756
msgid ""
"Another cool thing about Git is that it doesn’t track file renames "
"explicitly. It records the snapshots and then tries to figure out what was "
"renamed implicitly, after the fact. One of the interesting features of this "
"is that you can ask it to figure out all sorts of code movement as well. If "
"you pass `-C` to `git blame`, Git analyzes the file you’re annotating and "
"tries to figure out where snippets of code within it originally came from if "
"they were copied from elsewhere. Recently, I was refactoring a file named "
"`GITServerHandler.m` into multiple files, one of which was `GITPackUpload."
"m`. By blaming `GITPackUpload.m` with the `-C` option, I could see where "
"sections of the code originally came from:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:758
msgid ""
"\t$ git blame -C -L 141,153 GITPackUpload.m\n"
"\tf344f58d GITServerHandler.m (Scott 2009-01-04 141)\n"
"\tf344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) "
"gatherObjectShasFromC\n"
"\tf344f58d GITServerHandler.m (Scott 2009-01-04 143) {\n"
"\t70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"
"\"GATHER COMMI\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString "
"*parentSha;\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit "
"*commit = [g\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"
"\"GATHER COMMI\n"
"\tad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)\n"
"\t56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {\n"
"\t56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 "
"[refDict setOb\n"
"\t56ef2caf GITServerHandler.m (Scott 2009-01-05 153)"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:773
msgid ""
"This is really useful. Normally, you get as the original commit the commit "
"where you copied the code over, because that is the first time you touched "
"those lines in this file. Git tells you the original commit where you wrote "
"those lines, even if it was in another file."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:775
msgid "### Binary Search ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:777
msgid ""
"Annotating a file helps if you know where the issue is to begin with. If you "
"don’t know what is breaking, and there have been dozens or hundreds of "
"commits since the last state where you know the code worked, you’ll likely "
"turn to `git bisect` for help. The `bisect` command does a binary search "
"through your commit history to help you identify as quickly as possible "
"which commit introduced an issue."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:779
msgid ""
"Let’s say you just pushed out a release of your code to a production "
"environment, you’re getting bug reports about something that wasn’t "
"happening in your development environment, and you can’t imagine why the "
"code is doing that. You go back to your code, and it turns out you can "
"reproduce the issue, but you can’t figure out what is going wrong. You can "
"bisect the code to find out. First you run `git bisect start` to get things "
"going, and then you use `git bisect bad` to tell the system that the current "
"commit you’re on is broken. Then, you must tell bisect when the last known "
"good state was, using `git bisect good [good_commit]`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:781
msgid ""
"\t$ git bisect start\n"
"\t$ git bisect bad\n"
"\t$ git bisect good v1.0\n"
"\tBisecting: 6 revisions left to test after this\n"
"\t[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:787
msgid ""
"Git figured out that about 12 commits came between the commit you marked as "
"the last good commit (v1.0) and the current bad version, and it checked out "
"the middle one for you. At this point, you can run your test to see if the "
"issue exists as of this commit. If it does, then it was introduced sometime "
"before this middle commit; if it doesn’t, then the problem was introduced "
"sometime after the middle commit. It turns out there is no issue here, and "
"you tell Git that by typing `git bisect good` and continue your journey:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:789
msgid ""
"\t$ git bisect good\n"
"\tBisecting: 3 revisions left to test after this\n"
"\t[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:793
msgid ""
"Now you’re on another commit, halfway between the one you just tested and "
"your bad commit. You run your test again and find that this commit is "
"broken, so you tell Git that with `git bisect bad`:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:795
msgid ""
"\t$ git bisect bad\n"
"\tBisecting: 1 revisions left to test after this\n"
"\t[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:799
msgid ""
"This commit is fine, and now Git has all the information it needs to "
"determine where the issue was introduced. It tells you the SHA-1 of the "
"first bad commit and show some of the commit information and which files "
"were modified in that commit so you can figure out what happened that may "
"have introduced this bug:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:801
msgid ""
"\t$ git bisect good\n"
"\tb047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit\n"
"\tcommit b047b02ea83310a70fd603dc8cd7a6cd13d15c04\n"
"\tAuthor: PJ Hyett <pjhyett@example.com>\n"
"\tDate:   Tue Jan 27 14:48:32 2009 -0800"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:807
msgid "\t    secure this thing"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:809
msgid ""
"\t:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730\n"
"\tf24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:812
msgid ""
"When you’re finished, you should run `git bisect reset` to reset your HEAD "
"to where you were before you started, or you’ll end up in a weird state:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:814
msgid "\t$ git bisect reset"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:816
msgid ""
"This is a powerful tool that can help you check hundreds of commits for an "
"introduced bug in minutes. In fact, if you have a script that will exit 0 if "
"the project is good or non-0 if the project is bad, you can fully automate "
"`git bisect`. First, you again tell it the scope of the bisect by providing "
"the known bad and good commits. You can do this by listing them with the "
"`bisect start` command if you want, listing the known bad commit first and "
"the known good commit second:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:818
msgid ""
"\t$ git bisect start HEAD v1.0\n"
"\t$ git bisect run test-error.sh"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:821
msgid ""
"Doing so automatically runs `test-error.sh` on each checked-out commit until "
"Git finds the first broken commit. You can also run something like `make` or "
"`make tests` or whatever you have that runs automated tests for you."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:823
msgid "## Submodules ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:825
msgid ""
"It often happens that while working on one project, you need to use another "
"project from within it. Perhaps it’s a library that a third party developed "
"or that you’re developing separately and using in multiple parent projects. "
"A common issue arises in these scenarios: you want to be able to treat the "
"two projects as separate yet still be able to use one from within the other."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:827
msgid ""
"Here’s an example. Suppose you’re developing a web site and creating Atom "
"feeds. Instead of writing your own Atom-generating code, you decide to use a "
"library. You’re likely to have to either include this code from a shared "
"library like a CPAN install or Ruby gem, or copy the source code into your "
"own project tree. The issue with including the library is that it’s "
"difficult to customize the library in any way and often more difficult to "
"deploy it, because you need to make sure every client has that library "
"available. The issue with vendoring the code into your own project is that "
"any custom changes you make are difficult to merge when upstream changes "
"become available."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:829
msgid ""
"Git addresses this issue using submodules. Submodules allow you to keep a "
"Git repository as a subdirectory of another Git repository. This lets you "
"clone another repository into your project and keep your commits separate."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:831
msgid "### Starting with Submodules ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:833
msgid ""
"Suppose you want to add the Rack library (a Ruby web server gateway "
"interface) to your project, possibly maintain your own changes to it, but "
"continue to merge in upstream changes. The first thing you should do is "
"clone the external repository into your subdirectory. You add external "
"projects as submodules with the `git submodule add` command:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:835
msgid ""
"\t$ git submodule add git://github.com/chneukirchen/rack.git rack\n"
"\tInitialized empty Git repository in /opt/subtest/rack/.git/\n"
"\tremote: Counting objects: 3181, done.\n"
"\tremote: Compressing objects: 100% (1534/1534), done.\n"
"\tremote: Total 3181 (delta 1951), reused 2623 (delta 1603)\n"
"\tReceiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.\n"
"\tResolving deltas: 100% (1951/1951), done."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:843
msgid ""
"Now you have the Rack project under a subdirectory named `rack` within your "
"project. You can go into that subdirectory, make changes, add your own "
"writable remote repository to push your changes into, fetch and merge from "
"the original repository, and more. If you run `git status` right after you "
"add the submodule, you see two things:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:845
msgid ""
"\t$ git status\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t#      new file:   .gitmodules\n"
"\t#      new file:   rack\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:854
msgid ""
"First you notice the `.gitmodules` file. This is a configuration file that "
"stores the mapping between the project’s URL and the local subdirectory "
"you’ve pulled it into:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:856
msgid ""
"\t$ cat .gitmodules\n"
"\t[submodule \"rack\"]\n"
"\t      path = rack\n"
"\t      url = git://github.com/chneukirchen/rack.git"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:861
msgid ""
"If you have multiple submodules, you’ll have multiple entries in this file. "
"It’s important to note that this file is version-controlled with your other "
"files, like your `.gitignore` file. It’s pushed and pulled with the rest of "
"your project. This is how other people who clone this project know where to "
"get the submodule projects from."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:863
msgid ""
"The other listing in the `git status` output is the rack entry. If you run "
"`git diff` on that, you see something interesting:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:865
msgid ""
"\t$ git diff --cached rack\n"
"\tdiff --git a/rack b/rack\n"
"\tnew file mode 160000\n"
"\tindex 0000000..08d709f\n"
"\t--- /dev/null\n"
"\t+++ b/rack\n"
"\t@@ -0,0 +1 @@\n"
"\t+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:874
msgid ""
"Although `rack` is a subdirectory in your working directory, Git sees it as "
"a submodule and doesn’t track its contents when you’re not in that "
"directory. Instead, Git records it as a particular commit from that "
"repository. When you make changes and commit in that subdirectory, the "
"superproject notices that the HEAD there has changed and records the exact "
"commit you’re currently working off of; that way, when others clone this "
"project, they can re-create the environment exactly."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:876
msgid ""
"This is an important point with submodules: you record them as the exact "
"commit they’re at. You can’t record a submodule at `master` or some other "
"symbolic reference."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:878
msgid "When you commit, you see something like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:880
msgid ""
"\t$ git commit -m 'first commit with submodule rack'\n"
"\t[master 0550271] first commit with submodule rack\n"
"\t 2 files changed, 4 insertions(+), 0 deletions(-)\n"
"\t create mode 100644 .gitmodules\n"
"\t create mode 160000 rack"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:886
msgid ""
"Notice the 160000 mode for the rack entry. That is a special mode in Git "
"that basically means you’re recording a commit as a directory entry rather "
"than a subdirectory or a file."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:888
msgid ""
"You can treat the `rack` directory as a separate project and then update "
"your superproject from time to time with a pointer to the latest commit in "
"that subproject. All the Git commands work independently in the two "
"directories:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:890
msgid ""
"\t$ git log -1\n"
"\tcommit 0550271328a0038865aad6331e620cd7238601bb\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Apr 9 09:03:56 2009 -0700"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:895
msgid ""
"\t    first commit with submodule rack\n"
"\t$ cd rack/\n"
"\t$ git log -1\n"
"\tcommit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433\n"
"\tAuthor: Christian Neukirchen <chneukirchen@gmail.com>\n"
"\tDate:   Wed Mar 25 14:49:04 2009 +0100"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:902
msgid "\t    Document version change"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:904
msgid "### Cloning a Project with Submodules ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:906
msgid ""
"Here you’ll clone a project with a submodule in it. When you receive such a "
"project, you get the directories that contain submodules, but none of the "
"files yet:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:908
msgid ""
"\t$ git clone git://github.com/schacon/myproject.git\n"
"\tInitialized empty Git repository in /opt/myproject/.git/\n"
"\tremote: Counting objects: 6, done.\n"
"\tremote: Compressing objects: 100% (4/4), done.\n"
"\tremote: Total 6 (delta 0), reused 0 (delta 0)\n"
"\tReceiving objects: 100% (6/6), done.\n"
"\t$ cd myproject\n"
"\t$ ls -l\n"
"\ttotal 8\n"
"\t-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README\n"
"\tdrwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack\n"
"\t$ ls rack/\n"
"\t$"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:922
msgid ""
"The `rack` directory is there, but empty. You must run two commands: `git "
"submodule init` to initialize your local configuration file, and `git "
"submodule update` to fetch all the data from that project and check out the "
"appropriate commit listed in your superproject:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:924
msgid ""
"\t$ git submodule init\n"
"\tSubmodule 'rack' (git://github.com/chneukirchen/rack.git) registered for "
"path 'rack'\n"
"\t$ git submodule update\n"
"\tInitialized empty Git repository in /opt/myproject/rack/.git/\n"
"\tremote: Counting objects: 3181, done.\n"
"\tremote: Compressing objects: 100% (1534/1534), done.\n"
"\tremote: Total 3181 (delta 1951), reused 2623 (delta 1603)\n"
"\tReceiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.\n"
"\tResolving deltas: 100% (1951/1951), done.\n"
"\tSubmodule path 'rack': checked out "
"'08d709f78b8c5b0fbeb7821e37fa53e69afcf433'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:935
msgid ""
"Now your `rack` subdirectory is at the exact state it was in when you "
"committed earlier. If another developer makes changes to the rack code and "
"commits, and you pull that reference down and merge it in, you get something "
"a bit odd:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:937
msgid ""
"\t$ git merge origin/master\n"
"\tUpdating 0550271..85a3eee\n"
"\tFast forward\n"
"\t rack |    2 +-\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)\n"
"\t[master*]$ git status\n"
"\t# On branch master\n"
"\t# Changes not staged for commit:\n"
"\t#   (use \"git add <file>...\" to update what will be committed)\n"
"\t#   (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
"\t#\n"
"\t#      modified:   rack\n"
"\t#"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:951
msgid ""
"You merged in what is basically a change to the pointer for your submodule; "
"but it doesn’t update the code in the submodule directory, so it looks like "
"you have a dirty state in your working directory:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:953
msgid ""
"\t$ git diff\n"
"\tdiff --git a/rack b/rack\n"
"\tindex 6c5e70b..08d709f 160000\n"
"\t--- a/rack\n"
"\t+++ b/rack\n"
"\t@@ -1 +1 @@\n"
"\t-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\n"
"\t+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:962
msgid ""
"This is the case because the pointer you have for the submodule isn’t what "
"is actually in the submodule directory. To fix this, you must run `git "
"submodule update` again:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:964
msgid ""
"\t$ git submodule update\n"
"\tremote: Counting objects: 5, done.\n"
"\tremote: Compressing objects: 100% (3/3), done.\n"
"\tremote: Total 3 (delta 1), reused 2 (delta 0)\n"
"\tUnpacking objects: 100% (3/3), done.\n"
"\tFrom git@github.com:schacon/rack\n"
"\t   08d709f..6c5e70b  master     -> origin/master\n"
"\tSubmodule path 'rack': checked out "
"'6c5e70b984a60b3cecd395edd5b48a7575bf58e0'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:973
msgid ""
"You have to do this every time you pull down a submodule change in the main "
"project. It’s strange, but it works."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:975
msgid ""
"One common problem happens when a developer makes a change locally in a "
"submodule but doesn’t push it to a public server. Then, they commit a "
"pointer to that non-public state and push up the superproject. When other "
"developers try to run `git submodule update`, the submodule system can’t "
"find the commit that is referenced, because it exists only on the first "
"developer’s system. If that happens, you see an error like this:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:977
msgid ""
"\t$ git submodule update\n"
"\tfatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\n"
"\tUnable to checkout '6c5e70b984a60b3cecd395edd5ba7575bf58e0' in submodule "
"path 'rack'"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:981
msgid "You have to see who last changed the submodule:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:983
msgid ""
"\t$ git log -1 rack\n"
"\tcommit 85a3eee996800fcfa91e2119372dd4172bf76678\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Thu Apr 9 09:19:14 2009 -0700"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:988
msgid "\t    added a submodule reference I will never make public. hahahahaha!"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:990
msgid "Then, you e-mail that guy and yell at him."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:992
msgid "### Superprojects ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:994
msgid ""
"Sometimes, developers want to get a combination of a large project’s "
"subdirectories, depending on what team they’re on. This is common if you’re "
"coming from CVS or Subversion, where you’ve defined a module or collection "
"of subdirectories, and you want to keep this type of workflow."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:996
msgid ""
"A good way to do this in Git is to make each of the subfolders a separate "
"Git repository and then create superproject Git repositories that contain "
"multiple submodules. A benefit of this approach is that you can more "
"specifically define the relationships between the projects with tags and "
"branches in the superprojects."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:998
msgid "### Issues with Submodules ###"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1000
msgid ""
"Using submodules isn’t without hiccups, however. First, you must be "
"relatively careful when working in the submodule directory. When you run "
"`git submodule update`, it checks out the specific version of the project, "
"but not within a branch. This is called having a detached HEAD — it means "
"the HEAD file points directly to a commit, not to a symbolic reference. The "
"issue is that you generally don’t want to work in a detached HEAD "
"environment, because it’s easy to lose changes. If you do an initial "
"`submodule update`, commit in that submodule directory without creating a "
"branch to work in, and then run `git submodule update` again from the "
"superproject without committing in the meantime, Git will overwrite your "
"changes without telling you.  Technically you won’t lose the work, but you "
"won’t have a branch pointing to it, so it will be somewhat difficult to "
"retrieve."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1002
msgid ""
"To avoid this issue, create a branch when you work in a submodule directory "
"with `git checkout -b work` or something equivalent. When you do the "
"submodule update a second time, it will still revert your work, but at least "
"you have a pointer to get back to."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1004
msgid ""
"Switching branches with submodules in them can also be tricky. If you create "
"a new branch, add a submodule there, and then switch back to a branch "
"without that submodule, you still have the submodule directory as an "
"untracked directory:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1006
msgid ""
"\t$ git checkout -b rack\n"
"\tSwitched to a new branch \"rack\"\n"
"\t$ git submodule add git@github.com:schacon/rack.git rack\n"
"\tInitialized empty Git repository in /opt/myproj/rack/.git/\n"
"\t...\n"
"\tReceiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.\n"
"\tResolving deltas: 100% (1952/1952), done.\n"
"\t$ git commit -am 'added rack submodule'\n"
"\t[rack cc49a69] added rack submodule\n"
"\t 2 files changed, 4 insertions(+), 0 deletions(-)\n"
"\t create mode 100644 .gitmodules\n"
"\t create mode 160000 rack\n"
"\t$ git checkout master\n"
"\tSwitched to branch \"master\"\n"
"\t$ git status\n"
"\t# On branch master\n"
"\t# Untracked files:\n"
"\t#   (use \"git add <file>...\" to include in what will be committed)\n"
"\t#\n"
"\t#      rack/"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1027
msgid ""
"You have to either move it out of the way or remove it, in which case you "
"have to clone it again when you switch back—and you may lose local changes "
"or branches that you didn’t push up."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1029
msgid ""
"The last main caveat that many people run into involves switching from "
"subdirectories to submodules. If you’ve been tracking files in your project "
"and you want to move them out into a submodule, you must be careful or Git "
"will get angry at you. Assume that you have the rack files in a subdirectory "
"of your project, and you want to switch it to a submodule. If you delete the "
"subdirectory and then run `submodule add`, Git yells at you:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1031
msgid ""
"\t$ rm -Rf rack/\n"
"\t$ git submodule add git@github.com:schacon/rack.git rack\n"
"\t'rack' already exists in the index"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1035
msgid ""
"You have to unstage the `rack` directory first. Then you can add the "
"submodule:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1037
msgid ""
"\t$ git rm -r rack\n"
"\t$ git submodule add git@github.com:schacon/rack.git rack\n"
"\tInitialized empty Git repository in /opt/testsub/rack/.git/\n"
"\tremote: Counting objects: 3184, done.\n"
"\tremote: Compressing objects: 100% (1465/1465), done.\n"
"\tremote: Total 3184 (delta 1952), reused 2770 (delta 1675)\n"
"\tReceiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.\n"
"\tResolving deltas: 100% (1952/1952), done."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1046
msgid ""
"Now suppose you did that in a branch. If you try to switch back to a branch "
"where those files are still in the actual tree rather than a submodule — you "
"get this error:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1048
msgid ""
"\t$ git checkout master\n"
"\terror: Untracked working tree file 'rack/AUTHORS' would be overwritten by "
"merge."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1051
msgid ""
"You have to move the `rack` submodule directory out of the way before you "
"can switch to a branch that doesn’t have it:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1053
msgid ""
"\t$ mv rack /tmp/\n"
"\t$ git checkout master\n"
"\tSwitched to branch \"master\"\n"
"\t$ ls\n"
"\tREADME\track"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1059
msgid ""
"Then, when you switch back, you get an empty `rack` directory. You can "
"either run `git submodule update` to reclone, or you can move your `/tmp/"
"rack` directory back into the empty directory."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1061
msgid "## Subtree Merging ##"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1063
msgid ""
"Now that you’ve seen the difficulties of the submodule system, let’s look at "
"an alternate way to solve the same problem. When Git merges, it looks at "
"what it has to merge together and then chooses an appropriate merging "
"strategy to use. If you’re merging two branches, Git uses a _recursive_ "
"strategy. If you’re merging more than two branches, Git picks the _octopus_ "
"strategy. These strategies are automatically chosen for you because the "
"recursive strategy can handle complex three-way merge situations — for "
"example, more than one common ancestor — but it can only handle merging two "
"branches. The octopus merge can handle multiple branches but is more "
"cautious to avoid difficult conflicts, so it’s chosen as the default "
"strategy if you’re trying to merge more than two branches."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1065
msgid ""
"However, there are other strategies you can choose as well. One of them is "
"the _subtree_ merge, and you can use it to deal with the subproject issue. "
"Here you’ll see how to do the same rack embedding as in the last section, "
"but using subtree merges instead."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1067
msgid ""
"The idea of the subtree merge is that you have two projects, and one of the "
"projects maps to a subdirectory of the other one and vice versa. When you "
"specify a subtree merge, Git is smart enough to figure out that one is a "
"subtree of the other and merge appropriately — it’s pretty amazing."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1069
msgid ""
"You first add the Rack application to your project. You add the Rack project "
"as a remote reference in your own project and then check it out into its own "
"branch:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1071
msgid ""
"\t$ git remote add rack_remote git@github.com:schacon/rack.git\n"
"\t$ git fetch rack_remote\n"
"\twarning: no common commits\n"
"\tremote: Counting objects: 3184, done.\n"
"\tremote: Compressing objects: 100% (1465/1465), done.\n"
"\tremote: Total 3184 (delta 1952), reused 2770 (delta 1675)\n"
"\tReceiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.\n"
"\tResolving deltas: 100% (1952/1952), done.\n"
"\tFrom git@github.com:schacon/rack\n"
"\t * [new branch]      build      -> rack_remote/build\n"
"\t * [new branch]      master     -> rack_remote/master\n"
"\t * [new branch]      rack-0.4   -> rack_remote/rack-0.4\n"
"\t * [new branch]      rack-0.9   -> rack_remote/rack-0.9\n"
"\t$ git checkout -b rack_branch rack_remote/master\n"
"\tBranch rack_branch set up to track remote branch refs/remotes/rack_remote/"
"master.\n"
"\tSwitched to a new branch \"rack_branch\""
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1088
msgid ""
"Now you have the root of the Rack project in your `rack_branch` branch and "
"your own project in the `master` branch. If you check out one and then the "
"other, you can see that they have different project roots:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1090
msgid ""
"\t$ ls\n"
"\tAUTHORS\t       KNOWN-ISSUES   Rakefile      contrib\t       lib\n"
"\tCOPYING\t       README         bin           example\t       test\n"
"\t$ git checkout master\n"
"\tSwitched to branch \"master\"\n"
"\t$ ls\n"
"\tREADME"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1098
msgid ""
"You want to pull the Rack project into your `master` project as a "
"subdirectory. You can do that in Git with `git read-tree`. You’ll learn more "
"about `read-tree` and its friends in Chapter 9, but for now know that it "
"reads the root tree of one branch into your current staging area and working "
"directory. You just switched back to your `master` branch, and you pull the "
"`rack` branch into the `rack` subdirectory of your `master` branch of your "
"main project:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1100
msgid "\t$ git read-tree --prefix=rack/ -u rack_branch"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1102
msgid ""
"When you commit, it looks like you have all the Rack files under that "
"subdirectory — as though you copied them in from a tarball. What gets "
"interesting is that you can fairly easily merge changes from one of the "
"branches to the other. So, if the Rack project updates, you can pull in "
"upstream changes by switching to that branch and pulling:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1104
msgid ""
"\t$ git checkout rack_branch\n"
"\t$ git pull"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1107
msgid ""
"Then, you can merge those changes back into your master branch. You can use "
"`git merge -s subtree` and it will work fine; but Git will also merge the "
"histories together, which you probably don’t want. To pull in the changes "
"and prepopulate the commit message, use the `--squash` and `--no-commit` "
"options as well as the `-s subtree` strategy option:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1109
msgid ""
"\t$ git checkout master\n"
"\t$ git merge --squash -s subtree --no-commit rack_branch\n"
"\tSquash commit -- not updating HEAD\n"
"\tAutomatic merge went well; stopped before committing as requested"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1114
msgid ""
"All the changes from your Rack project are merged in and ready to be "
"committed locally. You can also do the opposite — make changes in the `rack` "
"subdirectory of your master branch and then merge them into your "
"`rack_branch` branch later to submit them to the maintainers or push them "
"upstream."
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1116
msgid ""
"To get a diff between what you have in your `rack` subdirectory and the code "
"in your `rack_branch` branch — to see if you need to merge them — you can’t "
"use the normal `diff` command. Instead, you must run `git diff-tree` with "
"the branch you want to compare to:"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1118
msgid "\t$ git diff-tree -p rack_branch"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1120
msgid ""
"Or, to compare what is in your `rack` subdirectory with what the `master` "
"branch on the server was the last time you fetched, you can run"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1122
msgid "\t$ git diff-tree -p rack_remote/master"
msgstr ""

#: en/06-git-tools/01-chapter6.markdown:1126
msgid ""
"You’ve seen a number of advanced tools that allow you to manipulate your "
"commits and staging area more precisely. When you notice issues, you should "
"be able to easily figure out what commit introduced them, when, and by whom. "
"If you want to use subprojects in your project, you’ve learned a few ways to "
"accommodate those needs. At this point, you should be able to do most of the "
"things in Git that you’ll need on the command line day to day and feel "
"comfortable doing so."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:1
msgid "# Customizing Git #"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:3
msgid ""
"So far, I’ve covered the basics of how Git works and how to use it, and I’ve "
"introduced a number of tools that Git provides to help you use it easily and "
"efficiently. In this chapter, I’ll go through some operations that you can "
"use to make Git operate in a more customized fashion by introducing several "
"important configuration settings and the hooks system. With these tools, "
"it’s easy to get Git to work exactly the way you, your company, or your "
"group needs it to."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:5
msgid "## Git Configuration ##"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:7
msgid ""
"As you briefly saw in the Chapter 1, you can specify Git configuration "
"settings with the `git config` command. One of the first things you did was "
"set up your name and e-mail address:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:12
msgid ""
"Now you’ll learn a few of the more interesting options that you can set in "
"this manner to customize your Git usage."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:14
msgid ""
"You saw some simple Git configuration details in the first chapter, but I’ll "
"go over them again quickly here. Git uses a series of configuration files to "
"determine non-default behavior that you may want. The first place Git looks "
"for these values is in an `/etc/gitconfig` file, which contains values for "
"every user on the system and all of their repositories. If you pass the "
"option `--system` to `git config`, it reads and writes from this file "
"specifically."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:16
msgid ""
"The next place Git looks is the `~/.gitconfig` file, which is specific to "
"each user. You can make Git read and write to this file by passing the `--"
"global` option."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:18
msgid ""
"Finally, Git looks for configuration values in the config file in the Git "
"directory (`.git/config`) of whatever repository you’re currently using. "
"These values are specific to that single repository. Each level overwrites "
"values in the previous level, so values in `.git/config` trump those in `/"
"etc/gitconfig`, for instance. You can also set these values by manually "
"editing the file and inserting the correct syntax, but it’s generally easier "
"to run the `git config` command."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:20
msgid "### Basic Client Configuration ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:22
msgid ""
"The configuration options recognized by Git fall into two categories: client "
"side and server side. The majority of the options are client side—"
"configuring your personal working preferences. Although tons of options are "
"available, I’ll only cover the few that either are commonly used or can "
"significantly affect your workflow. Many options are useful only in edge "
"cases that I won’t go over here. If you want to see a list of all the "
"options your version of Git recognizes, you can run"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:24
msgid "\t$ git config --help"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:26
msgid ""
"The manual page for `git config` lists all the available options in quite a "
"bit of detail."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:28
msgid "#### core.editor ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:30
msgid ""
"By default, Git uses whatever you’ve set as your default text editor or else "
"falls back to the Vi editor to create and edit your commit and tag messages. "
"To change that default to something else, you can use the `core.editor` "
"setting:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:34
msgid ""
"Now, no matter what is set as your default shell editor variable, Git will "
"fire up Emacs to edit messages."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:36
msgid "#### commit.template ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:38
msgid ""
"If you set this to the path of a file on your system, Git will use that file "
"as the default message when you commit. For instance, suppose you create a "
"template file at `$HOME/.gitmessage.txt` that looks like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:40
msgctxt "en/07-customizing-git/01-chapter7.markdown:40"
msgid "\tsubject line"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:42
msgctxt "en/07-customizing-git/01-chapter7.markdown:42"
msgid "\twhat happened"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:44
msgid "\t[ticket: X]"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:46
msgid ""
"To tell Git to use it as the default message that appears in your editor "
"when you run `git commit`, set the `commit.template` configuration value:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:48
msgid ""
"\t$ git config --global commit.template $HOME/.gitmessage.txt\n"
"\t$ git commit"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:51
msgid ""
"Then, your editor will open to something like this for your placeholder "
"commit message when you commit:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:53
msgctxt "en/07-customizing-git/01-chapter7.markdown:53"
msgid "\tsubject line"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:55
msgctxt "en/07-customizing-git/01-chapter7.markdown:55"
msgid "\twhat happened"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:57
msgid ""
"\t[ticket: X]\n"
"\t# Please enter the commit message for your changes. Lines starting\n"
"\t# with '#' will be ignored, and an empty message aborts the commit.\n"
"\t# On branch master\n"
"\t# Changes to be committed:\n"
"\t#   (use \"git reset HEAD <file>...\" to unstage)\n"
"\t#\n"
"\t# modified:   lib/test.rb\n"
"\t#\n"
"\t~\n"
"\t~\n"
"\t\".git/COMMIT_EDITMSG\" 14L, 297C"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:70
msgid ""
"If you have a commit-message policy in place, then putting a template for "
"that policy on your system and configuring Git to use it by default can help "
"increase the chance of that policy being followed regularly."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:72
msgid "#### core.pager ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:74
msgid ""
"The core.pager setting determines what pager is used when Git pages output "
"such as `log` and `diff`. You can set it to `more` or to your favorite pager "
"(by default, it’s `less`), or you can turn it off by setting it to a blank "
"string:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:76
#, fuzzy
msgid "\t$ git config --global core.pager ''"
msgstr "\t$ git config --global core.editor emacs"

#: en/07-customizing-git/01-chapter7.markdown:78
msgid ""
"If you run that, Git will page the entire output of all commands, no matter "
"how long it is."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:80
msgid "#### user.signingkey ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:82
msgid ""
"If you’re making signed annotated tags (as discussed in Chapter 2), setting "
"your GPG signing key as a configuration setting makes things easier. Set "
"your key ID like so:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:84
msgid "\t$ git config --global user.signingkey <gpg-key-id>"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:86
msgid ""
"Now, you can sign tags without having to specify your key every time with "
"the `git tag` command:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:88
msgid "\t$ git tag -s <tag-name>"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:90
msgid "#### core.excludesfile ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:92
msgid ""
"You can put patterns in your project’s `.gitignore` file to have Git not see "
"them as untracked files or try to stage them when you run `git add` on them, "
"as discussed in Chapter 2. However, if you want another file outside of your "
"project to hold those values or have extra values, you can tell Git where "
"that file is with the `core.excludesfile` setting. Simply set it to the path "
"of a file that has content similar to what a `.gitignore` file would have."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:94
msgid "#### help.autocorrect ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:96
msgid ""
"This option is available only in Git 1.6.1 and later. If you mistype a "
"command in Git 1.6, it shows you something like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:98
msgid ""
"\t$ git com\n"
"\tgit: 'com' is not a git-command. See 'git --help'."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:101
msgid ""
"\tDid you mean this?\n"
"\t     commit"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:104
msgid ""
"If you set `help.autocorrect` to 1, Git will automatically run the command "
"if it has only one match under this scenario."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:106
msgid "### Colors in Git ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:108
msgid ""
"Git can color its output to your terminal, which can help you visually parse "
"the output quickly and easily. A number of options can help you set the "
"coloring to your preference."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:110
msgid "#### color.ui ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:112
msgid ""
"Git automatically colors most of its output if you ask it to. You can get "
"very specific about what you want colored and how; but to turn on all the "
"default terminal coloring, set `color.ui` to true:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:114
msgid "\t$ git config --global color.ui true"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:116
msgid ""
"When that value is set, Git colors its output if the output goes to a "
"terminal. Other possible settings are false, which never colors the output, "
"and always, which sets colors all the time, even if you’re redirecting Git "
"commands to a file or piping them to another command. This setting was added "
"in Git version 1.5.5; if you have an older version, you’ll have to specify "
"all the color settings individually."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:118
msgid ""
"You’ll rarely want `color.ui = always`. In most scenarios, if you want color "
"codes in your redirected output, you can instead pass a `--color` flag to "
"the Git command to force it to use color codes. The `color.ui = true` "
"setting is almost always what you’ll want to use."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:120
msgid "#### `color.*` ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:122
msgid ""
"If you want to be more specific about which commands are colored and how, or "
"you have an older version, Git provides verb-specific coloring settings. "
"Each of these can be set to `true`, `false`, or `always`:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:124
msgid ""
"\tcolor.branch\n"
"\tcolor.diff\n"
"\tcolor.interactive\n"
"\tcolor.status"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:129
msgid ""
"In addition, each of these has subsettings you can use to set specific "
"colors for parts of the output, if you want to override each color. For "
"example, to set the meta information in your diff output to blue foreground, "
"black background, and bold text, you can run"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:131
msgid "\t$ git config --global color.diff.meta \"blue black bold\""
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:133
msgid ""
"You can set the color to any of the following values: normal, black, red, "
"green, yellow, blue, magenta, cyan, or white. If you want an attribute like "
"bold in the previous example, you can choose from bold, dim, ul, blink, and "
"reverse."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:135
msgid ""
"See the `git config` manpage for all the subsettings you can configure, if "
"you want to do that."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:137
msgid "### External Merge and Diff Tools ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:139
msgid ""
"Although Git has an internal implementation of diff, which is what you’ve "
"been using, you can set up an external tool instead. You can also set up a "
"graphical merge conflict-resolution tool instead of having to resolve "
"conflicts manually. I’ll demonstrate setting up the Perforce Visual Merge "
"Tool (P4Merge) to do your diffs and merge resolutions, because it’s a nice "
"graphical tool and it’s free."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:141
msgid ""
"If you want to try this out, P4Merge works on all major platforms, so you "
"should be able to do so. I’ll use path names in the examples that work on "
"Mac and Linux systems; for Windows, you’ll have to change `/usr/local/bin` "
"to an executable path in your environment."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:143
msgid "You can download P4Merge here:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:145
msgid "\thttp://www.perforce.com/perforce/downloads/component.html"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:147
msgid ""
"To begin, you’ll set up external wrapper scripts to run your commands. I’ll "
"use the Mac path for the executable; in other systems, it will be where your "
"`p4merge` binary is installed. Set up a merge wrapper script named "
"`extMerge` that calls your binary with all the arguments provided:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:149
msgid ""
"\t$ cat /usr/local/bin/extMerge\n"
"\t#!/bin/sh\n"
"\t/Applications/p4merge.app/Contents/MacOS/p4merge $*"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:153
msgid ""
"The diff wrapper checks to make sure seven arguments are provided and passes "
"two of them to your merge script. By default, Git passes the following "
"arguments to the diff program:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:155
msgid "\tpath old-file old-hex old-mode new-file new-hex new-mode"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:157
msgid ""
"Because you only want the `old-file` and `new-file` arguments, you use the "
"wrapper script to pass the ones you need."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:159
msgid ""
"\t$ cat /usr/local/bin/extDiff\n"
"\t#!/bin/sh\n"
"\t[ $# -eq 7 ] && /usr/local/bin/extMerge \"$2\" \"$5\""
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:163
msgid "You also need to make sure these tools are executable:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:165
msgid ""
"\t$ sudo chmod +x /usr/local/bin/extMerge\n"
"\t$ sudo chmod +x /usr/local/bin/extDiff"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:168
msgid ""
"Now you can set up your config file to use your custom merge resolution and "
"diff tools. This takes a number of custom settings: `merge.tool` to tell Git "
"what strategy to use, `mergetool.*.cmd` to specify how to run the command, "
"`mergetool.trustExitCode` to tell Git if the exit code of that program "
"indicates a successful merge resolution or not, and `diff.external` to tell "
"Git what command to run for diffs. So, you can either run four config "
"commands"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:170
msgid ""
"\t$ git config --global merge.tool extMerge\n"
"\t$ git config --global mergetool.extMerge.cmd \\\n"
"\t    'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"'\n"
"\t$ git config --global mergetool.trustExitCode false\n"
"\t$ git config --global diff.external extDiff"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:176
msgid "or you can edit your `~/.gitconfig` file to add these lines:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:178
msgid ""
"\t[merge]\n"
"\t  tool = extMerge\n"
"\t[mergetool \"extMerge\"]\n"
"\t  cmd = extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"\n"
"\t  trustExitCode = false\n"
"\t[diff]\n"
"\t  external = extDiff"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:186
msgid "After all this is set, if you run diff commands such as this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:188
msgid "\t$ git diff 32d1776b1^ 32d1776b1"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:190
msgid ""
"Instead of getting the diff output on the command line, Git fires up "
"P4Merge, which looks something like Figure 7-1."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:192
msgid ""
"Insert 18333fig0701.png\n"
"Figure 7-1. P4Merge."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:195
msgid ""
"If you try to merge two branches and subsequently have merge conflicts, you "
"can run the command `git mergetool`; it starts P4Merge to let you resolve "
"the conflicts through that GUI tool."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:197
msgid ""
"The nice thing about this wrapper setup is that you can change your diff and "
"merge tools easily. For example, to change your `extDiff` and `extMerge` "
"tools to run the KDiff3 tool instead, all you have to do is edit your "
"`extMerge` file:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:199
msgid ""
"\t$ cat /usr/local/bin/extMerge\n"
"\t#!/bin/sh\n"
"\t/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:203
msgid ""
"Now, Git will use the KDiff3 tool for diff viewing and merge conflict "
"resolution."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:205
msgid ""
"Git comes preset to use a number of other merge-resolution tools without "
"your having to set up the cmd configuration. You can set your merge tool to "
"kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, or gvimdiff. If "
"you’re not interested in using KDiff3 for diff but rather want to use it "
"just for merge resolution, and the kdiff3 command is in your path, then you "
"can run"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:207
#, fuzzy
msgid "\t$ git config --global merge.tool kdiff3"
msgstr "\t$ git config --global merge.tool vimdiff"

#: en/07-customizing-git/01-chapter7.markdown:209
msgid ""
"If you run this instead of setting up the `extMerge` and `extDiff` files, "
"Git will use KDiff3 for merge resolution and the normal Git diff tool for "
"diffs."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:211
msgid "### Formatting and Whitespace ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:213
msgid ""
"Formatting and whitespace issues are some of the more frustrating and subtle "
"problems that many developers encounter when collaborating, especially cross-"
"platform. It’s very easy for patches or other collaborated work to introduce "
"subtle whitespace changes because editors silently introduce them or Windows "
"programmers add carriage returns at the end of lines they touch in cross-"
"platform projects. Git has a few configuration options to help with these "
"issues."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:215
msgid "#### core.autocrlf ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:217
msgid ""
"If you’re programming on Windows or using another system but working with "
"people who are programming on Windows, you’ll probably run into line-ending "
"issues at some point. This is because Windows uses both a carriage-return "
"character and a linefeed character for newlines in its files, whereas Mac "
"and Linux systems use only the linefeed character. This is a subtle but "
"incredibly annoying fact of cross-platform work."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:219
msgid ""
"Git can handle this by auto-converting CRLF line endings into LF when you "
"commit, and vice versa when it checks out code onto your filesystem. You can "
"turn on this functionality with the `core.autocrlf` setting. If you’re on a "
"Windows machine, set it to `true` — this converts LF endings into CRLF when "
"you check out code:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:221
#, fuzzy
msgid "\t$ git config --global core.autocrlf true"
msgstr "\t$ git config --global core.editor emacs"

#: en/07-customizing-git/01-chapter7.markdown:223
msgid ""
"If you’re on a Linux or Mac system that uses LF line endings, then you don’t "
"want Git to automatically convert them when you check out files; however, if "
"a file with CRLF endings accidentally gets introduced, then you may want Git "
"to fix it. You can tell Git to convert CRLF to LF on commit but not the "
"other way around by setting `core.autocrlf` to input:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:225
#, fuzzy
msgid "\t$ git config --global core.autocrlf input"
msgstr "\t$ git config --global core.editor emacs"

#: en/07-customizing-git/01-chapter7.markdown:227
msgid ""
"This setup should leave you with CRLF endings in Windows checkouts but LF "
"endings on Mac and Linux systems and in the repository."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:229
msgid ""
"If you’re a Windows programmer doing a Windows-only project, then you can "
"turn off this functionality, recording the carriage returns in the "
"repository by setting the config value to `false`:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:231
#, fuzzy
msgid "\t$ git config --global core.autocrlf false"
msgstr "\t$ git config --global core.editor emacs"

#: en/07-customizing-git/01-chapter7.markdown:233
msgid "#### core.whitespace ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:235
msgid ""
"Git comes preset to detect and fix some whitespace issues. It can look for "
"four primary whitespace issues — two are enabled by default and can be "
"turned off, and two aren’t enabled by default but can be activated."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:237
msgid ""
"The two that are turned on by default are `trailing-space`, which looks for "
"spaces at the end of a line, and `space-before-tab`, which looks for spaces "
"before tabs at the beginning of a line."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:239
msgid ""
"The two that are disabled by default but can be turned on are `indent-with-"
"non-tab`, which looks for lines that begin with eight or more spaces instead "
"of tabs, and `cr-at-eol`, which tells Git that carriage returns at the end "
"of lines are OK."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:241
msgid ""
"You can tell Git which of these you want enabled by setting `core."
"whitespace` to the values you want on or off, separated by commas. You can "
"disable settings by either leaving them out of the setting string or "
"prepending a `-` in front of the value. For example, if you want all but `cr-"
"at-eol` to be set, you can do this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:243
msgid ""
"\t$ git config --global core.whitespace \\\n"
"\t    trailing-space,space-before-tab,indent-with-non-tab"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:246
msgid ""
"Git will detect these issues when you run a `git diff` command and try to "
"color them so you can possibly fix them before you commit. It will also use "
"these values to help you when you apply patches with `git apply`. When "
"you’re applying patches, you can ask Git to warn you if it’s applying "
"patches with the specified whitespace issues:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:248
msgid "\t$ git apply --whitespace=warn <patch>"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:250
msgid ""
"Or you can have Git try to automatically fix the issue before applying the "
"patch:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:252
msgid "\t$ git apply --whitespace=fix <patch>"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:254
msgid ""
"These options apply to the `git rebase` command as well. If you’ve committed "
"whitespace issues but haven’t yet pushed upstream, you can run a `rebase` "
"with the `--whitespace=fix` option to have Git automatically fix whitespace "
"issues as it’s rewriting the patches."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:256
msgid "### Server Configuration ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:258
msgid ""
"Not nearly as many configuration options are available for the server side "
"of Git, but there are a few interesting ones you may want to take note of."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:260
msgid "#### receive.fsckObjects ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:262
msgid ""
"By default, Git doesn’t check for consistency all the objects it receives "
"during a push. Although Git can check to make sure each object still matches "
"its SHA-1 checksum and points to valid objects, it doesn’t do that by "
"default on every push. This is a relatively expensive operation and may add "
"a lot of time to each push, depending on the size of the repository or the "
"push. If you want Git to check object consistency on every push, you can "
"force it to do so by setting `receive.fsckObjects` to true:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:264
msgid "\t$ git config --system receive.fsckObjects true"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:266
msgid ""
"Now, Git will check the integrity of your repository before each push is "
"accepted to make sure faulty clients aren’t introducing corrupt data."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:268
msgid "#### receive.denyNonFastForwards ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:270
msgid ""
"If you rebase commits that you’ve already pushed and then try to push again, "
"or otherwise try to push a commit to a remote branch that doesn’t contain "
"the commit that the remote branch currently points to, you’ll be denied. "
"This is generally good policy; but in the case of the rebase, you may "
"determine that you know what you’re doing and can force-update the remote "
"branch with a `-f` flag to your push command."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:272
msgid ""
"To disable the ability to force-update remote branches to non-fast-forward "
"references, set `receive.denyNonFastForwards`:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:274
msgid "\t$ git config --system receive.denyNonFastForwards true"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:276
msgid ""
"The other way you can do this is via server-side receive hooks, which I’ll "
"cover in a bit. That approach lets you do more complex things like deny non-"
"fast-forwards to a certain subset of users."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:278
msgid "#### receive.denyDeletes ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:280
msgid ""
"One of the workarounds to the `denyNonFastForwards` policy is for the user "
"to delete the branch and then push it back up with the new reference. In "
"newer versions of Git (beginning with version 1.6.1), you can set `receive."
"denyDeletes` to true:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:282
msgid "\t$ git config --system receive.denyDeletes true"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:284
msgid ""
"This denies branch and tag deletion over a push across the board — no user "
"can do it. To remove remote branches, you must remove the ref files from the "
"server manually. There are also more interesting ways to do this on a per-"
"user basis via ACLs, as you’ll learn at the end of this chapter."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:286
msgid "## Git Attributes ##"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:288
msgid ""
"Some of these settings can also be specified for a path, so that Git applies "
"those settings only for a subdirectory or subset of files. These path-"
"specific settings are called Git attributes and are set either in a `."
"gitattributes` file in one of your directories (normally the root of your "
"project) or in the `.git/info/attributes` file if you don’t want the "
"attributes file committed with your project."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:290
msgid ""
"Using attributes, you can do things like specify separate merge strategies "
"for individual files or directories in your project, tell Git how to diff "
"non-text files, or have Git filter content before you check it into or out "
"of Git. In this section, you’ll learn about some of the attributes you can "
"set on your paths in your Git project and see a few examples of using this "
"feature in practice."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:292
msgid "### Binary Files ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:294
msgid ""
"One cool trick for which you can use Git attributes is telling Git which "
"files are binary (in cases it otherwise may not be able to figure out) and "
"giving Git special instructions about how to handle those files. For "
"instance, some text files may be machine generated and not diffable, whereas "
"some binary files can be diffed — you’ll see how to tell Git which is which."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:296
msgid "#### Identifying Binary Files ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:298
msgid ""
"Some files look like text files but for all intents and purposes are to be "
"treated as binary data. For instance, Xcode projects on the Mac contain a "
"file that ends in `.pbxproj`, which is basically a JSON (plain text "
"javascript data format) dataset written out to disk by the IDE that records "
"your build settings and so on. Although it’s technically a text file, "
"because it’s all ASCII, you don’t want to treat it as such because it’s "
"really a lightweight database — you can’t merge the contents if two people "
"changed it, and diffs generally aren’t helpful. The file is meant to be "
"consumed by a machine. In essence, you want to treat it like a binary file."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:300
msgid ""
"To tell Git to treat all `pbxproj` files as binary data, add the following "
"line to your `.gitattributes` file:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:302
msgid "\t*.pbxproj -crlf -diff"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:304
msgid ""
"Now, Git won’t try to convert or fix CRLF issues; nor will it try to compute "
"or print a diff for changes in this file when you run git show or git diff "
"on your project. In the 1.6 series of Git, you can also use a macro that is "
"provided that means `-crlf -diff`:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:306
msgid "\t*.pbxproj binary"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:308
msgid "#### Diffing Binary Files ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:310
msgid ""
"In the 1.6 series of Git, you can use the Git attributes functionality to "
"effectively diff binary files. You do this by telling Git how to convert "
"your binary data to a text format that can be compared via the normal diff."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:312
msgid "##### MS Word files #####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:314
msgid ""
"Because this is a pretty cool and not widely known feature, I’ll go over a "
"few examples. First, you’ll use this technique to solve one of the most "
"annoying problems known to humanity: version-controlling Word documents. "
"Everyone knows that Word is the most horrific editor around; but, oddly, "
"everyone uses it. If you want to version-control Word documents, you can "
"stick them in a Git repository and commit every once in a while; but what "
"good does that do? If you run `git diff` normally, you only see something "
"like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:316
msgid ""
"\t$ git diff\n"
"\tdiff --git a/chapter1.doc b/chapter1.doc\n"
"\tindex 88839c4..4afcb7c 100644\n"
"\tBinary files a/chapter1.doc and b/chapter1.doc differ"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:321
msgid ""
"You can’t directly compare two versions unless you check them out and scan "
"them manually, right? It turns out you can do this fairly well using Git "
"attributes. Put the following line in your `.gitattributes` file:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:323
msgid "\t*.doc diff=word"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:325
msgid ""
"This tells Git that any file that matches this pattern (.doc) should use the "
"\"word\" filter when you try to view a diff that contains changes. What is "
"the \"word\" filter? You have to set it up. Here you’ll configure Git to use "
"the `strings` program to convert Word documents into readable text files, "
"which it will then diff properly:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:327
msgid "\t$ git config diff.word.textconv strings"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:329
msgid "This command adds a section to your `.git/config` that looks like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:331
msgid ""
"\t[diff \"word\"]\n"
"\t\ttextconv = strings"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:334
msgid ""
"Side note: There are different kinds of `.doc` files. Some use an UTF-16 "
"encoding or other \"codepages\" and `strings` won’t find anything useful in "
"there. Your mileage may vary."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:336
msgid ""
"Now Git knows that if it tries to do a diff between two snapshots, and any "
"of the files end in `.doc`, it should run those files through the \"word\" "
"filter, which is defined as the `strings` program. This effectively makes "
"nice text-based versions of your Word files before attempting to diff them."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:338
msgid ""
"Here’s an example. I put Chapter 1 of this book into Git, added some text to "
"a paragraph, and saved the document. Then, I ran `git diff` to see what "
"changed:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:340
msgid ""
"\t$ git diff\n"
"\tdiff --git a/chapter1.doc b/chapter1.doc\n"
"\tindex c1c8a0a..b93c9e4 100644\n"
"\t--- a/chapter1.doc\n"
"\t+++ b/chapter1.doc\n"
"\t@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git "
"basics\n"
"\t re going to cover how to get it and set it up for the first time if you "
"don\n"
"\t t already have it on your system.\n"
"\t In Chapter Two we will go over basic Git usage - how to use Git for the "
"80%\n"
"\t-s going on, modify stuff and contribute changes. If the book "
"spontaneously\n"
"\t+s going on, modify stuff and contribute changes. If the book "
"spontaneously\n"
"\t+Let's see if this works."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:353
msgid ""
"Git successfully and succinctly tells me that I added the string \"Let’s see "
"if this works\", which is correct. It’s not perfect — it adds a bunch of "
"random stuff at the end — but it certainly works. If you can find or write a "
"Word-to-plain-text converter that works well enough, that solution will "
"likely be incredibly effective. However, `strings` is available on most Mac "
"and Linux systems, so it may be a good first try to do this with many binary "
"formats."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:355
msgid "##### OpenDocument Text files #####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:357
msgid ""
"The same approach that we used for MS Word files (`*.doc`) can be used for "
"OpenDocument Text files (`*.odt`) created by OpenOffice.org."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:359
msgid "Add the following line to your `.gitattributes` file:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:361
msgid "\t*.odt diff=odt"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:363
msgid "Now set up the `odt` diff filter in `.git/config`:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:365
msgid ""
"\t[diff \"odt\"]\n"
"\t\tbinary = true\n"
"\t\ttextconv = /usr/local/bin/odt-to-txt"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:369
msgid ""
"OpenDocument files are actually zip’ped directories containing multiple "
"files (the content in an XML format, stylesheets, images, etc.). We’ll need "
"to write a script to extract the content and return it as plain text. Create "
"a file `/usr/local/bin/odt-to-txt` (you are free to put it into a different "
"directory) with the following content:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:371
msgid ""
"\t#! /usr/bin/env perl\n"
"\t# Simplistic OpenDocument Text (.odt) to plain text converter.\n"
"\t# Author: Philipp Kempgen"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:375
msgid ""
"\tif (! defined($ARGV[0])) {\n"
"\t\tprint STDERR \"No filename given!\\n\";\n"
"\t\tprint STDERR \"Usage: $0 filename\\n\";\n"
"\t\texit 1;\n"
"\t}"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:381
msgid ""
"\tmy $content = '';\n"
"\topen my $fh, '-|', 'unzip', '-qq', '-p', $ARGV[0], 'content.xml' or die "
"$!;\n"
"\t{\n"
"\t\tlocal $/ = undef;  # slurp mode\n"
"\t\t$content = <$fh>;\n"
"\t}\n"
"\tclose $fh;\n"
"\t$_ = $content;\n"
"\ts/<text:span\\b[^>]*>//g;           # remove spans\n"
"\ts/<text:h\\b[^>]*>/\\n\\n*****  /g;   # headers\n"
"\ts/<text:list-item\\b[^>]*>\\s*<text:p\\b[^>]*>/\\n    --  /g;  # list "
"items\n"
"\ts/<text:list\\b[^>]*>/\\n\\n/g;       # lists\n"
"\ts/<text:p\\b[^>]*>/\\n  /g;          # paragraphs\n"
"\ts/<[^>]+>//g;                      # remove all XML tags\n"
"\ts/\\n{2,}/\\n\\n/g;                   # remove multiple blank lines\n"
"\ts/\\A\\n+//;                         # remove leading blank lines\n"
"\tprint \"\\n\", $_, \"\\n\\n\";"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:399
msgid "And make it executable"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:401
msgid "\tchmod +x /usr/local/bin/odt-to-txt"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:403
msgid "Now `git diff` will be able to tell you what changed in `.odt` files."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:406
msgid "##### Image files #####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:408
msgid ""
"Another interesting problem you can solve this way involves diffing image "
"files. One way to do this is to run PNG files through a filter that extracts "
"their EXIF information — metadata that is recorded with most image formats. "
"If you download and install the `exiftool` program, you can use it to "
"convert your images into text about the metadata, so at least the diff will "
"show you a textual representation of any changes that happened:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:410
msgid ""
"\t$ echo '*.png diff=exif' >> .gitattributes\n"
"\t$ git config diff.exif.textconv exiftool"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:413
msgid ""
"If you replace an image in your project and run `git diff`, you see "
"something like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:415
msgid ""
"\tdiff --git a/image.png b/image.png\n"
"\tindex 88839c4..4afcb7c 100644\n"
"\t--- a/image.png\n"
"\t+++ b/image.png\n"
"\t@@ -1,12 +1,12 @@\n"
"\t ExifTool Version Number         : 7.74\n"
"\t-File Size                       : 70 kB\n"
"\t-File Modification Date/Time     : 2009:04:21 07:02:45-07:00\n"
"\t+File Size                       : 94 kB\n"
"\t+File Modification Date/Time     : 2009:04:21 07:02:43-07:00\n"
"\t File Type                       : PNG\n"
"\t MIME Type                       : image/png\n"
"\t-Image Width                     : 1058\n"
"\t-Image Height                    : 889\n"
"\t+Image Width                     : 1056\n"
"\t+Image Height                    : 827\n"
"\t Bit Depth                       : 8\n"
"\t Color Type                      : RGB with Alpha"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:434
msgid ""
"You can easily see that the file size and image dimensions have both changed."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:436
msgid "### Keyword Expansion ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:438
msgid ""
"SVN- or CVS-style keyword expansion is often requested by developers used to "
"those systems. The main problem with this in Git is that you can’t modify a "
"file with information about the commit after you’ve committed, because Git "
"checksums the file first. However, you can inject text into a file when it’s "
"checked out and remove it again before it’s added to a commit. Git "
"attributes offers you two ways to do this."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:440
msgid ""
"First, you can inject the SHA-1 checksum of a blob into an `$Id$` field in "
"the file automatically. If you set this attribute on a file or set of files, "
"then the next time you check out that branch, Git will replace that field "
"with the SHA-1 of the blob. It’s important to notice that it isn’t the SHA "
"of the commit, but of the blob itself:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:442
msgid ""
"\t$ echo '*.txt ident' >> .gitattributes\n"
"\t$ echo '$Id$' > test.txt"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:445
msgid "The next time you check out this file, Git injects the SHA of the blob:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:447
msgid ""
"\t$ rm test.txt\n"
"\t$ git checkout -- test.txt\n"
"\t$ cat test.txt\n"
"\t$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:452
msgid ""
"However, that result is of limited use. If you’ve used keyword substitution "
"in CVS or Subversion, you can include a datestamp — the SHA isn’t all that "
"helpful, because it’s fairly random and you can’t tell if one SHA is older "
"or newer than another."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:454
msgid ""
"It turns out that you can write your own filters for doing substitutions in "
"files on commit/checkout. These are the \"clean\" and \"smudge\" filters. In "
"the `.gitattributes` file, you can set a filter for particular paths and "
"then set up scripts that will process files just before they’re checked out "
"(\"smudge\", see Figure 7-2) and just before they’re committed (\"clean\", "
"see Figure 7-3). These filters can be set to do all sorts of fun things."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:456
msgid ""
"Insert 18333fig0702.png\n"
"Figure 7-2. The “smudge” filter is run on checkout."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:459
msgid ""
"Insert 18333fig0703.png\n"
"Figure 7-3. The “clean” filter is run when files are staged."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:462
msgid ""
"The original commit message for this functionality gives a simple example of "
"running all your C source code through the `indent` program before "
"committing. You can set it up by setting the filter attribute in your `."
"gitattributes` file to filter `*.c` files with the \"indent\" filter:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:464
msgid "\t*.c     filter=indent"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:466
msgid "Then, tell Git what the \"indent\" filter does on smudge and clean:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:468
msgid ""
"\t$ git config --global filter.indent.clean indent\n"
"\t$ git config --global filter.indent.smudge cat"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:471
msgid ""
"In this case, when you commit files that match `*.c`, Git will run them "
"through the indent program before it commits them and then run them through "
"the `cat` program before it checks them back out onto disk. The `cat` "
"program is basically a no-op: it spits out the same data that it gets in. "
"This combination effectively filters all C source code files through "
"`indent` before committing."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:473
msgid ""
"Another interesting example gets `$Date$` keyword expansion, RCS style. To "
"do this properly, you need a small script that takes a filename, figures out "
"the last commit date for this project, and inserts the date into the file. "
"Here is a small Ruby script that does that:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:475
msgid ""
"\t#! /usr/bin/env ruby\n"
"\tdata = STDIN.read\n"
"\tlast_date = `git log --pretty=format:\"%ad\" -1`\n"
"\tputs data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:480
msgid ""
"All the script does is get the latest commit date from the `git log` "
"command, stick that into any `$Date$` strings it sees in stdin, and print "
"the results — it should be simple to do in whatever language you’re most "
"comfortable in. You can name this file `expand_date` and put it in your "
"path. Now, you need to set up a filter in Git (call it `dater`) and tell it "
"to use your `expand_date` filter to smudge the files on checkout. You’ll use "
"a Perl expression to clean that up on commit:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:482
msgid ""
"\t$ git config filter.dater.smudge expand_date\n"
"\t$ git config filter.dater.clean 'perl -pe \"s/\\\\\\$Date[^\\\\\\$]*\\\\\\"
"$/\\\\\\$Date\\\\\\$/\"'"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:485
msgid ""
"This Perl snippet strips out anything it sees in a `$Date$` string, to get "
"back to where you started. Now that your filter is ready, you can test it by "
"setting up a file with your `$Date$` keyword and then setting up a Git "
"attribute for that file that engages the new filter:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:487
msgid ""
"\t$ echo '# $Date$' > date_test.txt\n"
"\t$ echo 'date*.txt filter=dater' >> .gitattributes"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:490
msgid ""
"If you commit those changes and check out the file again, you see the "
"keyword properly substituted:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:492
msgid ""
"\t$ git add date_test.txt .gitattributes\n"
"\t$ git commit -m \"Testing date expansion in Git\"\n"
"\t$ rm date_test.txt\n"
"\t$ git checkout date_test.txt\n"
"\t$ cat date_test.txt\n"
"\t# $Date: Tue Apr 21 07:26:52 2009 -0700$"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:499
msgid ""
"You can see how powerful this technique can be for customized applications. "
"You have to be careful, though, because the `.gitattributes` file is "
"committed and passed around with the project but the driver (in this case, "
"`dater`) isn’t; so, it won’t work everywhere. When you design these filters, "
"they should be able to fail gracefully and have the project still work "
"properly."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:501
msgid "### Exporting Your Repository ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:503
msgid ""
"Git attribute data also allows you to do some interesting things when "
"exporting an archive of your project."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:505
msgid "#### export-ignore ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:507
msgid ""
"You can tell Git not to export certain files or directories when generating "
"an archive. If there is a subdirectory or file that you don’t want to "
"include in your archive file but that you do want checked into your project, "
"you can determine those files via the `export-ignore` attribute."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:509
msgid ""
"For example, say you have some test files in a `test/` subdirectory, and it "
"doesn’t make sense to include them in the tarball export of your project. "
"You can add the following line to your Git attributes file:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:511
msgid "\ttest/ export-ignore"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:513
msgid ""
"Now, when you run git archive to create a tarball of your project, that "
"directory won’t be included in the archive."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:515
msgid "#### export-subst ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:517
msgid ""
"Another thing you can do for your archives is some simple keyword "
"substitution. Git lets you put the string `$Format:$` in any file with any "
"of the `--pretty=format` formatting shortcodes, many of which you saw in "
"Chapter 2. For instance, if you want to include a file named `LAST_COMMIT` "
"in your project, and the last commit date was automatically injected into it "
"when `git archive` ran, you can set up the file like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:519
msgid ""
"\t$ echo 'Last commit date: $Format:%cd$' > LAST_COMMIT\n"
"\t$ echo \"LAST_COMMIT export-subst\" >> .gitattributes\n"
"\t$ git add LAST_COMMIT .gitattributes\n"
"\t$ git commit -am 'adding LAST_COMMIT file for archives'"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:524
msgid ""
"When you run `git archive`, the contents of that file when people open the "
"archive file will look like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:526
msgid ""
"\t$ cat LAST_COMMIT\n"
"\tLast commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:529
msgid "### Merge Strategies ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:531
msgid ""
"You can also use Git attributes to tell Git to use different merge "
"strategies for specific files in your project. One very useful option is to "
"tell Git to not try to merge specific files when they have conflicts, but "
"rather to use your side of the merge over someone else’s."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:533
msgid ""
"This is helpful if a branch in your project has diverged or is specialized, "
"but you want to be able to merge changes back in from it, and you want to "
"ignore certain files. Say you have a database settings file called database."
"xml that is different in two branches, and you want to merge in your other "
"branch without messing up the database file. You can set up an attribute "
"like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:535
msgid "\tdatabase.xml merge=ours"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:537
msgid ""
"If you merge in the other branch, instead of having merge conflicts with the "
"database.xml file, you see something like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:539
msgid ""
"\t$ git merge topic\n"
"\tAuto-merging database.xml\n"
"\tMerge made by recursive."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:543
msgid ""
"In this case, database.xml stays at whatever version you originally had."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:545
msgid "## Git Hooks ##"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:547
msgid ""
"Like many other Version Control Systems, Git has a way to fire off custom "
"scripts when certain important actions occur. There are two groups of these "
"hooks: client side and server side. The client-side hooks are for client "
"operations such as committing and merging. The server-side hooks are for Git "
"server operations such as receiving pushed commits. You can use these hooks "
"for all sorts of reasons, and you’ll learn about a few of them here."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:549
#, fuzzy
msgid "### Installing a Hook ###"
msgstr "### Mac에 설치하기 ###"

#: en/07-customizing-git/01-chapter7.markdown:551
msgid ""
"The hooks are all stored in the `hooks` subdirectory of the Git directory. "
"In most projects, that’s `.git/hooks`. By default, Git populates this "
"directory with a bunch of example scripts, many of which are useful by "
"themselves; but they also document the input values of each script. All the "
"examples are written as shell scripts, with some Perl thrown in, but any "
"properly named executable scripts will work fine — you can write them in "
"Ruby or Python or what have you. For post-1.6 versions of Git, these example "
"hook files end with .sample; you’ll need to rename them. For pre-1.6 "
"versions of Git, the example files are named properly but are not executable."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:553
msgid ""
"To enable a hook script, put a file in the `hooks` subdirectory of your Git "
"directory that is named appropriately and is executable. From that point "
"forward, it should be called. I’ll cover most of the major hook filenames "
"here."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:555
msgctxt "en/07-customizing-git/01-chapter7.markdown:555"
msgid "### Client-Side Hooks ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:557
msgid ""
"There are a lot of client-side hooks. This section splits them into "
"committing-workflow hooks, e-mail-workflow scripts, and the rest of the "
"client-side scripts."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:559
msgid "#### Committing-Workflow Hooks ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:561
msgid ""
"The first four hooks have to do with the committing process. The `pre-"
"commit` hook is run first, before you even type in a commit message. It’s "
"used to inspect the snapshot that’s about to be committed, to see if you’ve "
"forgotten something, to make sure tests run, or to examine whatever you need "
"to inspect in the code. Exiting non-zero from this hook aborts the commit, "
"although you can bypass it with `git commit --no-verify`. You can do things "
"like check for code style (run lint or something equivalent), check for "
"trailing whitespace (the default hook does exactly that), or check for "
"appropriate documentation on new methods."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:563
msgid ""
"The `prepare-commit-msg` hook is run before the commit message editor is "
"fired up but after the default message is created. It lets you edit the "
"default message before the commit author sees it. This hook takes a few "
"options: the path to the file that holds the commit message so far, the type "
"of commit, and the commit SHA-1 if this is an amended commit. This hook "
"generally isn’t useful for normal commits; rather, it’s good for commits "
"where the default message is auto-generated, such as templated commit "
"messages, merge commits, squashed commits, and amended commits. You may use "
"it in conjunction with a commit template to programmatically insert "
"information."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:565
msgid ""
"The `commit-msg` hook takes one parameter, which again is the path to a "
"temporary file that contains the current commit message. If this script "
"exits non-zero, Git aborts the commit process, so you can use it to validate "
"your project state or commit message before allowing a commit to go through. "
"In the last section of this chapter, I’ll demonstrate using this hook to "
"check that your commit message is conformant to a required pattern."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:567
msgid ""
"After the entire commit process is completed, the `post-commit` hook runs. "
"It doesn’t take any parameters, but you can easily get the last commit by "
"running `git log -1 HEAD`. Generally, this script is used for notification "
"or something similar."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:569
msgid ""
"The committing-workflow client-side scripts can be used in just about any "
"workflow. They’re often used to enforce certain policies, although it’s "
"important to note that these scripts aren’t transferred during a clone. You "
"can enforce policy on the server side to reject pushes of commits that don’t "
"conform to some policy, but it’s entirely up to the developer to use these "
"scripts on the client side. So, these are scripts to help developers, and "
"they must be set up and maintained by them, although they can be overridden "
"or modified by them at any time."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:571
msgid "#### E-mail Workflow Hooks ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:573
msgid ""
"You can set up three client-side hooks for an e-mail-based workflow. They’re "
"all invoked by the `git am` command, so if you aren’t using that command in "
"your workflow, you can safely skip to the next section. If you’re taking "
"patches over e-mail prepared by `git format-patch`, then some of these may "
"be helpful to you."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:575
msgid ""
"The first hook that is run is `applypatch-msg`. It takes a single argument: "
"the name of the temporary file that contains the proposed commit message. "
"Git aborts the patch if this script exits non-zero. You can use this to make "
"sure a commit message is properly formatted or to normalize the message by "
"having the script edit it in place."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:577
msgid ""
"The next hook to run when applying patches via `git am` is `pre-applypatch`. "
"It takes no arguments and is run after the patch is applied, so you can use "
"it to inspect the snapshot before making the commit. You can run tests or "
"otherwise inspect the working tree with this script. If something is missing "
"or the tests don’t pass, exiting non-zero also aborts the `git am` script "
"without committing the patch."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:579
msgid ""
"The last hook to run during a `git am` operation is `post-applypatch`. You "
"can use it to notify a group or the author of the patch you pulled in that "
"you’ve done so. You can’t stop the patching process with this script."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:581
msgid "#### Other Client Hooks ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:583
msgid ""
"The `pre-rebase` hook runs before you rebase anything and can halt the "
"process by exiting non-zero. You can use this hook to disallow rebasing any "
"commits that have already been pushed. The example `pre-rebase` hook that "
"Git installs does this, although it assumes that next is the name of the "
"branch you publish. You’ll likely need to change that to whatever your "
"stable, published branch is."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:585
msgid ""
"After you run a successful `git checkout`, the `post-checkout` hook runs; "
"you can use it to set up your working directory properly for your project "
"environment. This may mean moving in large binary files that you don’t want "
"source controlled, auto-generating documentation, or something along those "
"lines."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:587
msgid ""
"Finally, the `post-merge` hook runs after a successful `merge` command. You "
"can use it to restore data in the working tree that Git can’t track, such as "
"permissions data. This hook can likewise validate the presence of files "
"external to Git control that you may want copied in when the working tree "
"changes."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:589
msgid "### Server-Side Hooks ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:591
msgid ""
"In addition to the client-side hooks, you can use a couple of important "
"server-side hooks as a system administrator to enforce nearly any kind of "
"policy for your project. These scripts run before and after pushes to the "
"server. The pre hooks can exit non-zero at any time to reject the push as "
"well as print an error message back to the client; you can set up a push "
"policy that’s as complex as you wish."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:593
msgid "#### pre-receive and post-receive ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:595
msgid ""
"The first script to run when handling a push from a client is `pre-receive`. "
"It takes a list of references that are being pushed from stdin; if it exits "
"non-zero, none of them are accepted. You can use this hook to do things like "
"make sure none of the updated references are non-fast-forwards; or to check "
"that the user doing the pushing has create, delete, or push access or access "
"to push updates to all the files they’re modifying with the push."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:597
msgid ""
"The `post-receive` hook runs after the entire process is completed and can "
"be used to update other services or notify users. It takes the same stdin "
"data as the `pre-receive` hook. Examples include e-mailing a list, notifying "
"a continuous integration server, or updating a ticket-tracking system — you "
"can even parse the commit messages to see if any tickets need to be opened, "
"modified, or closed. This script can’t stop the push process, but the client "
"doesn’t disconnect until it has completed; so, be careful when you try to do "
"anything that may take a long time."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:599
msgid "#### update ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:601
msgid ""
"The update script is very similar to the `pre-receive` script, except that "
"it’s run once for each branch the pusher is trying to update. If the pusher "
"is trying to push to multiple branches, `pre-receive` runs only once, "
"whereas update runs once per branch they’re pushing to. Instead of reading "
"from stdin, this script takes three arguments: the name of the reference "
"(branch), the SHA-1 that reference pointed to before the push, and the SHA-1 "
"the user is trying to push. If the update script exits non-zero, only that "
"reference is rejected; other references can still be updated."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:603
msgid "## An Example Git-Enforced Policy ##"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:605
msgid ""
"In this section, you’ll use what you’ve learned to establish a Git workflow "
"that checks for a custom commit message format, enforces fast-forward-only "
"pushes, and allows only certain users to modify certain subdirectories in a "
"project. You’ll build client scripts that help the developer know if their "
"push will be rejected and server scripts that actually enforce the policies."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:607
msgid ""
"I used Ruby to write these, both because it’s my preferred scripting "
"language and because I feel it’s the most pseudocode-looking of the "
"scripting languages; thus you should be able to roughly follow the code even "
"if you don’t use Ruby. However, any language will work fine. All the sample "
"hook scripts distributed with Git are in either Perl or Bash scripting, so "
"you can also see plenty of examples of hooks in those languages by looking "
"at the samples."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:609
msgid "### Server-Side Hook ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:611
msgid ""
"All the server-side work will go into the update file in your hooks "
"directory. The update file runs once per branch being pushed and takes the "
"reference being pushed to, the old revision where that branch was, and the "
"new revision being pushed. You also have access to the user doing the "
"pushing if the push is being run over SSH. If you’ve allowed everyone to "
"connect with a single user (like \"git\") via public-key authentication, you "
"may have to give that user a shell wrapper that determines which user is "
"connecting based on the public key, and set an environment variable "
"specifying that user. Here I assume the connecting user is in the `$USER` "
"environment variable, so your update script begins by gathering all the "
"information you need:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:613
msgctxt "en/07-customizing-git/01-chapter7.markdown:613"
msgid "\t#!/usr/bin/env ruby"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:615
msgid ""
"\t$refname = ARGV[0]\n"
"\t$oldrev  = ARGV[1]\n"
"\t$newrev  = ARGV[2]\n"
"\t$user    = ENV['USER']"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:620
msgid ""
"\tputs \"Enforcing Policies... \\n(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev"
"[0,6]})\""
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:622
msgid ""
"Yes, I’m using global variables. Don’t judge me — it’s easier to demonstrate "
"in this manner."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:624
msgid "#### Enforcing a Specific Commit-Message Format ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:626
msgid ""
"Your first challenge is to enforce that each commit message must adhere to a "
"particular format. Just to have a target, assume that each message has to "
"include a string that looks like \"ref: 1234\" because you want each commit "
"to link to a work item in your ticketing system. You must look at each "
"commit being pushed up, see if that string is in the commit message, and, if "
"the string is absent from any of the commits, exit non-zero so the push is "
"rejected."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:628
msgid ""
"You can get a list of the SHA-1 values of all the commits that are being "
"pushed by taking the `$newrev` and `$oldrev` values and passing them to a "
"Git plumbing command called `git rev-list`. This is basically the `git log` "
"command, but by default it prints out only the SHA-1 values and no other "
"information. So, to get a list of all the commit SHAs introduced between one "
"commit SHA and another, you can run something like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:630
msgid ""
"\t$ git rev-list 538c33..d14fc7\n"
"\td14fc7c847ab946ec39590d87783c69b031bdfb7\n"
"\t9f585da4401b0a3999e84113824d15245c13f0be\n"
"\t234071a1be950e2a8d078e6141f5cd20c1e61ad3\n"
"\tdfa04c9ef3d5197182f13fb5b9b1fb7717d2222a\n"
"\t17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:637
msgid ""
"You can take that output, loop through each of those commit SHAs, grab the "
"message for it, and test that message against a regular expression that "
"looks for a pattern."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:639
msgid ""
"You have to figure out how to get the commit message from each of these "
"commits to test. To get the raw commit data, you can use another plumbing "
"command called `git cat-file`. I’ll go over all these plumbing commands in "
"detail in Chapter 9; but for now, here’s what that command gives you:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:641
msgid ""
"\t$ git cat-file commit ca82a6\n"
"\ttree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\n"
"\tparent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tauthor Scott Chacon <schacon@gmail.com> 1205815931 -0700\n"
"\tcommitter Scott Chacon <schacon@gmail.com> 1240030591 -0700"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:647
#: en/09-git-internals/01-chapter9.markdown:649
msgid "\tchanged the version number"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:649
msgid ""
"A simple way to get the commit message from a commit when you have the SHA-1 "
"value is to go to the first blank line and take everything after that. You "
"can do so with the `sed` command on Unix systems:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:651
msgid ""
"\t$ git cat-file commit ca82a6 | sed '1,/^$/d'\n"
"\tchanged the version number"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:654
msgid ""
"You can use that incantation to grab the commit message from each commit "
"that is trying to be pushed and exit if you see anything that doesn’t match. "
"To exit the script and reject the push, exit non-zero. The whole method "
"looks like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:656
msgctxt "en/07-customizing-git/01-chapter7.markdown:656"
msgid "\t$regex = /\\[ref: (\\d+)\\]/"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:658
msgid ""
"\t# enforced custom commit message format\n"
"\tdef check_message_format\n"
"\t  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split(\"\\n\")\n"
"\t  missed_revs.each do |rev|\n"
"\t    message = `git cat-file commit #{rev} | sed '1,/^$/d'`\n"
"\t    if !$regex.match(message)\n"
"\t      puts \"[POLICY] Your message is not formatted correctly\"\n"
"\t      exit 1\n"
"\t    end\n"
"\t  end\n"
"\tend\n"
"\tcheck_message_format"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:671
msgid ""
"Putting that in your `update` script will reject updates that contain "
"commits that have messages that don’t adhere to your rule."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:673
msgid "#### Enforcing a User-Based ACL System ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:675
msgid ""
"Suppose you want to add a mechanism that uses an access control list (ACL) "
"that specifies which users are allowed to push changes to which parts of "
"your projects. Some people have full access, and others only have access to "
"push changes to certain subdirectories or specific files. To enforce this, "
"you’ll write those rules to a file named `acl` that lives in your bare Git "
"repository on the server. You’ll have the `update` hook look at those rules, "
"see what files are being introduced for all the commits being pushed, and "
"determine whether the user doing the push has access to update all those "
"files."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:677
msgid ""
"The first thing you’ll do is write your ACL. Here you’ll use a format very "
"much like the CVS ACL mechanism: it uses a series of lines, where the first "
"field is `avail` or `unavail`, the next field is a comma-delimited list of "
"the users to which the rule applies, and the last field is the path to which "
"the rule applies (blank meaning open access). All of these fields are "
"delimited by a pipe (`|`) character."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:679
msgid ""
"In this case, you have a couple of administrators, some documentation "
"writers with access to the `doc` directory, and one developer who only has "
"access to the `lib` and `tests` directories, and your ACL file looks like "
"this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:681
msgid ""
"\tavail|nickh,pjhyett,defunkt,tpw\n"
"\tavail|usinclair,cdickens,ebronte|doc\n"
"\tavail|schacon|lib\n"
"\tavail|schacon|tests"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:686
msgid ""
"You begin by reading this data into a structure that you can use. In this "
"case, to keep the example simple, you’ll only enforce the `avail` "
"directives. Here is a method that gives you an associative array where the "
"key is the user name and the value is an array of paths to which the user "
"has write access:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:688
msgid ""
"\tdef get_acl_access_data(acl_file)\n"
"\t  # read in ACL data\n"
"\t  acl_file = File.read(acl_file).split(\"\\n\").reject { |line| line == "
"'' }\n"
"\t  access = {}\n"
"\t  acl_file.each do |line|\n"
"\t    avail, users, path = line.split('|')\n"
"\t    next unless avail == 'avail'\n"
"\t    users.split(',').each do |user|\n"
"\t      access[user] ||= []\n"
"\t      access[user] << path\n"
"\t    end\n"
"\t  end\n"
"\t  access\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:703
msgid ""
"On the ACL file you looked at earlier, this `get_acl_access_data` method "
"returns a data structure that looks like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:705
msgid ""
"\t{\"defunkt\"=>[nil],\n"
"\t \"tpw\"=>[nil],\n"
"\t \"nickh\"=>[nil],\n"
"\t \"pjhyett\"=>[nil],\n"
"\t \"schacon\"=>[\"lib\", \"tests\"],\n"
"\t \"cdickens\"=>[\"doc\"],\n"
"\t \"usinclair\"=>[\"doc\"],\n"
"\t \"ebronte\"=>[\"doc\"]}"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:714
msgid ""
"Now that you have the permissions sorted out, you need to determine what "
"paths the commits being pushed have modified, so you can make sure the user "
"who’s pushing has access to all of them."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:716
msgid ""
"You can pretty easily see what files have been modified in a single commit "
"with the `--name-only` option to the `git log` command (mentioned briefly in "
"Chapter 2):"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:718
msgid "\t$ git log -1 --name-only --pretty=format:'' 9f585d"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:720
msgid ""
"\tREADME\n"
"\tlib/test.rb"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:723
msgid ""
"If you use the ACL structure returned from the `get_acl_access_data` method "
"and check it against the listed files in each of the commits, you can "
"determine whether the user has access to push all of their commits:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:725
msgid ""
"\t# only allows certain users to modify certain subdirectories in a project\n"
"\tdef check_directory_perms\n"
"\t  access = get_acl_access_data('acl')"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:729
msgid ""
"\t  # see if anyone is trying to push something they can't\n"
"\t  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split(\"\\n\")\n"
"\t  new_commits.each do |rev|\n"
"\t    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`."
"split(\"\\n\")\n"
"\t    files_modified.each do |path|\n"
"\t      next if path.size == 0\n"
"\t      has_file_access = false\n"
"\t      access[$user].each do |access_path|\n"
"\t        if !access_path || # user has access to everything\n"
"\t          (path.index(access_path) == 0) # access to this path\n"
"\t          has_file_access = true\n"
"\t        end\n"
"\t      end\n"
"\t      if !has_file_access\n"
"\t        puts \"[POLICY] You do not have access to push to #{path}\"\n"
"\t        exit 1\n"
"\t      end\n"
"\t    end\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:750
msgctxt "en/07-customizing-git/01-chapter7.markdown:750"
msgid "\tcheck_directory_perms"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:752
msgid ""
"Most of that should be easy to follow. You get a list of new commits being "
"pushed to your server with `git rev-list`. Then, for each of those, you find "
"which files are modified and make sure the user who’s pushing has access to "
"all the paths being modified. One Rubyism that may not be clear is `path."
"index(access_path) == 0`, which is true if path begins with `access_path` — "
"this ensures that `access_path` is not just in one of the allowed paths, but "
"an allowed path begins with each accessed path."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:754
msgid ""
"Now your users can’t push any commits with badly formed messages or with "
"modified files outside of their designated paths."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:756
msgid "#### Enforcing Fast-Forward-Only Pushes ####"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:758
msgid ""
"The only thing left is to enforce fast-forward-only pushes. In Git versions "
"1.6 or newer, you can set the `receive.denyDeletes` and `receive."
"denyNonFastForwards` settings. But enforcing this with a hook will work in "
"older versions of Git, and you can modify it to do so only for certain users "
"or whatever else you come up with later."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:760
msgid ""
"The logic for checking this is to see if any commits are reachable from the "
"older revision that aren’t reachable from the newer one. If there are none, "
"then it was a fast-forward push; otherwise, you deny it:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:762
msgid ""
"\t# enforces fast-forward only pushes\n"
"\tdef check_fast_forward\n"
"\t  missed_refs = `git rev-list #{$newrev}..#{$oldrev}`\n"
"\t  missed_ref_count = missed_refs.split(\"\\n\").size\n"
"\t  if missed_ref_count > 0\n"
"\t    puts \"[POLICY] Cannot push a non fast-forward reference\"\n"
"\t    exit 1\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:772
msgid "\tcheck_fast_forward"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:774
msgid ""
"Everything is set up. If you run `chmod u+x .git/hooks/update`, which is the "
"file into which you should have put all this code, and then try to push a "
"non-fast-forward reference, you’ll get something like this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:776
msgid ""
"\t$ git push -f origin master\n"
"\tCounting objects: 5, done.\n"
"\tCompressing objects: 100% (3/3), done.\n"
"\tWriting objects: 100% (3/3), 323 bytes, done.\n"
"\tTotal 3 (delta 1), reused 0 (delta 0)\n"
"\tUnpacking objects: 100% (3/3), done.\n"
"\tEnforcing Policies...\n"
"\t(refs/heads/master) (8338c5) (c5b616)\n"
"\t[POLICY] Cannot push a non fast-forward reference\n"
"\terror: hooks/update exited with error code 1\n"
"\terror: hook declined to update refs/heads/master\n"
"\tTo git@gitserver:project.git\n"
"\t ! [remote rejected] master -> master (hook declined)\n"
"\terror: failed to push some refs to 'git@gitserver:project.git'"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:791
msgid ""
"There are a couple of interesting things here. First, you see this where the "
"hook starts running."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:793
msgid ""
"\tEnforcing Policies...\n"
"\t(refs/heads/master) (8338c5) (c5b616)"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:796
msgid ""
"Notice that you printed that out to stdout at the very beginning of your "
"update script. It’s important to note that anything your script prints to "
"stdout will be transferred to the client."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:798
msgid "The next thing you’ll notice is the error message."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:800
msgid ""
"\t[POLICY] Cannot push a non fast-forward reference\n"
"\terror: hooks/update exited with error code 1\n"
"\terror: hook declined to update refs/heads/master"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:804
msgid ""
"The first line was printed out by you, the other two were Git telling you "
"that the update script exited non-zero and that is what is declining your "
"push. Lastly, you have this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:806
msgid ""
"\tTo git@gitserver:project.git\n"
"\t ! [remote rejected] master -> master (hook declined)\n"
"\terror: failed to push some refs to 'git@gitserver:project.git'"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:810
msgid ""
"You’ll see a remote rejected message for each reference that your hook "
"declined, and it tells you that it was declined specifically because of a "
"hook failure."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:812
msgid ""
"Furthermore, if the ref marker isn’t there in any of your commits, you’ll "
"see the error message you’re printing out for that."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:814
msgid "\t[POLICY] Your message is not formatted correctly"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:816
msgid ""
"Or if someone tries to edit a file they don’t have access to and push a "
"commit containing it, they will see something similar. For instance, if a "
"documentation author tries to push a commit modifying something in the `lib` "
"directory, they see"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:818
msgid "\t[POLICY] You do not have access to push to lib/test.rb"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:820
msgid ""
"That’s all. From now on, as long as that `update` script is there and "
"executable, your repository will never be rewound and will never have a "
"commit message without your pattern in it, and your users will be sandboxed."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:822
msgctxt "en/07-customizing-git/01-chapter7.markdown:822"
msgid "### Client-Side Hooks ###"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:824
msgid ""
"The downside to this approach is the whining that will inevitably result "
"when your users’ commit pushes are rejected. Having their carefully crafted "
"work rejected at the last minute can be extremely frustrating and confusing; "
"and furthermore, they will have to edit their history to correct it, which "
"isn’t always for the faint of heart."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:826
msgid ""
"The answer to this dilemma is to provide some client-side hooks that users "
"can use to notify them when they’re doing something that the server is "
"likely to reject. That way, they can correct any problems before committing "
"and before those issues become more difficult to fix. Because hooks aren’t "
"transferred with a clone of a project, you must distribute these scripts "
"some other way and then have your users copy them to their `.git/hooks` "
"directory and make them executable. You can distribute these hooks within "
"the project or in a separate project, but there is no way to set them up "
"automatically."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:828
msgid ""
"To begin, you should check your commit message just before each commit is "
"recorded, so you know the server won’t reject your changes due to badly "
"formatted commit messages. To do this, you can add the `commit-msg` hook. If "
"you have it read the message from the file passed as the first argument and "
"compare that to the pattern, you can force Git to abort the commit if there "
"is no match:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:830
msgid ""
"\t#!/usr/bin/env ruby\n"
"\tmessage_file = ARGV[0]\n"
"\tmessage = File.read(message_file)"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:834
msgctxt "en/07-customizing-git/01-chapter7.markdown:834"
msgid "\t$regex = /\\[ref: (\\d+)\\]/"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:836
msgid ""
"\tif !$regex.match(message)\n"
"\t  puts \"[POLICY] Your message is not formatted correctly\"\n"
"\t  exit 1\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:841
msgid ""
"If that script is in place (in `.git/hooks/commit-msg`) and executable, and "
"you commit with a message that isn’t properly formatted, you see this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:843
msgid ""
"\t$ git commit -am 'test'\n"
"\t[POLICY] Your message is not formatted correctly"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:846
msgid ""
"No commit was completed in that instance. However, if your message contains "
"the proper pattern, Git allows you to commit:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:848
msgid ""
"\t$ git commit -am 'test [ref: 132]'\n"
"\t[master e05c914] test [ref: 132]\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:852
msgid ""
"Next, you want to make sure you aren’t modifying files that are outside your "
"ACL scope. If your project’s `.git` directory contains a copy of the ACL "
"file you used previously, then the following `pre-commit` script will "
"enforce those constraints for you:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:854
msgctxt "en/07-customizing-git/01-chapter7.markdown:854"
msgid "\t#!/usr/bin/env ruby"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:856
msgid "\t$user    = ENV['USER']"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:858
msgid "\t# [ insert acl_access_data method from above ]"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:860
msgid ""
"\t# only allows certain users to modify certain subdirectories in a project\n"
"\tdef check_directory_perms\n"
"\t  access = get_acl_access_data('.git/acl')"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:864
msgid ""
"\t  files_modified = `git diff-index --cached --name-only HEAD`.split(\"\\n"
"\")\n"
"\t  files_modified.each do |path|\n"
"\t    next if path.size == 0\n"
"\t    has_file_access = false\n"
"\t    access[$user].each do |access_path|\n"
"\t    if !access_path || (path.index(access_path) == 0)\n"
"\t      has_file_access = true\n"
"\t    end\n"
"\t    if !has_file_access\n"
"\t      puts \"[POLICY] You do not have access to push to #{path}\"\n"
"\t      exit 1\n"
"\t    end\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:879
msgctxt "en/07-customizing-git/01-chapter7.markdown:879"
msgid "\tcheck_directory_perms"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:881
msgid ""
"This is roughly the same script as the server-side part, but with two "
"important differences. First, the ACL file is in a different place, because "
"this script runs from your working directory, not from your Git directory. "
"You have to change the path to the ACL file from this"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:883
msgid "\taccess = get_acl_access_data('acl')"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:887
msgid "\taccess = get_acl_access_data('.git/acl')"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:889
msgid ""
"The other important difference is the way you get a listing of the files "
"that have been changed. Because the server-side method looks at the log of "
"commits, and, at this point, the commit hasn’t been recorded yet, you must "
"get your file listing from the staging area instead. Instead of"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:891
msgid "\tfiles_modified = `git log -1 --name-only --pretty=format:'' #{ref}`"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:893
msgid "you have to use"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:895
msgid "\tfiles_modified = `git diff-index --cached --name-only HEAD`"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:897
msgid ""
"But those are the only two differences — otherwise, the script works the "
"same way. One caveat is that it expects you to be running locally as the "
"same user you push as to the remote machine. If that is different, you must "
"set the `$user` variable manually."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:899
msgid ""
"The last thing you have to do is check that you’re not trying to push non-"
"fast-forwarded references, but that is a bit less common. To get a reference "
"that isn’t a fast-forward, you either have to rebase past a commit you’ve "
"already pushed up or try pushing a different local branch up to the same "
"remote branch."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:901
msgid ""
"Because the server will tell you that you can’t push a non-fast-forward "
"anyway, and the hook prevents forced pushes, the only accidental thing you "
"can try to catch is rebasing commits that have already been pushed."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:903
msgid ""
"Here is an example pre-rebase script that checks for that. It gets a list of "
"all the commits you’re about to rewrite and checks whether they exist in any "
"of your remote references. If it sees one that is reachable from one of your "
"remote references, it aborts the rebase:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:905
msgctxt "en/07-customizing-git/01-chapter7.markdown:905"
msgid "\t#!/usr/bin/env ruby"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:907
msgid ""
"\tbase_branch = ARGV[0]\n"
"\tif ARGV[1]\n"
"\t  topic_branch = ARGV[1]\n"
"\telse\n"
"\t  topic_branch = \"HEAD\"\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:914
msgid ""
"\ttarget_shas = `git rev-list #{base_branch}..#{topic_branch}`.split(\"\\n"
"\")\n"
"\tremote_refs = `git branch -r`.split(\"\\n\").map { |r| r.strip }"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:917
msgid ""
"\ttarget_shas.each do |sha|\n"
"\t  remote_refs.each do |remote_ref|\n"
"\t    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`\n"
"\t    if shas_pushed.split(\"\\n\").include?(sha)\n"
"\t      puts \"[POLICY] Commit #{sha} has already been pushed to #"
"{remote_ref}\"\n"
"\t      exit 1\n"
"\t    end\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:927
msgid ""
"This script uses a syntax that wasn’t covered in the Revision Selection "
"section of Chapter 6. You get a list of commits that have already been "
"pushed up by running this:"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:929
msgid "\tgit rev-list ^#{sha}^@ refs/remotes/#{remote_ref}"
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:931
msgid ""
"The `SHA^@` syntax resolves to all the parents of that commit. You’re "
"looking for any commit that is reachable from the last commit on the remote "
"and that isn’t reachable from any parent of any of the SHAs you’re trying to "
"push up — meaning it’s a fast-forward."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:933
msgid ""
"The main drawback to this approach is that it can be very slow and is often "
"unnecessary — if you don’t try to force the push with `-f`, the server will "
"warn you and not accept the push. However, it’s an interesting exercise and "
"can in theory help you avoid a rebase that you might later have to go back "
"and fix."
msgstr ""

#: en/07-customizing-git/01-chapter7.markdown:937
msgid ""
"You’ve covered most of the major ways that you can customize your Git client "
"and server to best fit your workflow and projects. You’ve learned about all "
"sorts of configuration settings, file-based attributes, and event hooks, and "
"you’ve built an example policy-enforcing server. You should now be able to "
"make Git fit nearly any workflow you can dream up."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:1
msgid "# Git and Other Systems #"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:3
msgid ""
"The world isn’t perfect. Usually, you can’t immediately switch every project "
"you come in contact with to Git. Sometimes you’re stuck on a project using "
"another VCS, and many times that system is Subversion. You’ll spend the "
"first part of this chapter learning about `git svn`, the bidirectional "
"Subversion gateway tool in Git."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:5
msgid ""
"At some point, you may want to convert your existing project to Git. The "
"second part of this chapter covers how to migrate your project into Git: "
"first from Subversion, then from Perforce, and finally via a custom import "
"script for a nonstandard importing case."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:7
msgid "## Git and Subversion ##"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:9
msgid ""
"Currently, the majority of open source development projects and a large "
"number of corporate projects use Subversion to manage their source code. "
"It’s the most popular open source VCS and has been around for nearly a "
"decade. It’s also very similar in many ways to CVS, which was the big boy of "
"the source-control world before that."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:11
msgid ""
"One of Git’s great features is a bidirectional bridge to Subversion called "
"`git svn`. This tool allows you to use Git as a valid client to a Subversion "
"server, so you can use all the local features of Git and then push to a "
"Subversion server as if you were using Subversion locally. This means you "
"can do local branching and merging, use the staging area, use rebasing and "
"cherry-picking, and so on, while your collaborators continue to work in "
"their dark and ancient ways. It’s a good way to sneak Git into the corporate "
"environment and help your fellow developers become more efficient while you "
"lobby to get the infrastructure changed to support Git fully. The Subversion "
"bridge is the gateway drug to the DVCS world."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:13
msgid "### git svn ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:15
msgid ""
"The base command in Git for all the Subversion bridging commands is `git "
"svn`. You preface everything with that. It takes quite a few commands, so "
"you’ll learn about the common ones while going through a few small workflows."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:17
msgid ""
"It’s important to note that when you’re using `git svn`, you’re interacting "
"with Subversion, which is a system that is far less sophisticated than Git. "
"Although you can easily do local branching and merging, it’s generally best "
"to keep your history as linear as possible by rebasing your work and "
"avoiding doing things like simultaneously interacting with a Git remote "
"repository."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:19
msgid ""
"Don’t rewrite your history and try to push again, and don’t push to a "
"parallel Git repository to collaborate with fellow Git developers at the "
"same time. Subversion can have only a single linear history, and confusing "
"it is very easy. If you’re working with a team, and some are using SVN and "
"others are using Git, make sure everyone is using the SVN server to "
"collaborate — doing so will make your life easier."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:21
msgid "### Setting Up ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:23
msgid ""
"To demonstrate this functionality, you need a typical SVN repository that "
"you have write access to. If you want to copy these examples, you’ll have to "
"make a writeable copy of my test repository. In order to do that easily, you "
"can use a tool called `svnsync` that comes with more recent versions of "
"Subversion — it should be distributed with at least 1.4. For these tests, I "
"created a new Subversion repository on Google code that was a partial copy "
"of the `protobuf` project, which is a tool that encodes structured data for "
"network transmission."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:25
msgid ""
"To follow along, you first need to create a new local Subversion repository:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:27
msgid ""
"\t$ mkdir /tmp/test-svn\n"
"\t$ svnadmin create /tmp/test-svn"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:30
msgid ""
"Then, enable all users to change revprops — the easy way is to add a pre-"
"revprop-change script that always exits 0:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:32
msgid ""
"\t$ cat /tmp/test-svn/hooks/pre-revprop-change\n"
"\t#!/bin/sh\n"
"\texit 0;\n"
"\t$ chmod +x /tmp/test-svn/hooks/pre-revprop-change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:37
msgid ""
"You can now sync this project to your local machine by calling `svnsync "
"init` with the to and from repositories."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:39
msgid ""
"\t$ svnsync init file:///tmp/test-svn http://progit-example.googlecode.com/"
"svn/"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:41
msgid ""
"This sets up the properties to run the sync. You can then clone the code by "
"running"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:43
msgid ""
"\t$ svnsync sync file:///tmp/test-svn\n"
"\tCommitted revision 1.\n"
"\tCopied properties for revision 1.\n"
"\tCommitted revision 2.\n"
"\tCopied properties for revision 2.\n"
"\tCommitted revision 3.\n"
"\t..."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:51
msgid ""
"Although this operation may take only a few minutes, if you try to copy the "
"original repository to another remote repository instead of a local one, the "
"process will take nearly an hour, even though there are fewer than 100 "
"commits. Subversion has to clone one revision at a time and then push it "
"back into another repository — it’s ridiculously inefficient, but it’s the "
"only easy way to do this."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:53
#, fuzzy
msgid "### Getting Started ###"
msgstr "# 시작하기 #"

#: en/08-git-and-other-scms/01-chapter8.markdown:55
msgid ""
"Now that you have a Subversion repository to which you have write access, "
"you can go through a typical workflow. You’ll start with the `git svn clone` "
"command, which imports an entire Subversion repository into a local Git "
"repository. Remember that if you’re importing from a real hosted Subversion "
"repository, you should replace the `file:///tmp/test-svn` here with the URL "
"of your Subversion repository:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:57
msgid ""
"\t$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags\n"
"\tInitialized empty Git repository in /Users/schacon/projects/testsvnsync/"
"svn/.git/\n"
"\tr1 = b4e387bc68740b5af56c2a5faf4003ae42bd135c (trunk)\n"
"\t      A    m4/acx_pthread.m4\n"
"\t      A    m4/stl_hash.m4\n"
"\t...\n"
"\tr75 = d1957f3b307922124eec6314e15bcda59e3d9610 (trunk)\n"
"\tFound possible branch point: file:///tmp/test-svn/trunk => \\\n"
"\t    file:///tmp/test-svn /branches/my-calc-branch, 75\n"
"\tFound branch parent: (my-calc-branch) "
"d1957f3b307922124eec6314e15bcda59e3d9610\n"
"\tFollowing parent with do_switch\n"
"\tSuccessfully followed parent\n"
"\tr76 = 8624824ecc0badd73f40ea2f01fce51894189b01 (my-calc-branch)\n"
"\tChecked out HEAD:\n"
"\t file:///tmp/test-svn/branches/my-calc-branch r76"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:73
msgid ""
"This runs the equivalent of two commands — `git svn init` followed by `git "
"svn fetch` — on the URL you provide. This can take a while. The test project "
"has only about 75 commits and the codebase isn’t that big, so it takes just "
"a few minutes. However, Git has to check out each version, one at a time, "
"and commit it individually. For a project with hundreds or thousands of "
"commits, this can literally take hours or even days to finish."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:75
msgid ""
"The `-T trunk -b branches -t tags` part tells Git that this Subversion "
"repository follows the basic branching and tagging conventions. If you name "
"your trunk, branches, or tags differently, you can change these options. "
"Because this is so common, you can replace this entire part with `-s`, which "
"means standard layout and implies all those options. The following command "
"is equivalent:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:77
msgid "\t$ git svn clone file:///tmp/test-svn -s"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:79
msgid ""
"At this point, you should have a valid Git repository that has imported your "
"branches and tags:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:81
msgid ""
"\t$ git branch -a\n"
"\t* master\n"
"\t  my-calc-branch\n"
"\t  tags/2.0.2\n"
"\t  tags/release-2.0.1\n"
"\t  tags/release-2.0.2\n"
"\t  tags/release-2.0.2rc1\n"
"\t  trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:90
msgid ""
"It’s important to note how this tool namespaces your remote references "
"differently. When you’re cloning a normal Git repository, you get all the "
"branches on that remote server available locally as something like `origin/"
"[branch]` - namespaced by the name of the remote. However, `git svn` assumes "
"that you won’t have multiple remotes and saves all its references to points "
"on the remote server with no namespacing. You can use the Git plumbing "
"command `show-ref` to look at all your full reference names:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:92
msgid ""
"\t$ git show-ref\n"
"\t1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/heads/master\n"
"\taee1ecc26318164f355a883f5d99cff0c852d3c4 refs/remotes/my-calc-branch\n"
"\t03d09b0e2aad427e34a6d50ff147128e76c0e0f5 refs/remotes/tags/2.0.2\n"
"\t50d02cc0adc9da4319eeba0900430ba219b9c376 refs/remotes/tags/release-2.0.1\n"
"\t4caaa711a50c77879a91b8b90380060f672745cb refs/remotes/tags/release-2.0.2\n"
"\t1c4cb508144c513ff1214c3488abe66dcb92916f refs/remotes/tags/"
"release-2.0.2rc1\n"
"\t1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:101
msgid "A normal Git repository looks more like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:103
msgid ""
"\t$ git show-ref\n"
"\t83e38c7a0af325a9722f2fdc56b10188806d83a1 refs/heads/master\n"
"\t3e15e38c198baac84223acfc6224bb8b99ff2281 refs/remotes/gitserver/master\n"
"\t0a30dd3b0c795b80212ae723640d4e5d48cabdff refs/remotes/origin/master\n"
"\t25812380387fdd55f916652be4881c6f11600d6f refs/remotes/origin/testing"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:109
msgid ""
"You have two remote servers: one named `gitserver` with a `master` branch; "
"and another named `origin` with two branches, `master` and `testing`."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:111
msgid ""
"Notice how in the example of remote references imported from `git svn`, tags "
"are added as remote branches, not as real Git tags. Your Subversion import "
"looks like it has a remote named tags with branches under it."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:113
msgid "### Committing Back to Subversion ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:115
msgid ""
"Now that you have a working repository, you can do some work on the project "
"and push your commits back upstream, using Git effectively as a SVN client. "
"If you edit one of the files and commit it, you have a commit that exists in "
"Git locally that doesn’t exist on the Subversion server:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:117
msgid ""
"\t$ git commit -am 'Adding git-svn instructions to the README'\n"
"\t[master 97031e5] Adding git-svn instructions to the README\n"
"\t 1 files changed, 1 insertions(+), 1 deletions(-)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:121
msgid ""
"Next, you need to push your change upstream. Notice how this changes the way "
"you work with Subversion — you can do several commits offline and then push "
"them all at once to the Subversion server. To push to a Subversion server, "
"you run the `git svn dcommit` command:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:123
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      README.txt\n"
"\tCommitted r79\n"
"\t       M      README.txt\n"
"\tr79 = 938b1a547c2cc92033b74d32030e86468294a5c8 (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:132
msgid ""
"This takes all the commits you’ve made on top of the Subversion server code, "
"does a Subversion commit for each, and then rewrites your local Git commit "
"to include a unique identifier. This is important because it means that all "
"the SHA-1 checksums for your commits change. Partly for this reason, working "
"with Git-based remote versions of your projects concurrently with a "
"Subversion server isn’t a good idea. If you look at the last commit, you can "
"see the new `git-svn-id` that was added:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:134
msgid ""
"\t$ git log -1\n"
"\tcommit 938b1a547c2cc92033b74d32030e86468294a5c8\n"
"\tAuthor: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\n"
"\tDate:   Sat May 2 22:06:44 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:139
msgid "\t    Adding git-svn instructions to the README"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:141
msgid ""
"\t    git-svn-id: file:///tmp/test-svn/trunk@79 4c93b258-373f-11de-"
"be05-5f7a86268029"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:143
msgid ""
"Notice that the SHA checksum that originally started with `97031e5` when you "
"committed now begins with `938b1a5`. If you want to push to both a Git "
"server and a Subversion server, you have to push (`dcommit`) to the "
"Subversion server first, because that action changes your commit data."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:145
msgid "### Pulling in New Changes ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:147
msgid ""
"If you’re working with other developers, then at some point one of you will "
"push, and then the other one will try to push a change that conflicts. That "
"change will be rejected until you merge in their work. In `git svn`, it "
"looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:149
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\tMerge conflict during commit: Your file or directory 'README.txt' is "
"probably \\\n"
"\tout-of-date: resource out of date; try updating at /Users/schacon/libexec/"
"git-\\\n"
"\tcore/git-svn line 482"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:155
msgid ""
"To resolve this situation, you can run `git svn rebase`, which pulls down "
"any changes on the server that you don’t have yet and rebases any work you "
"have on top of what is on the server:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:157
msgid ""
"\t$ git svn rebase\n"
"\t       M      README.txt\n"
"\tr80 = ff829ab914e8775c7c025d741beb3d523ee30bc4 (trunk)\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tApplying: first user change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:163
msgid ""
"Now, all your work is on top of what is on the Subversion server, so you can "
"successfully `dcommit`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:165
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      README.txt\n"
"\tCommitted r81\n"
"\t       M      README.txt\n"
"\tr81 = 456cbe6337abe49154db70106d1836bc1332deed (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:174
msgid ""
"It’s important to remember that unlike Git, which requires you to merge "
"upstream work you don’t yet have locally before you can push, `git svn` "
"makes you do that only if the changes conflict. If someone else pushes a "
"change to one file and then you push a change to another file, your "
"`dcommit` will work fine:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:176
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      configure.ac\n"
"\tCommitted r84\n"
"\t       M      autogen.sh\n"
"\tr83 = 8aa54a74d452f82eee10076ab2584c1fc424853b (trunk)\n"
"\t       M      configure.ac\n"
"\tr84 = cdbac939211ccb18aa744e581e46563af5d962d0 (trunk)\n"
"\tW: d2f23b80f67aaaa1f6f5aaef48fce3263ac71a92 and refs/remotes/trunk differ, "
"\\\n"
"\t  using rebase:\n"
"\t:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 \\\n"
"\t  015e4c98c482f0fa71e4d5434338014530b37fa6 M   autogen.sh\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tNothing to do."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:191
msgid ""
"This is important to remember, because the outcome is a project state that "
"didn’t exist on either of your computers when you pushed. If the changes are "
"incompatible but don’t conflict, you may get issues that are difficult to "
"diagnose. This is different than using a Git server — in Git, you can fully "
"test the state on your client system before publishing it, whereas in SVN, "
"you can’t ever be certain that the states immediately before commit and "
"after commit are identical."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:193
msgid ""
"You should also run this command to pull in changes from the Subversion "
"server, even if you’re not ready to commit yourself. You can run `git svn "
"fetch` to grab the new data, but `git svn rebase` does the fetch and then "
"updates your local commits."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:195
msgid ""
"\t$ git svn rebase\n"
"\t       M      generate_descriptor_proto.sh\n"
"\tr82 = bd16df9173e424c6f52c337ab6efa7f7643282f1 (trunk)\n"
"\tFirst, rewinding head to replay your work on top of it...\n"
"\tFast-forwarded master to refs/remotes/trunk."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:201
msgid ""
"Running `git svn rebase` every once in a while makes sure your code is "
"always up to date. You need to be sure your working directory is clean when "
"you run this, though. If you have local changes, you must either stash your "
"work or temporarily commit it before running `git svn rebase` — otherwise, "
"the command will stop if it sees that the rebase will result in a merge "
"conflict."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:203
msgid "### Git Branching Issues ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:205
msgid ""
"When you’ve become comfortable with a Git workflow, you’ll likely create "
"topic branches, do work on them, and then merge them in. If you’re pushing "
"to a Subversion server via git svn, you may want to rebase your work onto a "
"single branch each time instead of merging branches together. The reason to "
"prefer rebasing is that Subversion has a linear history and doesn’t deal "
"with merges like Git does, so git svn follows only the first parent when "
"converting the snapshots into Subversion commits."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:207
msgid ""
"Suppose your history looks like the following: you created an `experiment` "
"branch, did two commits, and then merged them back into `master`. When you "
"`dcommit`, you see output like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:209
msgid ""
"\t$ git svn dcommit\n"
"\tCommitting to file:///tmp/test-svn/trunk ...\n"
"\t       M      CHANGES.txt\n"
"\tCommitted r85\n"
"\t       M      CHANGES.txt\n"
"\tr85 = 4bfebeec434d156c36f2bcd18f4e3d97dc3269a2 (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk\n"
"\tCOPYING.txt: locally modified\n"
"\tINSTALL.txt: locally modified\n"
"\t       M      COPYING.txt\n"
"\t       M      INSTALL.txt\n"
"\tCommitted r86\n"
"\t       M      INSTALL.txt\n"
"\t       M      COPYING.txt\n"
"\tr86 = 2647f6b86ccfcaad4ec58c520e369ec81f7c283c (trunk)\n"
"\tNo changes between current HEAD and refs/remotes/trunk\n"
"\tResetting to the latest refs/remotes/trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:228
msgid ""
"Running `dcommit` on a branch with merged history works fine, except that "
"when you look at your Git project history, it hasn’t rewritten either of the "
"commits you made on the `experiment` branch — instead, all those changes "
"appear in the SVN version of the single merge commit."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:230
msgid ""
"When someone else clones that work, all they see is the merge commit with "
"all the work squashed into it; they don’t see the commit data about where it "
"came from or when it was committed."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:232
msgid "### Subversion Branching ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:234
msgid ""
"Branching in Subversion isn’t the same as branching in Git; if you can avoid "
"using it much, that’s probably best. However, you can create and commit to "
"branches in Subversion using git svn."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:236
msgid "#### Creating a New SVN Branch ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:238
msgid ""
"To create a new branch in Subversion, you run `git svn branch [branchname]`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:240
msgid ""
"\t$ git svn branch opera\n"
"\tCopying file:///tmp/test-svn/trunk at r87 to file:///tmp/test-svn/branches/"
"opera...\n"
"\tFound possible branch point: file:///tmp/test-svn/trunk => \\\n"
"\t  file:///tmp/test-svn/branches/opera, 87\n"
"\tFound branch parent: (opera) 1f6bfe471083cbca06ac8d4176f7ad4de0d62e5f\n"
"\tFollowing parent with do_switch\n"
"\tSuccessfully followed parent\n"
"\tr89 = 9b6fe0b90c5c9adf9165f700897518dbc54a7cbf (opera)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:249
msgid ""
"This does the equivalent of the `svn copy trunk branches/opera` command in "
"Subversion and operates on the Subversion server. It’s important to note "
"that it doesn’t check you out into that branch; if you commit at this point, "
"that commit will go to `trunk` on the server, not `opera`."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:251
msgid "### Switching Active Branches ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:253
msgid ""
"Git figures out what branch your dcommits go to by looking for the tip of "
"any of your Subversion branches in your history — you should have only one, "
"and it should be the last one with a `git-svn-id` in your current branch "
"history."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:255
msgid ""
"If you want to work on more than one branch simultaneously, you can set up "
"local branches to `dcommit` to specific Subversion branches by starting them "
"at the imported Subversion commit for that branch. If you want an `opera` "
"branch that you can work on separately, you can run"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:257
msgid "\t$ git branch opera remotes/opera"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:259
msgid ""
"Now, if you want to merge your `opera` branch into `trunk` (your `master` "
"branch), you can do so with a normal `git merge`. But you need to provide a "
"descriptive commit message (via `-m`), or the merge will say \"Merge branch "
"opera\" instead of something useful."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:261
msgid ""
"Remember that although you’re using `git merge` to do this operation, and "
"the merge likely will be much easier than it would be in Subversion (because "
"Git will automatically detect the appropriate merge base for you), this "
"isn’t a normal Git merge commit. You have to push this data back to a "
"Subversion server that can’t handle a commit that tracks more than one "
"parent; so, after you push it up, it will look like a single commit that "
"squashed in all the work of another branch under a single commit. After you "
"merge one branch into another, you can’t easily go back and continue working "
"on that branch, as you normally can in Git. The `dcommit` command that you "
"run erases any information that says what branch was merged in, so "
"subsequent merge-base calculations will be wrong — the dcommit makes your "
"`git merge` result look like you ran `git merge --squash`. Unfortunately, "
"there’s no good way to avoid this situation — Subversion can’t store this "
"information, so you’ll always be crippled by its limitations while you’re "
"using it as your server. To avoid issues, you should delete the local branch "
"(in this case, `opera`) after you merge it into trunk."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:263
msgid "### Subversion Commands ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:265
msgid ""
"The `git svn` toolset provides a number of commands to help ease the "
"transition to Git by providing some functionality that’s similar to what you "
"had in Subversion. Here are a few commands that give you what Subversion "
"used to."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:267
msgid "#### SVN Style History ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:269
msgid ""
"If you’re used to Subversion and want to see your history in SVN output "
"style, you can run `git svn log` to view your commit history in SVN "
"formatting:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:271
msgid ""
"\t$ git svn log\n"
"\t------------------------------------------------------------------------\n"
"\tr87 | schacon | 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:275
msgid "\tautogen change"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:277
msgid ""
"\t------------------------------------------------------------------------\n"
"\tr86 | schacon | 2009-05-02 16:00:21 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:280
msgid "\tMerge branch 'experiment'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:282
msgid ""
"\t------------------------------------------------------------------------\n"
"\tr85 | schacon | 2009-05-02 16:00:09 -0700 (Sat, 02 May 2009) | 2 lines"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:285
msgid "\tupdated the changelog"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:287
msgid ""
"You should know two important things about `git svn log`. First, it works "
"offline, unlike the real `svn log` command, which asks the Subversion server "
"for the data. Second, it only shows you commits that have been committed up "
"to the Subversion server. Local Git commits that you haven’t dcommited don’t "
"show up; neither do commits that people have made to the Subversion server "
"in the meantime. It’s more like the last known state of the commits on the "
"Subversion server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:289
msgid "#### SVN Annotation ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:291
msgid ""
"Much as the `git svn log` command simulates the `svn log` command offline, "
"you can get the equivalent of `svn annotate` by running `git svn blame [FILE]"
"`. The output looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:293
msgid ""
"\t$ git svn blame README.txt\n"
"\t 2   temporal Protocol Buffers - Google's data interchange format\n"
"\t 2   temporal Copyright 2008 Google Inc.\n"
"\t 2   temporal http://code.google.com/apis/protocolbuffers/\n"
"\t 2   temporal\n"
"\t22   temporal C++ Installation - Unix\n"
"\t22   temporal =======================\n"
"\t 2   temporal\n"
"\t79    schacon Committing in git-svn.\n"
"\t78    schacon\n"
"\t 2   temporal To build and install the C++ Protocol Buffer runtime and the "
"Protocol\n"
"\t 2   temporal Buffer compiler (protoc) execute the following:\n"
"\t 2   temporal"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:307
msgid ""
"Again, it doesn’t show commits that you did locally in Git or that have been "
"pushed to Subversion in the meantime."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:309
msgid "#### SVN Server Information ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:311
msgid ""
"You can also get the same sort of information that `svn info` gives you by "
"running `git svn info`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:313
msgid ""
"\t$ git svn info\n"
"\tPath: .\n"
"\tURL: https://schacon-test.googlecode.com/svn/trunk\n"
"\tRepository Root: https://schacon-test.googlecode.com/svn\n"
"\tRepository UUID: 4c93b258-373f-11de-be05-5f7a86268029\n"
"\tRevision: 87\n"
"\tNode Kind: directory\n"
"\tSchedule: normal\n"
"\tLast Changed Author: schacon\n"
"\tLast Changed Rev: 87\n"
"\tLast Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:325
msgid ""
"This is like `blame` and `log` in that it runs offline and is up to date "
"only as of the last time you communicated with the Subversion server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:327
msgid "#### Ignoring What Subversion Ignores ####"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:329
msgid ""
"If you clone a Subversion repository that has `svn:ignore` properties set "
"anywhere, you’ll likely want to set corresponding `.gitignore` files so you "
"don’t accidentally commit files that you shouldn’t. `git svn` has two "
"commands to help with this issue. The first is `git svn create-ignore`, "
"which automatically creates corresponding `.gitignore` files for you so your "
"next commit can include them."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:331
msgid ""
"The second command is `git svn show-ignore`, which prints to stdout the "
"lines you need to put in a `.gitignore` file so you can redirect the output "
"into your project exclude file:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:333
msgid "\t$ git svn show-ignore > .git/info/exclude"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:335
msgid ""
"That way, you don’t litter the project with `.gitignore` files. This is a "
"good option if you’re the only Git user on a Subversion team, and your "
"teammates don’t want `.gitignore` files in the project."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:337
msgid "### Git-Svn Summary ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:339
msgid ""
"The `git svn` tools are useful if you’re stuck with a Subversion server for "
"now or are otherwise in a development environment that necessitates running "
"a Subversion server. You should consider it crippled Git, however, or you’ll "
"hit issues in translation that may confuse you and your collaborators. To "
"stay out of trouble, try to follow these guidelines:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:341
msgid ""
"* Keep a linear Git history that doesn’t contain merge commits made by `git "
"merge`. Rebase any work you do outside of your mainline branch back onto it; "
"don’t merge it in.\n"
"* Don’t set up and collaborate on a separate Git server. Possibly have one "
"to speed up clones for new developers, but don’t push anything to it that "
"doesn’t have a `git-svn-id` entry. You may even want to add a `pre-receive` "
"hook that checks each commit message for a `git-svn-id` and rejects pushes "
"that contain commits without it."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:344
msgid ""
"If you follow those guidelines, working with a Subversion server can be more "
"bearable. However, if it’s possible to move to a real Git server, doing so "
"can gain your team a lot more."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:346
msgid "## Migrating to Git ##"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:348
msgid ""
"If you have an existing codebase in another VCS but you’ve decided to start "
"using Git, you must migrate your project one way or another. This section "
"goes over some importers that are included with Git for common systems and "
"then demonstrates how to develop your own custom importer."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:350
msgid "### Importing ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:352
msgid ""
"You’ll learn how to import data from two of the bigger professionally used "
"SCM systems — Subversion and Perforce — both because they make up the "
"majority of users I hear of who are currently switching, and because high-"
"quality tools for both systems are distributed with Git."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:354
msgid "### Subversion ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:356
msgid ""
"If you read the previous section about using `git svn`, you can easily use "
"those instructions to `git svn clone` a repository; then, stop using the "
"Subversion server, push to a new Git server, and start using that. If you "
"want the history, you can accomplish that as quickly as you can pull the "
"data out of the Subversion server (which may take a while)."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:358
msgid ""
"However, the import isn’t perfect; and because it will take so long, you may "
"as well do it right. The first problem is the author information. In "
"Subversion, each person committing has a user on the system who is recorded "
"in the commit information. The examples in the previous section show "
"`schacon` in some places, such as the `blame` output and the `git svn log`. "
"If you want to map this to better Git author data, you need a mapping from "
"the Subversion users to the Git authors. Create a file called `users.txt` "
"that has this mapping in a format like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:360
msgid ""
"\tschacon = Scott Chacon <schacon@geemail.com>\n"
"\tselse = Someo Nelse <selse@geemail.com>"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:363
msgid "To get a list of the author names that SVN uses, you can run this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:365
msgid ""
"\t$ svn log --xml | grep -P \"^<author\" | sort -u | \\\n"
"\t      perl -pe 's/<author>(.*?)<\\/author>/$1 = /'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:368
msgid ""
"That gives you the log output in XML format — you can look for the authors, "
"create a unique list, and then strip out the XML. (Obviously this only works "
"on a machine with `grep`, `sort`, and `perl` installed.) Then, redirect that "
"output into your users.txt file so you can add the equivalent Git user data "
"next to each entry."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:370
msgid ""
"You can provide this file to `git svn` to help it map the author data more "
"accurately. You can also tell `git svn` not to include the metadata that "
"Subversion normally imports, by passing `--no-metadata` to the `clone` or "
"`init` command. This makes your `import` command look like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:372
msgid ""
"\t$ git-svn clone http://my-project.googlecode.com/svn/ \\\n"
"\t      --authors-file=users.txt --no-metadata -s my_project"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:375
msgid ""
"Now you should have a nicer Subversion import in your `my_project` "
"directory. Instead of commits that look like this"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:377
msgid ""
"\tcommit 37efa680e8473b615de980fa935944215428a35a\n"
"\tAuthor: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\n"
"\tDate:   Sun May 3 00:12:22 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:381
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:381"
msgid "\t    fixed install - go to trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:383
msgid ""
"\t    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 "
"4c93b258-373f-11de-\n"
"\t    be05-5f7a86268029\n"
"they look like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:387
msgid ""
"\tcommit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2\n"
"\tAuthor: Scott Chacon <schacon@geemail.com>\n"
"\tDate:   Sun May 3 00:12:22 2009 +0000"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:391
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:391"
msgid "\t    fixed install - go to trunk"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:393
msgid ""
"Not only does the Author field look a lot better, but the `git-svn-id` is no "
"longer there, either."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:395
msgid ""
"You need to do a bit of `post-import` cleanup. For one thing, you should "
"clean up the weird references that `git svn` set up. First you’ll move the "
"tags so they’re actual tags rather than strange remote branches, and then "
"you’ll move the rest of the branches so they’re local."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:397
msgid "To move the tags to be proper Git tags, run"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:399
msgid ""
"\t$ git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while "
"read tagname; do git tag \"$tagname\" \"tags/$tagname\"; git branch -r -d "
"\"tags/$tagname\"; done"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:401
msgid ""
"This takes the references that were remote branches that started with `tag/` "
"and makes them real (lightweight) tags."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:403
msgid ""
"Next, move the rest of the references under `refs/remotes` to be local "
"branches:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:405
msgid ""
"\t$ git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read "
"branchname; do git branch \"$branchname\" \"refs/remotes/$branchname\"; git "
"branch -r -d \"$branchname\"; done"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:407
msgid ""
"Now all the old branches are real Git branches and all the old tags are real "
"Git tags. The last thing to do is add your new Git server as a remote and "
"push to it. Here is an example of adding your server as a remote:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:409
msgid "\t$ git remote add origin git@my-git-server:myrepository.git"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:411
msgid ""
"Because you want all your branches and tags to go up, you can now run this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:413
msgid ""
"\t$ git push origin --all\n"
"\t$ git push origin --tags"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:416
msgid ""
"All your branches and tags should be on your new Git server in a nice, clean "
"import."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:418
msgid "### Perforce ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:420
msgid ""
"The next system you’ll look at importing from is Perforce. A Perforce "
"importer is also distributed with Git, but only in the `contrib` section of "
"the source code — it isn’t available by default like `git svn`. To run it, "
"you must get the Git source code, which you can download from git.kernel.org:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:422
msgid ""
"\t$ git clone git://git.kernel.org/pub/scm/git/git.git\n"
"\t$ cd git/contrib/fast-import"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:425
msgid ""
"In this `fast-import` directory, you should find an executable Python script "
"named `git-p4`. You must have Python and the `p4` tool installed on your "
"machine for this import to work. For example, you’ll import the Jam project "
"from the Perforce Public Depot. To set up your client, you must export the "
"P4PORT environment variable to point to the Perforce depot:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:427
msgid "\t$ export P4PORT=public.perforce.com:1666"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:429
msgid ""
"Run the `git-p4 clone` command to import the Jam project from the Perforce "
"server, supplying the depot and project path and the path into which you "
"want to import the project:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:431
msgid ""
"\t$ git-p4 clone //public/jam/src@all /opt/p4import\n"
"\tImporting from //public/jam/src@all into /opt/p4import\n"
"\tReinitialized existing Git repository in /opt/p4import/.git/\n"
"\tImport destination: refs/remotes/p4/master\n"
"\tImporting revision 4409 (100%)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:437
msgid ""
"If you go to the `/opt/p4import` directory and run `git log`, you can see "
"your imported work:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:439
msgid ""
"\t$ git log -2\n"
"\tcommit 1fd4ec126171790efd2db83548b85b1bbbc07dc2\n"
"\tAuthor: Perforce staff <support@perforce.com>\n"
"\tDate:   Thu Aug 19 10:18:45 2004 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:444
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:444"
msgid ""
"\t    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\n"
"\t    the main part of the document.  Built new tar/zip balls."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:447
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:447"
msgid "\t    Only 16 months later."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:449
msgid "\t    [git-p4: depot-paths = \"//public/jam/src/\": change = 4409]"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:451
msgid ""
"\tcommit ca8870db541a23ed867f38847eda65bf4363371d\n"
"\tAuthor: Richard Geiger <rmg@perforce.com>\n"
"\tDate:   Tue Apr 22 20:51:34 2003 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:455
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:455"
msgid "\t    Update derived jamgram.c"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:457
msgid "\t    [git-p4: depot-paths = \"//public/jam/src/\": change = 3108]"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:459
msgid ""
"You can see the `git-p4` identifier in each commit. It’s fine to keep that "
"identifier there, in case you need to reference the Perforce change number "
"later. However, if you’d like to remove the identifier, now is the time to "
"do so — before you start doing work on the new repository. You can use `git "
"filter-branch` to remove the identifier strings en masse:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:461
msgid ""
"\t$ git filter-branch --msg-filter '\n"
"\t        sed -e \"/^\\[git-p4:/d\"\n"
"\t'\n"
"\tRewrite 1fd4ec126171790efd2db83548b85b1bbbc07dc2 (123/123)\n"
"\tRef 'refs/heads/master' was rewritten"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:467
msgid ""
"If you run `git log`, you can see that all the SHA-1 checksums for the "
"commits have changed, but the `git-p4` strings are no longer in the commit "
"messages:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:469
msgid ""
"\t$ git log -2\n"
"\tcommit 10a16d60cffca14d454a15c6164378f4082bc5b0\n"
"\tAuthor: Perforce staff <support@perforce.com>\n"
"\tDate:   Thu Aug 19 10:18:45 2004 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:474
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:474"
msgid ""
"\t    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\n"
"\t    the main part of the document.  Built new tar/zip balls."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:477
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:477"
msgid "\t    Only 16 months later."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:479
msgid ""
"\tcommit 2b6c6db311dd76c34c66ec1c40a49405e6b527b2\n"
"\tAuthor: Richard Geiger <rmg@perforce.com>\n"
"\tDate:   Tue Apr 22 20:51:34 2003 -0800"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:483
msgctxt "en/08-git-and-other-scms/01-chapter8.markdown:483"
msgid "\t    Update derived jamgram.c"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:485
msgid "Your import is ready to push up to your new Git server."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:487
msgid "### A Custom Importer ###"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:489
msgid ""
"If your system isn’t Subversion or Perforce, you should look for an importer "
"online — quality importers are available for CVS, Clear Case, Visual Source "
"Safe, even a directory of archives. If none of these tools works for you, "
"you have a rarer tool, or you otherwise need a more custom importing "
"process, you should use `git fast-import`. This command reads simple "
"instructions from stdin to write specific Git data. It’s much easier to "
"create Git objects this way than to run the raw Git commands or try to write "
"the raw objects (see Chapter 9 for more information). This way, you can "
"write an import script that reads the necessary information out of the "
"system you’re importing from and prints straightforward instructions to "
"stdout. You can then run this program and pipe its output through `git fast-"
"import`."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:491
msgid ""
"To quickly demonstrate, you’ll write a simple importer. Suppose you work in "
"current, you back up your project by occasionally copying the directory into "
"a time-stamped `back_YYYY_MM_DD` backup directory, and you want to import "
"this into Git. Your directory structure looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:493
msgid ""
"\t$ ls /opt/import_from\n"
"\tback_2009_01_02\n"
"\tback_2009_01_04\n"
"\tback_2009_01_14\n"
"\tback_2009_02_03\n"
"\tcurrent"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:500
msgid ""
"In order to import a Git directory, you need to review how Git stores its "
"data. As you may remember, Git is fundamentally a linked list of commit "
"objects that point to a snapshot of content. All you have to do is tell "
"`fast-import` what the content snapshots are, what commit data points to "
"them, and the order they go in. Your strategy will be to go through the "
"snapshots one at a time and create commits with the contents of each "
"directory, linking each commit back to the previous one."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:502
msgid ""
"As you did in the \"An Example Git Enforced Policy\" section of Chapter 7, "
"we’ll write this in Ruby, because it’s what I generally work with and it "
"tends to be easy to read. You can write this example pretty easily in "
"anything you’re familiar with — it just needs to print the appropriate "
"information to stdout. And, if you are running on Windows, this means you’ll "
"need to take special care to not introduce carriage returns at the end your "
"lines — git fast-import is very particular about just wanting line feeds "
"(LF) not the carriage return line feeds (CRLF) that Windows uses."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:504
msgid ""
"To begin, you’ll change into the target directory and identify every "
"subdirectory, each of which is a snapshot that you want to import as a "
"commit. You’ll change into each subdirectory and print the commands "
"necessary to export it. Your basic main loop looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:506
msgid "\tlast_mark = nil"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:508
msgid ""
"\t# loop through the directories\n"
"\tDir.chdir(ARGV[0]) do\n"
"\t  Dir.glob(\"*\").each do |dir|\n"
"\t    next if File.file?(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:513
msgid ""
"\t    # move into the target directory\n"
"\t    Dir.chdir(dir) do\n"
"\t      last_mark = print_export(dir, last_mark)\n"
"\t    end\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:520
msgid ""
"You run `print_export` inside each directory, which takes the manifest and "
"mark of the previous snapshot and returns the manifest and mark of this one; "
"that way, you can link them properly. \"Mark\" is the `fast-import` term for "
"an identifier you give to a commit; as you create commits, you give each one "
"a mark that you can use to link to it from other commits. So, the first "
"thing to do in your `print_export` method is generate a mark from the "
"directory name:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:522
msgid "\tmark = convert_dir_to_mark(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:524
msgid ""
"You’ll do this by creating an array of directories and using the index value "
"as the mark, because a mark must be an integer. Your method looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:526
msgid ""
"\t$marks = []\n"
"\tdef convert_dir_to_mark(dir)\n"
"\t  if !$marks.include?(dir)\n"
"\t    $marks << dir\n"
"\t  end\n"
"\t  ($marks.index(dir) + 1).to_s\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:534
msgid ""
"Now that you have an integer representation of your commit, you need a date "
"for the commit metadata. Because the date is expressed in the name of the "
"directory, you’ll parse it out. The next line in your `print_export` file is"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:536
msgid "\tdate = convert_dir_to_date(dir)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:538
msgid "where `convert_dir_to_date` is defined as"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:540
msgid ""
"\tdef convert_dir_to_date(dir)\n"
"\t  if dir == 'current'\n"
"\t    return Time.now().to_i\n"
"\t  else\n"
"\t    dir = dir.gsub('back_', '')\n"
"\t    (year, month, day) = dir.split('_')\n"
"\t    return Time.local(year, month, day).to_i\n"
"\t  end\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:550
msgid ""
"That returns an integer value for the date of each directory. The last piece "
"of meta-information you need for each commit is the committer data, which "
"you hardcode in a global variable:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:552
msgid "\t$author = 'Scott Chacon <schacon@example.com>'"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:554
msgid ""
"Now you’re ready to begin printing out the commit data for your importer. "
"The initial information states that you’re defining a commit object and what "
"branch it’s on, followed by the mark you’ve generated, the committer "
"information and commit message, and then the previous commit, if any. The "
"code looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:556
msgid ""
"\t# print the import information\n"
"\tputs 'commit refs/heads/master'\n"
"\tputs 'mark :' + mark\n"
"\tputs \"committer #{$author} #{date} -0700\"\n"
"\texport_data('imported from ' + dir)\n"
"\tputs 'from :' + last_mark if last_mark"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:563
msgid ""
"You hardcode the time zone (-0700) because doing so is easy. If you’re "
"importing from another system, you must specify the time zone as an offset.\n"
"The commit message must be expressed in a special format:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:566
msgid "\tdata (size)\\n(contents)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:568
msgid ""
"The format consists of the word data, the size of the data to be read, a "
"newline, and finally the data. Because you need to use the same format to "
"specify the file contents later, you create a helper method, `export_data`:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:570
msgid ""
"\tdef export_data(string)\n"
"\t  print \"data #{string.size}\\n#{string}\"\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:574
msgid ""
"All that’s left is to specify the file contents for each snapshot. This is "
"easy, because you have each one in a directory — you can print out the "
"`deleteall` command followed by the contents of each file in the directory. "
"Git will then record each snapshot appropriately:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:576
msgid ""
"\tputs 'deleteall'\n"
"\tDir.glob(\"**/*\").each do |file|\n"
"\t  next if !File.file?(file)\n"
"\t  inline_data(file)\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:582
msgid ""
"Note:\tBecause many systems think of their revisions as changes from one "
"commit to another, fast-import can also take commands with each commit to "
"specify which files have been added, removed, or modified and what the new "
"contents are. You could calculate the differences between snapshots and "
"provide only this data, but doing so is more complex — you may as well give "
"Git all the data and let it figure it out. If this is better suited to your "
"data, check the `fast-import` man page for details about how to provide your "
"data in this manner."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:584
msgid ""
"The format for listing the new file contents or specifying a modified file "
"with the new contents is as follows:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:586
msgid ""
"\tM 644 inline path/to/file\n"
"\tdata (size)\n"
"\t(file contents)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:590
msgid ""
"Here, 644 is the mode (if you have executable files, you need to detect and "
"specify 755 instead), and inline says you’ll list the contents immediately "
"after this line. Your `inline_data` method looks like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:592
msgid ""
"\tdef inline_data(file, code = 'M', mode = '644')\n"
"\t  content = File.read(file)\n"
"\t  puts \"#{code} #{mode} inline #{file}\"\n"
"\t  export_data(content)\n"
"\tend"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:598
msgid ""
"You reuse the `export_data` method you defined earlier, because it’s the "
"same as the way you specified your commit message data."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:600
msgid ""
"The last thing you need to do is to return the current mark so it can be "
"passed to the next iteration:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:602
msgid "\treturn mark"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:604
msgid ""
"NOTE: If you are running on Windows you’ll need to make sure that you add "
"one extra step. As metioned before, Windows uses CRLF for new line "
"characters while git fast-import expects only LF. To get around this problem "
"and make git fast-import happy, you need to tell ruby to use LF instead of "
"CRLF:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:606
msgid "\t$stdout.binmode"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:608
msgid ""
"That’s it. If you run this script, you’ll get content that looks something "
"like this:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:610
msgid ""
"\t$ ruby import.rb /opt/import_from\n"
"\tcommit refs/heads/master\n"
"\tmark :1\n"
"\tcommitter Scott Chacon <schacon@geemail.com> 1230883200 -0700\n"
"\tdata 29\n"
"\timported from back_2009_01_02deleteall\n"
"\tM 644 inline file.rb\n"
"\tdata 12\n"
"\tversion two\n"
"\tcommit refs/heads/master\n"
"\tmark :2\n"
"\tcommitter Scott Chacon <schacon@geemail.com> 1231056000 -0700\n"
"\tdata 29\n"
"\timported from back_2009_01_04from :1\n"
"\tdeleteall\n"
"\tM 644 inline file.rb\n"
"\tdata 14\n"
"\tversion three\n"
"\tM 644 inline new.rb\n"
"\tdata 16\n"
"\tnew version one\n"
"\t(...)"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:633
msgid ""
"To run the importer, pipe this output through `git fast-import` while in the "
"Git directory you want to import into. You can create a new directory and "
"then run `git init` in it for a starting point, and then run your script:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:635
msgid ""
"\t$ git init\n"
"\tInitialized empty Git repository in /opt/import_to/.git/\n"
"\t$ ruby import.rb /opt/import_from | git fast-import\n"
"\tgit-fast-import statistics:\n"
"\t---------------------------------------------------------------------\n"
"\tAlloc'd objects:       5000\n"
"\tTotal objects:           18 (         1 duplicates                  )\n"
"\t      blobs  :            7 (         1 duplicates          0 deltas)\n"
"\t      trees  :            6 (         0 duplicates          1 deltas)\n"
"\t      commits:            5 (         0 duplicates          0 deltas)\n"
"\t      tags   :            0 (         0 duplicates          0 deltas)\n"
"\tTotal branches:           1 (         1 loads     )\n"
"\t      marks:           1024 (         5 unique    )\n"
"\t      atoms:              3\n"
"\tMemory total:          2255 KiB\n"
"\t       pools:          2098 KiB\n"
"\t     objects:           156 KiB\n"
"\t---------------------------------------------------------------------\n"
"\tpack_report: getpagesize()            =       4096\n"
"\tpack_report: core.packedGitWindowSize =   33554432\n"
"\tpack_report: core.packedGitLimit      =  268435456\n"
"\tpack_report: pack_used_ctr            =          9\n"
"\tpack_report: pack_mmap_calls          =          5\n"
"\tpack_report: pack_open_windows        =          1 /          1\n"
"\tpack_report: pack_mapped              =       1356 /       1356\n"
"\t---------------------------------------------------------------------"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:662
msgid ""
"As you can see, when it completes successfully, it gives you a bunch of "
"statistics about what it accomplished. In this case, you imported 18 objects "
"total for 5 commits into 1 branch. Now, you can run `git log` to see your "
"new history:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:664
msgid ""
"\t$ git log -2\n"
"\tcommit 10bfe7d22ce15ee25b60a824c8982157ca593d41\n"
"\tAuthor: Scott Chacon <schacon@example.com>\n"
"\tDate:   Sun May 3 12:57:39 2009 -0700"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:669
msgid "\t    imported from current"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:671
msgid ""
"\tcommit 7e519590de754d079dd73b44d695a42c9d2df452\n"
"\tAuthor: Scott Chacon <schacon@example.com>\n"
"\tDate:   Tue Feb 3 01:00:00 2009 -0700"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:675
msgid "\t    imported from back_2009_02_03"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:677
msgid ""
"There you go — a nice, clean Git repository. It’s important to note that "
"nothing is checked out — you don’t have any files in your working directory "
"at first. To get them, you must reset your branch to where `master` is now:"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:679
msgid ""
"\t$ ls\n"
"\t$ git reset --hard master\n"
"\tHEAD is now at 10bfe7d imported from current\n"
"\t$ ls\n"
"\tfile.rb  lib"
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:685
msgid ""
"You can do a lot more with the `fast-import` tool — handle different modes, "
"binary data, multiple branches and merging, tags, progress indicators, and "
"more. A number of examples of more complex scenarios are available in the "
"`contrib/fast-import` directory of the Git source code; one of the better "
"ones is the `git-p4` script I just covered."
msgstr ""

#: en/08-git-and-other-scms/01-chapter8.markdown:689
msgid ""
"You should feel comfortable using Git with Subversion or importing nearly "
"any existing repository into a new Git one without losing data. The next "
"chapter will cover the raw internals of Git so you can craft every single "
"byte, if need be."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:1
msgid "# Git Internals #"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:3
msgid ""
"You may have skipped to this chapter from a previous chapter, or you may "
"have gotten here after reading the rest of the book — in either case, this "
"is where you’ll go over the inner workings and implementation of Git. I "
"found that learning this information was fundamentally important to "
"understanding how useful and powerful Git is, but others have argued to me "
"that it can be confusing and unnecessarily complex for beginners. Thus, I’ve "
"made this discussion the last chapter in the book so you could read it early "
"or later in your learning process. I leave it up to you to decide."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:5
msgid ""
"Now that you’re here, let’s get started. First, if it isn’t yet clear, Git "
"is fundamentally a content-addressable filesystem with a VCS user interface "
"written on top of it. You’ll learn more about what this means in a bit."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:7
msgid ""
"In the early days of Git (mostly pre 1.5), the user interface was much more "
"complex because it emphasized this filesystem rather than a polished VCS. In "
"the last few years, the UI has been refined until it’s as clean and easy to "
"use as any system out there; but often, the stereotype lingers about the "
"early Git UI that was complex and difficult to learn."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:9
msgid ""
"The content-addressable filesystem layer is amazingly cool, so I’ll cover "
"that first in this chapter; then, you’ll learn about the transport "
"mechanisms and the repository maintenance tasks that you may eventually have "
"to deal with."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:11
msgid "## Plumbing and Porcelain ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:13
msgid ""
"This book covers how to use Git with 30 or so verbs such as `checkout`, "
"`branch`, `remote`, and so on. But because Git was initially a toolkit for a "
"VCS rather than a full user-friendly VCS, it has a bunch of verbs that do "
"low-level work and were designed to be chained together UNIX style or called "
"from scripts. These commands are generally referred to as \"plumbing\" "
"commands, and the more user-friendly commands are called \"porcelain\" "
"commands."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:15
msgid ""
"The book’s first eight chapters deal almost exclusively with porcelain "
"commands. But in this chapter, you’ll be dealing mostly with the lower-level "
"plumbing commands, because they give you access to the inner workings of Git "
"and help demonstrate how and why Git does what it does. These commands "
"aren’t meant to be used manually on the command line, but rather to be used "
"as building blocks for new tools and custom scripts."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:17
msgid ""
"When you run `git init` in a new or existing directory, Git creates the `."
"git` directory, which is where almost everything that Git stores and "
"manipulates is located. If you want to back up or clone your repository, "
"copying this single directory elsewhere gives you nearly everything you "
"need. This entire chapter basically deals with the stuff in this directory. "
"Here’s what it looks like:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:19
msgid ""
"\t$ ls\n"
"\tHEAD\n"
"\tbranches/\n"
"\tconfig\n"
"\tdescription\n"
"\thooks/\n"
"\tindex\n"
"\tinfo/\n"
"\tobjects/\n"
"\trefs/"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:30
msgid ""
"You may see some other files in there, but this is a fresh `git init` "
"repository — it’s what you see by default. The `branches` directory isn’t "
"used by newer Git versions, and the `description` file is only used by the "
"GitWeb program, so don’t worry about those. The `config` file contains your "
"project-specific configuration options, and the `info` directory keeps a "
"global exclude file for ignored patterns that you don’t want to track in a ."
"gitignore file. The `hooks` directory contains your client- or server-side "
"hook scripts, which are discussed in detail in Chapter 7."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:32
msgid ""
"This leaves four important entries: the `HEAD` and `index` files and the "
"`objects` and `refs` directories. These are the core parts of Git. The "
"`objects` directory stores all the content for your database, the `refs` "
"directory stores pointers into commit objects in that data (branches), the "
"`HEAD` file points to the branch you currently have checked out, and the "
"`index` file is where Git stores your staging area information. You’ll now "
"look at each of these sections in detail to see how Git operates."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:34
msgid "## Git Objects ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:36
msgid ""
"Git is a content-addressable filesystem. Great. What does that mean?\n"
"It means that at the core of Git is a simple key-value data store. You can "
"insert any kind of content into it, and it will give you back a key that you "
"can use to retrieve the content again at any time. To demonstrate, you can "
"use the plumbing command `hash-object`, which takes some data, stores it in "
"your `.git` directory, and gives you back the key the data is stored as. "
"First, you initialize a new Git repository and verify that there is nothing "
"in the `objects` directory:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:39
msgid ""
"\t$ mkdir test\n"
"\t$ cd test\n"
"\t$ git init\n"
"\tInitialized empty Git repository in /tmp/test/.git/\n"
"\t$ find .git/objects\n"
"\t.git/objects\n"
"\t.git/objects/info\n"
"\t.git/objects/pack\n"
"\t$ find .git/objects -type f\n"
"\t$"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:50
msgid ""
"Git has initialized the `objects` directory and created `pack` and `info` "
"subdirectories in it, but there are no regular files. Now, store some text "
"in your Git database:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:52
msgid ""
"\t$ echo 'test content' | git hash-object -w --stdin\n"
"\td670460b4b4aece5915caf5c68d12f560a9fe3e4"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:55
msgid ""
"The `-w` tells `hash-object` to store the object; otherwise, the command "
"simply tells you what the key would be. `--stdin` tells the command to read "
"the content from stdin; if you don’t specify this, `hash-object` expects the "
"path to a file. The output from the command is a 40-character checksum hash. "
"This is the SHA-1 hash — a checksum of the content you’re storing plus a "
"header, which you’ll learn about in a bit. Now you can see how Git has "
"stored your data:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:57
msgid ""
"\t$ find .git/objects -type f\n"
"\t.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:60
msgid ""
"You can see a file in the `objects` directory. This is how Git stores the "
"content initially — as a single file per piece of content, named with the "
"SHA-1 checksum of the content and its header. The subdirectory is named with "
"the first 2 characters of the SHA, and the filename is the remaining 38 "
"characters."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:62
msgid ""
"You can pull the content back out of Git with the `cat-file` command. This "
"command is sort of a Swiss army knife for inspecting Git objects. Passing `-"
"p` to it instructs the `cat-file` command to figure out the type of content "
"and display it nicely for you:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:64
msgid ""
"\t$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\n"
"\ttest content"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:67
msgid ""
"Now, you can add content to Git and pull it back out again. You can also do "
"this with content in files. For example, you can do some simple version "
"control on a file. First, create a new file and save its contents in your "
"database:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:69
msgid ""
"\t$ echo 'version 1' > test.txt\n"
"\t$ git hash-object -w test.txt\n"
"\t83baae61804e65cc73a7201a7252750c76066a30"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:73
msgid "Then, write some new content to the file, and save it again:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:75
msgid ""
"\t$ echo 'version 2' > test.txt\n"
"\t$ git hash-object -w test.txt\n"
"\t1f7a7a472abf3dd9643fd615f6da379c4acb3e3a"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:79
msgid ""
"Your database contains the two new versions of the file as well as the first "
"content you stored there:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:81
msgid ""
"\t$ find .git/objects -type f\n"
"\t.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n"
"\t.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n"
"\t.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:86
msgid "Now you can revert the file back to the first version"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:88
msgid ""
"\t$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n"
"\t$ cat test.txt\n"
"\tversion 1"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:92
msgid "or the second version:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:94
msgid ""
"\t$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n"
"\t$ cat test.txt\n"
"\tversion 2"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:98
msgid ""
"But remembering the SHA-1 key for each version of your file isn’t practical; "
"plus, you aren’t storing the filename in your system — just the content. "
"This object type is called a blob. You can have Git tell you the object type "
"of any object in Git, given its SHA-1 key, with `cat-file -t`:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:100
msgid ""
"\t$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n"
"\tblob"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:103
msgid "### Tree Objects ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:105
msgid ""
"The next type you’ll look at is the tree object, which solves the problem of "
"storing the filename and also allows you to store a group of files together. "
"Git stores content in a manner similar to a UNIX filesystem, but a bit "
"simplified. All the content is stored as tree and blob objects, with trees "
"corresponding to UNIX directory entries and blobs corresponding more or less "
"to inodes or file contents. A single tree object contains one or more tree "
"entries, each of which contains a SHA-1 pointer to a blob or subtree with "
"its associated mode, type, and filename. For example, the most recent tree "
"in the simplegit project may look something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:107
msgid ""
"\t$ git cat-file -p master^{tree}\n"
"\t100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n"
"\t100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n"
"\t040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:112
msgid ""
"The `master^{tree}` syntax specifies the tree object that is pointed to by "
"the last commit on your `master` branch. Notice that the `lib` subdirectory "
"isn’t a blob but a pointer to another tree:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:114
msgid ""
"\t$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n"
"\t100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:117
msgid ""
"Conceptually, the data that Git is storing is something like Figure 9-1."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:119
msgid ""
"Insert 18333fig0901.png\n"
"Figure 9-1. Simple version of the Git data model."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:122
msgid ""
"You can create your own tree. Git normally creates a tree by taking the "
"state of your staging area or index and writing a tree object from it. So, "
"to create a tree object, you first have to set up an index by staging some "
"files. To create an index with a single entry — the first version of your "
"test.txt file — you can use the plumbing command `update-index`. You use "
"this command to artificially add the earlier version of the test.txt file to "
"a new staging area. You must pass it the `--add` option because the file "
"doesn’t yet exist in your staging area (you don’t even have a staging area "
"set up yet) and `--cacheinfo` because the file you’re adding isn’t in your "
"directory but is in your database. Then, you specify the mode, SHA-1, and "
"filename:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:124
msgid ""
"\t$ git update-index --add --cacheinfo 100644 \\\n"
"\t  83baae61804e65cc73a7201a7252750c76066a30 test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:127
msgid ""
"In this case, you’re specifying a mode of `100644`, which means it’s a "
"normal file. Other options are `100755`, which means it’s an executable "
"file; and `120000`, which specifies a symbolic link. The mode is taken from "
"normal UNIX modes but is much less flexible — these three modes are the only "
"ones that are valid for files (blobs) in Git (although other modes are used "
"for directories and submodules)."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:129
msgid ""
"Now, you can use the `write-tree` command to write the staging area out to a "
"tree object. No `-w` option is needed — calling `write-tree` automatically "
"creates a tree object from the state of the index if that tree doesn’t yet "
"exist:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:131
msgid ""
"\t$ git write-tree\n"
"\td8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"
"\t$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"
"\t100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:136
msgid "You can also verify that this is a tree object:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:138
msgid ""
"\t$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"
"\ttree"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:141
msgid ""
"You’ll now create a new tree with the second version of test.txt and a new "
"file as well:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:143
msgid ""
"\t$ echo 'new file' > new.txt\n"
"\t$ git update-index test.txt\n"
"\t$ git update-index --add new.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:147
msgid ""
"Your staging area now has the new version of test.txt as well as the new "
"file new.txt. Write out that tree (recording the state of the staging area "
"or index to a tree object) and see what it looks like:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:149
msgid ""
"\t$ git write-tree\n"
"\t0155eb4229851634a0f03eb265b69f5a2d56f341\n"
"\t$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n"
"\t100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n"
"\t100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:155
msgid ""
"Notice that this tree has both file entries and also that the test.txt SHA "
"is the \"version 2\" SHA from earlier (`1f7a7a`). Just for fun, you’ll add "
"the first tree as a subdirectory into this one. You can read trees into your "
"staging area by calling `read-tree`. In this case, you can read an existing "
"tree into your staging area as a subtree by using the `--prefix` option to "
"`read-tree`:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:157
msgid ""
"\t$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"
"\t$ git write-tree\n"
"\t3c4e9cd789d88d8d89c1073707c3585e41b0e614\n"
"\t$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n"
"\t040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\n"
"\t100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n"
"\t100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:165
msgid ""
"If you created a working directory from the new tree you just wrote, you "
"would get the two files in the top level of the working directory and a "
"subdirectory named `bak` that contained the first version of the test.txt "
"file. You can think of the data that Git contains for these structures as "
"being like Figure 9-2."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:167
msgid ""
"Insert 18333fig0902.png\n"
"Figure 9-2. The content structure of your current Git data."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:170
msgid "### Commit Objects ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:172
msgid ""
"You have three trees that specify the different snapshots of your project "
"that you want to track, but the earlier problem remains: you must remember "
"all three SHA-1 values in order to recall the snapshots. You also don’t have "
"any information about who saved the snapshots, when they were saved, or why "
"they were saved. This is the basic information that the commit object stores "
"for you."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:174
msgid ""
"To create a commit object, you call `commit-tree` and specify a single tree "
"SHA-1 and which commit objects, if any, directly preceded it. Start with the "
"first tree you wrote:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:176
msgid ""
"\t$ echo 'first commit' | git commit-tree d8329f\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:179
msgid "Now you can look at your new commit object with `cat-file`:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:181
msgid ""
"\t$ git cat-file -p fdf4fc3\n"
"\ttree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"
"\tauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\n"
"\tcommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:186
msgid "\tfirst commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:188
msgid ""
"The format for a commit object is simple: it specifies the top-level tree "
"for the snapshot of the project at that point; the author/committer "
"information pulled from your `user.name` and `user.email` configuration "
"settings, with the current timestamp; a blank line, and then the commit "
"message."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:190
msgid ""
"Next, you’ll write the other two commit objects, each referencing the commit "
"that came directly before it:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:192
msgid ""
"\t$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d\n"
"\t$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:197
msgid ""
"Each of the three commit objects points to one of the three snapshot trees "
"you created. Oddly enough, you have a real Git history now that you can view "
"with the `git log` command, if you run it on the last commit SHA-1:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:199
msgid ""
"\t$ git log --stat 1a410e\n"
"\tcommit 1a410efbd13591db07496601ebc7a059dd55cfe9\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri May 22 18:15:24 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:204
msgctxt "en/09-git-internals/01-chapter9.markdown:204"
msgid "\t    third commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:206
msgid ""
"\t bak/test.txt |    1 +\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:209
msgid ""
"\tcommit cac0cab538b970a37ea1e769cbbde608743bc96d\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri May 22 18:14:29 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:213
msgid "\t    second commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:215
msgid ""
"\t new.txt  |    1 +\n"
"\t test.txt |    2 +-\n"
"\t 2 files changed, 2 insertions(+), 1 deletions(-)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:219
msgid ""
"\tcommit fdf4fc3344e67ab068f836878b6c4951e3b15f3d\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri May 22 18:09:34 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:223
msgid "\t    first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:225
msgid ""
"\t test.txt |    1 +\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:228
msgid ""
"Amazing. You’ve just done the low-level operations to build up a Git history "
"without using any of the front ends. This is essentially what Git does when "
"you run the `git add` and `git commit` commands — it stores blobs for the "
"files that have changed, updates the index, writes out trees, and writes "
"commit objects that reference the top-level trees and the commits that came "
"immediately before them. These three main Git objects — the blob, the tree, "
"and the commit — are initially stored as separate files in your `.git/"
"objects` directory. Here are all the objects in the example directory now, "
"commented with what they store:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:230
msgid ""
"\t$ find .git/objects -type f\n"
"\t.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\n"
"\t.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\n"
"\t.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\n"
"\t.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\n"
"\t.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\n"
"\t.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\n"
"\t.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\n"
"\t.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\n"
"\t.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\n"
"\t.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:242
msgid ""
"If you follow all the internal pointers, you get an object graph something "
"like Figure 9-3."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:244
msgid ""
"Insert 18333fig0903.png\n"
"Figure 9-3. All the objects in your Git directory."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:247
msgid "### Object Storage ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:249
msgid ""
"I mentioned earlier that a header is stored with the content. Let’s take a "
"minute to look at how Git stores its objects. You’ll see how to store a blob "
"object — in this case, the string \"what is up, doc?\" — interactively in "
"the Ruby scripting language. You can start up interactive Ruby mode with the "
"`irb` command:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:251
msgid ""
"\t$ irb\n"
"\t>> content = \"what is up, doc?\"\n"
"\t=> \"what is up, doc?\""
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:255
msgid ""
"Git constructs a header that starts with the type of the object, in this "
"case a blob. Then, it adds a space followed by the size of the content and "
"finally a null byte:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:257
msgid ""
"\t>> header = \"blob #{content.length}\\0\"\n"
"\t=> \"blob 16\\000\""
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:260
msgid ""
"Git concatenates the header and the original content and then calculates the "
"SHA-1 checksum of that new content. You can calculate the SHA-1 value of a "
"string in Ruby by including the SHA1 digest library with the `require` "
"command and then calling `Digest::SHA1.hexdigest()` with the string:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:262
msgid ""
"\t>> store = header + content\n"
"\t=> \"blob 16\\000what is up, doc?\"\n"
"\t>> require 'digest/sha1'\n"
"\t=> true\n"
"\t>> sha1 = Digest::SHA1.hexdigest(store)\n"
"\t=> \"bd9dbf5aae1a3862dd1526723246b20206e5fc37\""
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:269
msgid ""
"Git compresses the new content with zlib, which you can do in Ruby with the "
"zlib library. First, you need to require the library and then run `Zlib::"
"Deflate.deflate()` on the content:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:271
msgid ""
"\t>> require 'zlib'\n"
"\t=> true\n"
"\t>> zlib_content = Zlib::Deflate.deflate(store)\n"
"\t=> \"x\\234K\\312\\311OR04c(\\317H,Q\\310,V(-\\320QH\\311O\\266\\a\\000_"
"\\034\\a\\235\""
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:276
msgid ""
"Finally, you’ll write your zlib-deflated content to an object on disk. "
"You’ll determine the path of the object you want to write out (the first two "
"characters of the SHA-1 value being the subdirectory name, and the last 38 "
"characters being the filename within that directory). In Ruby, you can use "
"the `FileUtils.mkdir_p()` function to create the subdirectory if it doesn’t "
"exist. Then, open the file with `File.open()` and write out the previously "
"zlib-compressed content to the file with a `write()` call on the resulting "
"file handle:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:278
msgid ""
"\t>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]\n"
"\t=> \".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37\"\n"
"\t>> require 'fileutils'\n"
"\t=> true\n"
"\t>> FileUtils.mkdir_p(File.dirname(path))\n"
"\t=> \".git/objects/bd\"\n"
"\t>> File.open(path, 'w') { |f| f.write zlib_content }\n"
"\t=> 32"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:287
msgid ""
"That’s it — you’ve created a valid Git blob object. All Git objects are "
"stored the same way, just with different types — instead of the string blob, "
"the header will begin with commit or tree. Also, although the blob content "
"can be nearly anything, the commit and tree content are very specifically "
"formatted."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:289
msgid "## Git References ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:291
msgid ""
"You can run something like `git log 1a410e` to look through your whole "
"history, but you still have to remember that `1a410e` is the last commit in "
"order to walk that history to find all those objects. You need a file in "
"which you can store the SHA-1 value under a simple name so you can use that "
"pointer rather than the raw SHA-1 value."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:293
msgid ""
"In Git, these are called \"references\" or \"refs\"; you can find the files "
"that contain the SHA-1 values in the `.git/refs` directory. In the current "
"project, this directory contains no files, but it does contain a simple "
"structure:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:295
msgid ""
"\t$ find .git/refs\n"
"\t.git/refs\n"
"\t.git/refs/heads\n"
"\t.git/refs/tags\n"
"\t$ find .git/refs -type f\n"
"\t$"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:302
msgid ""
"To create a new reference that will help you remember where your latest "
"commit is, you can technically do something as simple as this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:304
msgid ""
"\t$ echo \"1a410efbd13591db07496601ebc7a059dd55cfe9\" > .git/refs/heads/"
"master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:306
msgid ""
"Now, you can use the head reference you just created instead of the SHA-1 "
"value in your Git commands:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:308
msgid ""
"\t$ git log --pretty=oneline  master\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d second commit\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:313
msgid ""
"You aren’t encouraged to directly edit the reference files. Git provides a "
"safer command to do this if you want to update a reference called `update-"
"ref`:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:315
msgid ""
"\t$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:317
msgid ""
"That’s basically what a branch in Git is: a simple pointer or reference to "
"the head of a line of work. To create a branch back at the second commit, "
"you can do this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:319
msgid "\t$ git update-ref refs/heads/test cac0ca"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:321
msgid "Your branch will contain only work from that commit down:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:323
msgid ""
"\t$ git log --pretty=oneline test\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d second commit\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:327
msgid "Now, your Git database conceptually looks something like Figure 9-4."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:329
msgid ""
"Insert 18333fig0904.png\n"
"Figure 9-4. Git directory objects with branch head references included."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:332
msgid ""
"When you run commands like `git branch (branchname)`, Git basically runs "
"that `update-ref` command to add the SHA-1 of the last commit of the branch "
"you’re on into whatever new reference you want to create."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:334
msgid "### The HEAD ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:336
msgid ""
"The question now is, when you run `git branch (branchname)`, how does Git "
"know the SHA-1 of the last commit? The answer is the HEAD file. The HEAD "
"file is a symbolic reference to the branch you’re currently on. By symbolic "
"reference, I mean that unlike a normal reference, it doesn’t generally "
"contain a SHA-1 value but rather a pointer to another reference. If you look "
"at the file, you’ll normally see something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:338
msgid ""
"\t$ cat .git/HEAD\n"
"\tref: refs/heads/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:341
msgid "If you run `git checkout test`, Git updates the file to look like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:343
msgid ""
"\t$ cat .git/HEAD\n"
"\tref: refs/heads/test"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:346
msgid ""
"When you run `git commit`, it creates the commit object, specifying the "
"parent of that commit object to be whatever SHA-1 value the reference in "
"HEAD points to."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:348
msgid ""
"You can also manually edit this file, but again a safer command exists to do "
"so: `symbolic-ref`. You can read the value of your HEAD via this command:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:350
msgid ""
"\t$ git symbolic-ref HEAD\n"
"\trefs/heads/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:353
msgid "You can also set the value of HEAD:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:355
msgid ""
"\t$ git symbolic-ref HEAD refs/heads/test\n"
"\t$ cat .git/HEAD\n"
"\tref: refs/heads/test"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:359
msgid "You can’t set a symbolic reference outside of the refs style:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:361
msgid ""
"\t$ git symbolic-ref HEAD test\n"
"\tfatal: Refusing to point HEAD outside of refs/"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:364
msgid "### Tags ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:366
msgid ""
"You’ve just gone over Git’s three main object types, but there is a fourth. "
"The tag object is very much like a commit object — it contains a tagger, a "
"date, a message, and a pointer. The main difference is that a tag object "
"points to a commit rather than a tree. It’s like a branch reference, but it "
"never moves — it always points to the same commit but gives it a friendlier "
"name."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:368
msgid ""
"As discussed in Chapter 2, there are two types of tags: annotated and "
"lightweight. You can make a lightweight tag by running something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:370
msgid ""
"\t$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:372
msgid ""
"That is all a lightweight tag is — a branch that never moves. An annotated "
"tag is more complex, however. If you create an annotated tag, Git creates a "
"tag object and then writes a reference to point to it rather than directly "
"to the commit. You can see this by creating an annotated tag (`-a` specifies "
"that it’s an annotated tag):"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:374
msgid ""
"\t$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:376
msgid "Here’s the object SHA-1 value it created:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:378
msgid ""
"\t$ cat .git/refs/tags/v1.1\n"
"\t9585191f37f7b0fb9444f35a9bf50de191beadc2"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:381
msgid "Now, run the `cat-file` command on that SHA-1 value:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:383
msgid ""
"\t$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2\n"
"\tobject 1a410efbd13591db07496601ebc7a059dd55cfe9\n"
"\ttype commit\n"
"\ttag v1.1\n"
"\ttagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:389
msgid "\ttest tag"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:391
msgid ""
"Notice that the object entry points to the commit SHA-1 value that you "
"tagged. Also notice that it doesn’t need to point to a commit; you can tag "
"any Git object. In the Git source code, for example, the maintainer has "
"added their GPG public key as a blob object and then tagged it. You can view "
"the public key by running"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:393
msgid "\t$ git cat-file blob junio-gpg-pub"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:395
msgid ""
"in the Git source code repository. The Linux kernel repository also has a "
"non-commit-pointing tag object — the first tag created points to the initial "
"tree of the import of the source code."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:397
msgid "### Remotes ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:399
msgid ""
"The third type of reference that you’ll see is a remote reference. If you "
"add a remote and push to it, Git stores the value you last pushed to that "
"remote for each branch in the `refs/remotes` directory. For instance, you "
"can add a remote called `origin` and push your `master` branch to it:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:401
msgid ""
"\t$ git remote add origin git@github.com:schacon/simplegit-progit.git\n"
"\t$ git push origin master\n"
"\tCounting objects: 11, done.\n"
"\tCompressing objects: 100% (5/5), done.\n"
"\tWriting objects: 100% (7/7), 716 bytes, done.\n"
"\tTotal 7 (delta 2), reused 4 (delta 1)\n"
"\tTo git@github.com:schacon/simplegit-progit.git\n"
"\t   a11bef0..ca82a6d  master -> master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:410
msgid ""
"Then, you can see what the `master` branch on the `origin` remote was the "
"last time you communicated with the server, by checking the `refs/remotes/"
"origin/master` file:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:412
msgid ""
"\t$ cat .git/refs/remotes/origin/master\n"
"\tca82a6dff817ec66f44342007202690a93763949"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:415
msgid ""
"Remote references differ from branches (`refs/heads` references) mainly in "
"that they can’t be checked out. Git moves them around as bookmarks to the "
"last known state of where those branches were on those servers."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:417
msgid "## Packfiles ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:419
msgid ""
"Let’s go back to the objects database for your test Git repository. At this "
"point, you have 11 objects — 4 blobs, 3 trees, 3 commits, and 1 tag:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:421
msgid ""
"\t$ find .git/objects -type f\n"
"\t.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\n"
"\t.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\n"
"\t.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\n"
"\t.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\n"
"\t.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\n"
"\t.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag\n"
"\t.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\n"
"\t.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\n"
"\t.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\n"
"\t.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\n"
"\t.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:434
msgid ""
"Git compresses the contents of these files with zlib, and you’re not storing "
"much, so all these files collectively take up only 925 bytes. You’ll add "
"some larger content to the repository to demonstrate an interesting feature "
"of Git. Add the repo.rb file from the Grit library you worked with earlier — "
"this is about a 12K source code file:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:436
msgid ""
"\t$ curl https://raw.github.com/mojombo/grit/master/lib/grit/repo.rb > repo."
"rb\n"
"\t$ git add repo.rb\n"
"\t$ git commit -m 'added repo.rb'\n"
"\t[master 484a592] added repo.rb\n"
"\t 3 files changed, 459 insertions(+), 2 deletions(-)\n"
"\t delete mode 100644 bak/test.txt\n"
"\t create mode 100644 repo.rb\n"
"\t rewrite test.txt (100%)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:445
msgid ""
"If you look at the resulting tree, you can see the SHA-1 value your repo.rb "
"file got for the blob object:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:447
msgid ""
"\t$ git cat-file -p master^{tree}\n"
"\t100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n"
"\t100644 blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb\n"
"\t100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:452
msgid "You can then check how big is that object on your disk:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:454
msgid ""
"\t$ du -b .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e\n"
"\t4102\t.git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:457
msgid "Now, modify that file a little, and see what happens:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:459
msgid ""
"\t$ echo '# testing' >> repo.rb \n"
"\t$ git commit -am 'modified repo a bit'\n"
"\t[master ab1afef] modified repo a bit\n"
"\t 1 files changed, 1 insertions(+), 0 deletions(-)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:464
msgid ""
"Check the tree created by that commit, and you see something interesting:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:466
msgid ""
"\t$ git cat-file -p master^{tree}\n"
"\t100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n"
"\t100644 blob 05408d195263d853f09dca71d55116663690c27c      repo.rb\n"
"\t100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:471
msgid ""
"The blob is now a different blob, which means that although you added only a "
"single line to the end of a 400-line file, Git stored that new content as a "
"completely new object:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:473
msgid ""
"\t$ du -b .git/objects/05/408d195263d853f09dca71d55116663690c27c\n"
"\t4109\t.git/objects/05/408d195263d853f09dca71d55116663690c27c"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:476
msgid ""
"You have two nearly identical 4K objects on your disk. Wouldn’t it be nice "
"if Git could store one of them in full but then the second object only as "
"the delta between it and the first?"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:478
msgid ""
"It turns out that it can. The initial format in which Git saves objects on "
"disk is called a loose object format. However, occasionally Git packs up "
"several of these objects into a single binary file called a packfile in "
"order to save space and be more efficient. Git does this if you have too "
"many loose objects around, if you run the `git gc` command manually, or if "
"you push to a remote server. To see what happens, you can manually ask Git "
"to pack up the objects by calling the `git gc` command:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:480
msgid ""
"\t$ git gc\n"
"\tCounting objects: 17, done.\n"
"\tDelta compression using 2 threads.\n"
"\tCompressing objects: 100% (13/13), done.\n"
"\tWriting objects: 100% (17/17), done.\n"
"\tTotal 17 (delta 1), reused 10 (delta 0)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:487
msgid ""
"If you look in your objects directory, you’ll find that most of your objects "
"are gone, and a new pair of files has appeared:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:489
msgid ""
"\t$ find .git/objects -type f\n"
"\t.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293\n"
"\t.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n"
"\t.git/objects/info/packs\n"
"\t.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx\n"
"\t.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:496
msgid ""
"The objects that remain are the blobs that aren’t pointed to by any commit — "
"in this case, the \"what is up, doc?\" example and the \"test content\" "
"example blobs you created earlier. Because you never added them to any "
"commits, they’re considered dangling and aren’t packed up in your new "
"packfile."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:498
msgid ""
"The other files are your new packfile and an index. The packfile is a single "
"file containing the contents of all the objects that were removed from your "
"filesystem. The index is a file that contains offsets into that packfile so "
"you can quickly seek to a specific object. What is cool is that although the "
"objects on disk before you ran the `gc` were collectively about 8K in size, "
"the new packfile is only 4K. You’ve halved your disk usage by packing your "
"objects."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:500
msgid ""
"How does Git do this? When Git packs objects, it looks for files that are "
"named and sized similarly, and stores just the deltas from one version of "
"the file to the next. You can look into the packfile and see what Git did to "
"save space. The `git verify-pack` plumbing command allows you to see what "
"was packed up:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:502
msgid ""
"\t$ git verify-pack -v \\\n"
"\t  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx\n"
"\t0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 5400\n"
"\t05408d195263d853f09dca71d55116663690c27c blob   12908 3478 874\n"
"\t09f01cea547666f58d6a8d809583841a7c6f0130 tree   106 107 5086\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9 commit 225 151 322\n"
"\t1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 5381\n"
"\t3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   101 105 5211\n"
"\t484a59275031909e19aadb7c92262719cfcdf19a commit 226 153 169\n"
"\t83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 5362\n"
"\t9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    136 127 5476\n"
"\t9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   7 18 5193 1 \\\n"
"\t  05408d195263d853f09dca71d55116663690c27c\n"
"\tab1afef80fac8e34258ff41fc1b867c702daa24b commit 232 157 12\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d commit 226 154 473\n"
"\td8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 5316\n"
"\te3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4352\n"
"\tf8f51d7d8a1760462eca26eebafde32087499533 tree   106 107 749\n"
"\tfa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 856\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d commit 177 122 627\n"
"\tchain length = 1: 1 object\n"
"\tpack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:525
msgid ""
"Here, the `9bc1d` blob, which if you remember was the first version of your "
"repo.rb file, is referencing the `05408` blob, which was the second version "
"of the file. The third column in the output is the size of the object’s "
"content, so you can see that the content of `05408` takes up 12K, but that "
"of `9bc1d` only takes up 7 bytes. What is also interesting is that the "
"second version of the file is the one that is stored intact, whereas the "
"original version is stored as a delta — this is because you’re most likely "
"to need faster access to the most recent version of the file."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:527
msgid ""
"The really nice thing about this is that it can be repacked at any time. Git "
"will occasionally repack your database automatically, always trying to save "
"more space. You can also manually repack at any time by running `git gc` by "
"hand."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:529
msgid "## The Refspec ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:531
msgid ""
"Throughout this book, you’ve used simple mappings from remote branches to "
"local references; but they can be more complex.\n"
"Suppose you add a remote like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:534
msgid "\t$ git remote add origin git@github.com:schacon/simplegit-progit.git"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:536
msgid ""
"It adds a section to your `.git/config` file, specifying the name of the "
"remote (`origin`), the URL of the remote repository, and the refspec for "
"fetching:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:538
msgid ""
"\t[remote \"origin\"]\n"
"\t       url = git@github.com:schacon/simplegit-progit.git\n"
"\t       fetch = +refs/heads/*:refs/remotes/origin/*"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:542
msgid ""
"The format of the refspec is an optional `+`, followed by `<src>:<dst>`, "
"where `<src>` is the pattern for references on the remote side and `<dst>` "
"is where those references will be written locally. The `+` tells Git to "
"update the reference even if it isn’t a fast-forward."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:544
msgid ""
"In the default case that is automatically written by a `git remote add` "
"command, Git fetches all the references under `refs/heads/` on the server "
"and writes them to `refs/remotes/origin/` locally. So, if there is a "
"`master` branch on the server, you can access the log of that branch locally "
"via"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:546
msgid ""
"\t$ git log origin/master\n"
"\t$ git log remotes/origin/master\n"
"\t$ git log refs/remotes/origin/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:550
msgid ""
"They’re all equivalent, because Git expands each of them to `refs/remotes/"
"origin/master`."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:552
msgid ""
"If you want Git instead to pull down only the `master` branch each time, and "
"not every other branch on the remote server, you can change the fetch line to"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:554
msgid "\tfetch = +refs/heads/master:refs/remotes/origin/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:556
msgid ""
"This is just the default refspec for `git fetch` for that remote. If you "
"want to do something one time, you can specify the refspec on the command "
"line, too. To pull the `master` branch on the remote down to `origin/"
"mymaster` locally, you can run"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:558
msgid "\t$ git fetch origin master:refs/remotes/origin/mymaster"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:560
msgid ""
"You can also specify multiple refspecs. On the command line, you can pull "
"down several branches like so:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:562
msgid ""
"\t$ git fetch origin master:refs/remotes/origin/mymaster \\\n"
"\t   topic:refs/remotes/origin/topic\n"
"\tFrom git@github.com:schacon/simplegit\n"
"\t ! [rejected]        master     -> origin/mymaster  (non fast forward)\n"
"\t * [new branch]      topic      -> origin/topic"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:568
msgid ""
"In this case, the  master branch pull was rejected because it wasn’t a fast-"
"forward reference. You can override that by specifying the `+` in front of "
"the refspec."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:570
msgid ""
"You can also specify multiple refspecs for fetching in your configuration "
"file. If you want to always fetch the master and experiment branches, add "
"two lines:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:572
msgid ""
"\t[remote \"origin\"]\n"
"\t       url = git@github.com:schacon/simplegit-progit.git\n"
"\t       fetch = +refs/heads/master:refs/remotes/origin/master\n"
"\t       fetch = +refs/heads/experiment:refs/remotes/origin/experiment"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:577
msgid "You can’t use partial globs in the pattern, so this would be invalid:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:579
msgid "\tfetch = +refs/heads/qa*:refs/remotes/origin/qa*"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:581
msgid ""
"However, you can use namespacing to accomplish something like that. If you "
"have a QA team that pushes a series of branches, and you want to get the "
"master branch and any of the QA team’s branches but nothing else, you can "
"use a config section like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:583
msgid ""
"\t[remote \"origin\"]\n"
"\t       url = git@github.com:schacon/simplegit-progit.git\n"
"\t       fetch = +refs/heads/master:refs/remotes/origin/master\n"
"\t       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:588
msgid ""
"If you have a complex workflow process that has a QA team pushing branches, "
"developers pushing branches, and integration teams pushing and collaborating "
"on remote branches, you can namespace them easily this way."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:590
msgid "### Pushing Refspecs ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:592
msgid ""
"It’s nice that you can fetch namespaced references that way, but how does "
"the QA team get their branches into a `qa/` namespace in the first place? "
"You accomplish that by using refspecs to push."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:594
msgid ""
"If the QA team wants to push their `master` branch to `qa/master` on the "
"remote server, they can run"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:596
msgid "\t$ git push origin master:refs/heads/qa/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:598
msgid ""
"If they want Git to do that automatically each time they run `git push "
"origin`, they can add a `push` value to their config file:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:600
msgid ""
"\t[remote \"origin\"]\n"
"\t       url = git@github.com:schacon/simplegit-progit.git\n"
"\t       fetch = +refs/heads/*:refs/remotes/origin/*\n"
"\t       push = refs/heads/master:refs/heads/qa/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:605
msgid ""
"Again, this will cause a `git push origin` to push the local `master` branch "
"to the remote `qa/master` branch by default."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:607
msgid "### Deleting References ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:609
msgid ""
"You can also use the refspec to delete references from the remote server by "
"running something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:611
msgid "\t$ git push origin :topic"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:613
msgid ""
"Because the refspec is `<src>:<dst>`, by leaving off the `<src>` part, this "
"basically says to make the topic branch on the remote nothing, which deletes "
"it."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:615
msgid "## Transfer Protocols ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:617
msgid ""
"Git can transfer data between two repositories in two major ways: over HTTP "
"and via the so-called smart protocols used in the `file://`, `ssh://`, and "
"`git://` transports. This section will quickly cover how these two main "
"protocols operate."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:619
msgid "### The Dumb Protocol ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:621
msgid ""
"Git transport over HTTP is often referred to as the dumb protocol because it "
"requires no Git-specific code on the server side during the transport "
"process. The fetch process is a series of GET requests, where the client can "
"assume the layout of the Git repository on the server. Let’s follow the "
"`http-fetch` process for the simplegit library:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:623
msgid "\t$ git clone http://github.com/schacon/simplegit-progit.git"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:625
msgid ""
"The first thing this command does is pull down the `info/refs` file. This "
"file is written by the `update-server-info` command, which is why you need "
"to enable that as a `post-receive` hook in order for the HTTP transport to "
"work properly:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:627
msgid ""
"\t=> GET info/refs\n"
"\tca82a6dff817ec66f44342007202690a93763949     refs/heads/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:630
msgid ""
"Now you have a list of the remote references and SHAs. Next, you look for "
"what the HEAD reference is so you know what to check out when you’re "
"finished:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:632
msgid ""
"\t=> GET HEAD\n"
"\tref: refs/heads/master"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:635
msgid ""
"You need to check out the `master` branch when you’ve completed the "
"process.\n"
"At this point, you’re ready to start the walking process. Because your "
"starting point is the `ca82a6` commit object you saw in the `info/refs` "
"file, you start by fetching that:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:638
msgid ""
"\t=> GET objects/ca/82a6dff817ec66f44342007202690a93763949\n"
"\t(179 bytes of binary data)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:641
msgid ""
"You get an object back — that object is in loose format on the server, and "
"you fetched it over a static HTTP GET request. You can zlib-uncompress it, "
"strip off the header, and look at the commit content:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:643
msgid ""
"\t$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949\n"
"\ttree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\n"
"\tparent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tauthor Scott Chacon <schacon@gmail.com> 1205815931 -0700\n"
"\tcommitter Scott Chacon <schacon@gmail.com> 1240030591 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:651
msgid ""
"Next, you have two more objects to retrieve — `cfda3b`, which is the tree of "
"content that the commit we just retrieved points to; and `085bb3`, which is "
"the parent commit:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:653
msgid ""
"\t=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\t(179 bytes of data)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:656
msgid "That gives you your next commit object. Grab the tree object:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:658
msgid ""
"\t=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf\n"
"\t(404 - Not Found)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:661
msgid ""
"Oops — it looks like that tree object isn’t in loose format on the server, "
"so you get a 404 response back. There are a couple of reasons for this — the "
"object could be in an alternate repository, or it could be in a packfile in "
"this repository. Git checks for any listed alternates first:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:663
msgid ""
"\t=> GET objects/info/http-alternates\n"
"\t(empty file)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:666
msgid ""
"If this comes back with a list of alternate URLs, Git checks for loose files "
"and packfiles there — this is a nice mechanism for projects that are forks "
"of one another to share objects on disk. However, because no alternates are "
"listed in this case, your object must be in a packfile. To see what "
"packfiles are available on this server, you need to get the `objects/info/"
"packs` file, which contains a listing of them (also generated by `update-"
"server-info`):"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:668
msgid ""
"\t=> GET objects/info/packs\n"
"\tP pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:671
msgid ""
"There is only one packfile on the server, so your object is obviously in "
"there, but you’ll check the index file to make sure. This is also useful if "
"you have multiple packfiles on the server, so you can see which packfile "
"contains the object you need:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:673
msgid ""
"\t=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx\n"
"\t(4k of binary data)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:676
msgid ""
"Now that you have the packfile index, you can see if your object is in it — "
"because the index lists the SHAs of the objects contained in the packfile "
"and the offsets to those objects. Your object is there, so go ahead and get "
"the whole packfile:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:678
msgid ""
"\t=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack\n"
"\t(13k of binary data)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:681
msgid ""
"You have your tree object, so you continue walking your commits. They’re all "
"also within the packfile you just downloaded, so you don’t have to do any "
"more requests to your server. Git checks out a working copy of the `master` "
"branch that was pointed to by the HEAD reference you downloaded at the "
"beginning."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:683
msgid "The entire output of this process looks like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:685
msgid ""
"\t$ git clone http://github.com/schacon/simplegit-progit.git\n"
"\tInitialized empty Git repository in /private/tmp/simplegit-progit/.git/\n"
"\tgot ca82a6dff817ec66f44342007202690a93763949\n"
"\twalk ca82a6dff817ec66f44342007202690a93763949\n"
"\tgot 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\tGetting alternates list for http://github.com/schacon/simplegit-progit."
"git\n"
"\tGetting pack list for http://github.com/schacon/simplegit-progit.git\n"
"\tGetting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835\n"
"\tGetting pack 816a9b2334da9953e530f27bcac22082a9f5b835\n"
"\t which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf\n"
"\twalk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\twalk a11bef06a3f659402fe7563abf99ad00de2209e6"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:698
msgid "### The Smart Protocol ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:700
msgid ""
"The HTTP method is simple but a bit inefficient. Using smart protocols is a "
"more common method of transferring data. These protocols have a process on "
"the remote end that is intelligent about Git — it can read local data and "
"figure out what the client has or needs and generate custom data for it. "
"There are two sets of processes for transferring data: a pair for uploading "
"data and a pair for downloading data."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:702
msgid "#### Uploading Data ####"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:704
msgid ""
"To upload data to a remote process, Git uses the `send-pack` and `receive-"
"pack` processes. The `send-pack` process runs on the client and connects to "
"a `receive-pack` process on the remote side."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:706
msgid ""
"For example, say you run `git push origin master` in your project, and "
"`origin` is defined as a URL that uses the SSH protocol. Git fires up the "
"`send-pack` process, which initiates a connection over SSH to your server. "
"It tries to run a command on the remote server via an SSH call that looks "
"something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:708
msgid ""
"\t$ ssh -x git@github.com \"git-receive-pack 'schacon/simplegit-progit."
"git'\"\n"
"\t005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status "
"delete-refs\n"
"\t003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic\n"
"\t0000"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:713
msgid ""
"The `git-receive-pack` command immediately responds with one line for each "
"reference it currently has — in this case, just the `master` branch and its "
"SHA. The first line also has a list of the server’s capabilities (here, "
"`report-status` and `delete-refs`)."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:715
msgid ""
"Each line starts with a 4-byte hex value specifying how long the rest of the "
"line is. Your first line starts with 005b, which is 91 in hex, meaning that "
"91 bytes remain on that line. The next line starts with 003e, which is 62, "
"so you read the remaining 62 bytes. The next line is 0000, meaning the "
"server is done with its references listing."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:717
msgid ""
"Now that it knows the server’s state, your `send-pack` process determines "
"what commits it has that the server doesn’t. For each reference that this "
"push will update, the `send-pack` process tells the `receive-pack` process "
"that information. For instance, if you’re updating the `master` branch and "
"adding an `experiment` branch, the `send-pack` response may look something "
"like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:719
msgid ""
"\t0085ca82a6dff817ec66f44342007202690a93763949  "
"15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status\n"
"\t00670000000000000000000000000000000000000000 "
"cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment\n"
"\t0000"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:723
msgid ""
"The SHA-1 value of all '0's means that nothing was there before — because "
"you’re adding the experiment reference. If you were deleting a reference, "
"you would see the opposite: all '0's on the right side."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:725
msgid ""
"Git sends a line for each reference you’re updating with the old SHA, the "
"new SHA, and the reference that is being updated. The first line also has "
"the client’s capabilities. Next, the client uploads a packfile of all the "
"objects the server doesn’t have yet. Finally, the server responds with a "
"success (or failure) indication:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:727
msgid "\t000Aunpack ok"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:729
msgid "#### Downloading Data ####"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:731
msgid ""
"When you download data, the `fetch-pack` and `upload-pack` processes are "
"involved. The client initiates a `fetch-pack` process that connects to an "
"`upload-pack` process on the remote side to negotiate what data will be "
"transferred down."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:733
msgid ""
"There are different ways to initiate the `upload-pack` process on the remote "
"repository. You can run via SSH in the same manner as the `receive-pack` "
"process. You can also initiate the process via the Git daemon, which listens "
"on a server on port 9418 by default. The `fetch-pack` process sends data "
"that looks like this to the daemon after connecting:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:735
msgid ""
"\t003fgit-upload-pack schacon/simplegit-progit.git\\0host=myserver.com\\0"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:737
msgid ""
"It starts with the 4 bytes specifying how much data is following, then the "
"command to run followed by a null byte, and then the server’s hostname "
"followed by a final null byte. The Git daemon checks that the command can be "
"run and that the repository exists and has public permissions. If everything "
"is cool, it fires up the `upload-pack` process and hands off the request to "
"it."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:739
msgid ""
"If you’re doing the fetch over SSH, `fetch-pack` instead runs something like "
"this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:741
msgid ""
"\t$ ssh -x git@github.com \"git-upload-pack 'schacon/simplegit-progit.git'\""
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:743
msgid ""
"In either case, after `fetch-pack` connects, `upload-pack` sends back "
"something like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:745
msgid ""
"\t0088ca82a6dff817ec66f44342007202690a93763949 HEAD\\0multi_ack thin-pack "
"\\\n"
"\t  side-band side-band-64k ofs-delta shallow no-progress include-tag\n"
"\t003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master\n"
"\t003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic\n"
"\t0000"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:751
msgid ""
"This is very similar to what `receive-pack` responds with, but the "
"capabilities are different. In addition, it sends back the HEAD reference so "
"the client knows what to check out if this is a clone."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:753
msgid ""
"At this point, the `fetch-pack` process looks at what objects it has and "
"responds with the objects that it needs by sending \"want\" and then the SHA "
"it wants. It sends all the objects it already has with \"have\" and then the "
"SHA. At the end of this list, it writes \"done\" to initiate the `upload-"
"pack` process to begin sending the packfile of the data it needs:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:755
msgid ""
"\t0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta\n"
"\t0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n"
"\t0000\n"
"\t0009done"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:760
msgid ""
"That is a very basic case of the transfer protocols. In more complex cases, "
"the client supports `multi_ack` or `side-band` capabilities; but this "
"example shows you the basic back and forth used by the smart protocol "
"processes."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:762
msgid "## Maintenance and Data Recovery ##"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:764
msgid ""
"Occasionally, you may have to do some cleanup — make a repository more "
"compact, clean up an imported repository, or recover lost work. This section "
"will cover some of these scenarios."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:766
msgid "### Maintenance ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:768
msgid ""
"Occasionally, Git automatically runs a command called \"auto gc\". Most of "
"the time, this command does nothing. However, if there are too many loose "
"objects (objects not in a packfile) or too many packfiles, Git launches a "
"full-fledged `git gc` command. The `gc` stands for garbage collect, and the "
"command does a number of things: it gathers up all the loose objects and "
"places them in packfiles, it consolidates packfiles into one big packfile, "
"and it removes objects that aren’t reachable from any commit and are a few "
"months old."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:770
msgid "You can run auto gc manually as follows:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:772
msgid "\t$ git gc --auto"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:774
msgid ""
"Again, this generally does nothing. You must have around 7,000 loose objects "
"or more than 50 packfiles for Git to fire up a real gc command. You can "
"modify these limits with the `gc.auto` and `gc.autopacklimit` config "
"settings, respectively."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:776
msgid ""
"The other thing `gc` will do is pack up your references into a single file. "
"Suppose your repository contains the following branches and tags:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:778
msgid ""
"\t$ find .git/refs -type f\n"
"\t.git/refs/heads/experiment\n"
"\t.git/refs/heads/master\n"
"\t.git/refs/tags/v1.0\n"
"\t.git/refs/tags/v1.1"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:784
msgid ""
"If you run `git gc`, you’ll no longer have these files in the `refs` "
"directory. Git will move them for the sake of efficiency into a file named `."
"git/packed-refs` that looks like this:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:786
msgid ""
"\t$ cat .git/packed-refs\n"
"\t# pack-refs with: peeled\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment\n"
"\tab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0\n"
"\t9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1\n"
"\t^1a410efbd13591db07496601ebc7a059dd55cfe9"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:794
msgid ""
"If you update a reference, Git doesn’t edit this file but instead writes a "
"new file to `refs/heads`. To get the appropriate SHA for a given reference, "
"Git checks for that reference in the `refs` directory and then checks the "
"`packed-refs` file as a fallback. However, if you can’t find a reference in "
"the `refs` directory, it’s probably in your `packed-refs` file."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:796
msgid ""
"Notice the last line of the file, which begins with a `^`. This means the "
"tag directly above is an annotated tag and that line is the commit that the "
"annotated tag points to."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:798
msgid "### Data Recovery ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:800
msgid ""
"At some point in your Git journey, you may accidentally lose a commit. "
"Generally, this happens because you force-delete a branch that had work on "
"it, and it turns out you wanted the branch after all; or you hard-reset a "
"branch, thus abandoning commits that you wanted something from. Assuming "
"this happens, how can you get your commits back?"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:802
msgid ""
"Here’s an example that hard-resets the master branch in your test repository "
"to an older commit and then recovers the lost commits. First, let’s review "
"where your repository is at this point:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:804
msgid ""
"\t$ git log --pretty=oneline\n"
"\tab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit\n"
"\t484a59275031909e19aadb7c92262719cfcdf19a added repo.rb\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d second commit\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:811
msgid "Now, move the `master` branch back to the middle commit:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:813
msgid ""
"\t$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9\n"
"\tHEAD is now at 1a410ef third commit\n"
"\t$ git log --pretty=oneline\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d second commit\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:820
msgid ""
"You’ve effectively lost the top two commits — you have no branch from which "
"those commits are reachable. You need to find the latest commit SHA and then "
"add a branch that points to it. The trick is finding that latest commit SHA "
"— it’s not like you’ve memorized it, right?"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:822
msgid ""
"Often, the quickest way is to use a tool called `git reflog`. As you’re "
"working, Git silently records what your HEAD is every time you change it. "
"Each time you commit or change branches, the reflog is updated. The reflog "
"is also updated by the `git update-ref` command, which is another reason to "
"use it instead of just writing the SHA value to your ref files, as we "
"covered in the \"Git References\" section of this chapter earlier.  You can "
"see where you’ve been at any time by running `git reflog`:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:824
msgid ""
"\t$ git reflog\n"
"\t1a410ef HEAD@{0}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD\n"
"\tab1afef HEAD@{1}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:828
msgid ""
"Here we can see the two commits that we have had checked out, however there "
"is not much information here.  To see the same information in a much more "
"useful way, we can run `git log -g`, which will give you a normal log output "
"for your reflog."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:830
msgid ""
"\t$ git log -g\n"
"\tcommit 1a410efbd13591db07496601ebc7a059dd55cfe9\n"
"\tReflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)\n"
"\tReflog message: updating HEAD\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri May 22 18:22:37 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:837
msgctxt "en/09-git-internals/01-chapter9.markdown:837"
msgid "\t    third commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:839
msgid ""
"\tcommit ab1afef80fac8e34258ff41fc1b867c702daa24b\n"
"\tReflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)\n"
"\tReflog message: updating HEAD\n"
"\tAuthor: Scott Chacon <schacon@gmail.com>\n"
"\tDate:   Fri May 22 18:15:24 2009 -0700"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:845
msgid "\t     modified repo a bit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:847
msgid ""
"It looks like the bottom commit is the one you lost, so you can recover it "
"by creating a new branch at that commit. For example, you can start a branch "
"named `recover-branch` at that commit (ab1afef):"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:849
msgid ""
"\t$ git branch recover-branch ab1afef\n"
"\t$ git log --pretty=oneline recover-branch\n"
"\tab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit\n"
"\t484a59275031909e19aadb7c92262719cfcdf19a added repo.rb\n"
"\t1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\n"
"\tcac0cab538b970a37ea1e769cbbde608743bc96d second commit\n"
"\tfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:857
msgid ""
"Cool — now you have a branch named `recover-branch` that is where your "
"`master` branch used to be, making the first two commits reachable again.\n"
"Next, suppose your loss was for some reason not in the reflog — you can "
"simulate that by removing `recover-branch` and deleting the reflog. Now the "
"first two commits aren’t reachable by anything:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:860
msgid ""
"\t$ git branch -D recover-branch\n"
"\t$ rm -Rf .git/logs/"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:863
msgid ""
"Because the reflog data is kept in the `.git/logs/` directory, you "
"effectively have no reflog. How can you recover that commit at this point? "
"One way is to use the `git fsck` utility, which checks your database for "
"integrity. If you run it with the `--full` option, it shows you all objects "
"that aren’t pointed to by another object:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:865
msgid ""
"\t$ git fsck --full\n"
"\tdangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4\n"
"\tdangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b\n"
"\tdangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9\n"
"\tdangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:871
msgid ""
"In this case, you can see your missing commit after the dangling commit. You "
"can recover it the same way, by adding a branch that points to that SHA."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:873
msgid "### Removing Objects ###"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:875
msgid ""
"There are a lot of great things about Git, but one feature that can cause "
"issues is the fact that a `git clone` downloads the entire history of the "
"project, including every version of every file. This is fine if the whole "
"thing is source code, because Git is highly optimized to compress that data "
"efficiently. However, if someone at any point in the history of your project "
"added a single huge file, every clone for all time will be forced to "
"download that large file, even if it was removed from the project in the "
"very next commit. Because it’s reachable from the history, it will always be "
"there."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:877
msgid ""
"This can be a huge problem when you’re converting Subversion or Perforce "
"repositories into Git. Because you don’t download the whole history in those "
"systems, this type of addition carries few consequences. If you did an "
"import from another system or otherwise find that your repository is much "
"larger than it should be, here is how you can find and remove large objects."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:879
msgid ""
"Be warned: this technique is destructive to your commit history. It rewrites "
"every commit object downstream from the earliest tree you have to modify to "
"remove a large file reference. If you do this immediately after an import, "
"before anyone has started to base work on the commit, you’re fine — "
"otherwise, you have to notify all contributors that they must rebase their "
"work onto your new commits."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:881
msgid ""
"To demonstrate, you’ll add a large file into your test repository, remove it "
"in the next commit, find it, and remove it permanently from the repository. "
"First, add a large object to your history:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:883
msgid ""
"\t$ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 > git."
"tbz2\n"
"\t$ git add git.tbz2\n"
"\t$ git commit -am 'added git tarball'\n"
"\t[master 6df7640] added git tarball\n"
"\t 1 files changed, 0 insertions(+), 0 deletions(-)\n"
"\t create mode 100644 git.tbz2"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:890
msgid ""
"Oops — you didn’t want to add a huge tarball to your project. Better get rid "
"of it:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:892
msgid ""
"\t$ git rm git.tbz2\n"
"\trm 'git.tbz2'\n"
"\t$ git commit -m 'oops - removed large tarball'\n"
"\t[master da3f30d] oops - removed large tarball\n"
"\t 1 files changed, 0 insertions(+), 0 deletions(-)\n"
"\t delete mode 100644 git.tbz2"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:899
msgid "Now, `gc` your database and see how much space you’re using:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:901
msgid ""
"\t$ git gc\n"
"\tCounting objects: 21, done.\n"
"\tDelta compression using 2 threads.\n"
"\tCompressing objects: 100% (16/16), done.\n"
"\tWriting objects: 100% (21/21), done.\n"
"\tTotal 21 (delta 3), reused 15 (delta 1)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:908
msgid ""
"You can run the `count-objects` command to quickly see how much space you’re "
"using:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:910
msgid ""
"\t$ git count-objects -v\n"
"\tcount: 4\n"
"\tsize: 16\n"
"\tin-pack: 21\n"
"\tpacks: 1\n"
"\tsize-pack: 2016\n"
"\tprune-packable: 0\n"
"\tgarbage: 0"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:919
msgid ""
"The `size-pack` entry is the size of your packfiles in kilobytes, so you’re "
"using 2MB. Before the last commit, you were using closer to 2K — clearly, "
"removing the file from the previous commit didn’t remove it from your "
"history. Every time anyone clones this repository, they will have to clone "
"all 2MB just to get this tiny project, because you accidentally added a big "
"file. Let’s get rid of it."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:921
msgid ""
"First you have to find it. In this case, you already know what file it is. "
"But suppose you didn’t; how would you identify what file or files were "
"taking up so much space? If you run `git gc`, all the objects are in a "
"packfile; you can identify the big objects by running another plumbing "
"command called `git verify-pack` and sorting on the third field in the "
"output, which is file size. You can also pipe it through the `tail` command "
"because you’re only interested in the last few largest files:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:923
msgid ""
"\t$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n "
"| tail -3\n"
"\te3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4667\n"
"\t05408d195263d853f09dca71d55116663690c27c blob   12908 3478 1189\n"
"\t7a9eb2fba2b1811321254ac360970fc169ba2330 blob   2056716 2056872 5401"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:928
msgid ""
"The big object is at the bottom: 2MB. To find out what file it is, you’ll "
"use the `rev-list` command, which you used briefly in Chapter 7. If you pass "
"`--objects` to `rev-list`, it lists all the commit SHAs and also the blob "
"SHAs with the file paths associated with them. You can use this to find your "
"blob’s name:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:930
msgid ""
"\t$ git rev-list --objects --all | grep 7a9eb2fb\n"
"\t7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:933
msgid ""
"Now, you need to remove this file from all trees in your past. You can "
"easily see what commits modified this file:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:935
msgid ""
"\t$ git log --pretty=oneline -- git.tbz2\n"
"\tda3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball\n"
"\t6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:939
msgid ""
"You must rewrite all the commits downstream from `6df76` to fully remove "
"this file from your Git history. To do so, you use `filter-branch`, which "
"you used in Chapter 6:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:941
msgid ""
"\t$ git filter-branch --index-filter \\\n"
"\t   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..\n"
"\tRewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'\n"
"\tRewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)\n"
"\tRef 'refs/heads/master' was rewritten"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:947
msgid ""
"The `--index-filter` option is similar to the `--tree-filter` option used in "
"Chapter 6, except that instead of passing a command that modifies files "
"checked out on disk, you’re modifying your staging area or index each time. "
"Rather than remove a specific file with something like `rm file`, you have "
"to remove it with `git rm --cached` — you must remove it from the index, not "
"from disk. The reason to do it this way is speed — because Git doesn’t have "
"to check out each revision to disk before running your filter, the process "
"can be much, much faster. You can accomplish the same task with `--tree-"
"filter` if you want. The `--ignore-unmatch` option to `git rm` tells it not "
"to error out if the pattern you’re trying to remove isn’t there. Finally, "
"you ask `filter-branch` to rewrite your history only from the `6df7640` "
"commit up, because you know that is where this problem started. Otherwise, "
"it will start from the beginning and will unnecessarily take longer."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:949
msgid ""
"Your history no longer contains a reference to that file. However, your "
"reflog and a new set of refs that Git added when you did the `filter-branch` "
"under `.git/refs/original` still do, so you have to remove them and then "
"repack the database. You need to get rid of anything that has a pointer to "
"those old commits before you repack:"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:951
msgid ""
"\t$ rm -Rf .git/refs/original\n"
"\t$ rm -Rf .git/logs/\n"
"\t$ git gc\n"
"\tCounting objects: 19, done.\n"
"\tDelta compression using 2 threads.\n"
"\tCompressing objects: 100% (14/14), done.\n"
"\tWriting objects: 100% (19/19), done.\n"
"\tTotal 19 (delta 3), reused 16 (delta 1)"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:960
msgid "Let’s see how much space you saved."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:962
msgid ""
"\t$ git count-objects -v\n"
"\tcount: 8\n"
"\tsize: 2040\n"
"\tin-pack: 19\n"
"\tpacks: 1\n"
"\tsize-pack: 7\n"
"\tprune-packable: 0\n"
"\tgarbage: 0"
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:971
msgid ""
"The packed repository size is down to 7K, which is much better than 2MB. You "
"can see from the size value that the big object is still in your loose "
"objects, so it’s not gone; but it won’t be transferred on a push or "
"subsequent clone, which is what is important. If you really wanted to, you "
"could remove the object completely by running `git prune --expire`."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:975
msgid ""
"You should have a pretty good understanding of what Git does in the "
"background and, to some degree, how it’s implemented. This chapter has "
"covered a number of plumbing commands — commands that are lower level and "
"simpler than the porcelain commands you’ve learned about in the rest of the "
"book. Understanding how Git works at a lower level should make it easier to "
"understand why it’s doing what it’s doing and also to write your own tools "
"and helping scripts to make your specific workflow work for you."
msgstr ""

#: en/09-git-internals/01-chapter9.markdown:977
msgid ""
"Git as a content-addressable filesystem is a very powerful tool that you can "
"easily use as more than just a VCS. I hope you can use your newfound "
"knowledge of Git internals to implement your own cool application of this "
"technology and feel more comfortable using Git in more advanced ways."
msgstr ""

#~ msgid ""
#~ "On Windows systems, Git looks for the `.gitconfig` file in the `$HOME` "
#~ "directory (`C:\\Documents and Settings\\$USER` for most people). It also still "
#~ "looks for /etc/gitconfig, although it’s relative to the MSys root, which is "
#~ "wherever you decide to install Git on your Windows system when you run the "
#~ "installer."
#~ msgstr ""
#~ "윈도우에서 Git은 `$HOME` Directory(`C:\\Documents and Settings\\$USER`)에 있는 "
#~ "`.gitconfig` 파일을 찾는다. 그리고 msysGit도 /etc/gitconfig를 가지고 있다. 경로는 MSys 루트에 따른 "
#~ "상대 경로다. 인스톨러로 msysGit을 설치할 때 설치 경로를 선택할 수 있다."
